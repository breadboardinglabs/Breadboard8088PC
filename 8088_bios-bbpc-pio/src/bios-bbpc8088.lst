     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.13.02, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table??
    45                                  ;	F000:E739	INT 14 Entry Point E729??
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; macro.inc - Defines macros
     3                              <1> ;       setloc
     4                              <1> ;-------------------------------------------------------------------------
     5                              <1> ;
     6                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     9                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;=========================================================================
    25                              <1> 
    26                              <1> ;=========================================================================
    27                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    28                              <1> ;-------------------------------------------------------------------------
    29                              <1> %imacro setloc  1.nolist
    30                              <1> %assign pad_bytes (%1-($-$$)-START)
    31                              <1> %if pad_bytes < 0
    32                              <1> %assign over_bytes -pad_bytes
    33                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
    34                              <1> %endif
    35                              <1> %if pad_bytes > 0
    36                              <1> %warning Inserting pad_bytes bytes
    37                              <1>  times  pad_bytes db 0FFh
    38                              <1> %endif
    39                              <1> %endm
    69                                  %include "config.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; config.inc - Compilation time settings and settings
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25                              <1> %define DATE		'09/29/23'	; BIOS release date MM/DD/YY
    26                              <1> %define VERSION		'1.0.0'		; BIOS version
    27                              <1> 
    28                              <1> ; Machine type is defined in the Makefile
    29                              <1> ;%define MACHINE_XI8088			; Xi 8088
    30                              <1> ;%define MACHINE_FE2010A 		; Faraday FE2010A
    31                              <1> ;%define MACHINE_BOOK8088		; Book8088
    32                              <1> ;%define MACHINE_HOMEBREW8088		; EMM Computers "Homebrew8088" board
    33                              <1> ;%define MACHINE_XT			; IBM PC/XT or highly compatible board
    34                              <1> ;%define MACHINE_BBPC8088	        ; Breadboard PC 8088
    35                              <1> 
    36                              <1> 					; FIXME: not implemented yet
    37                              <1> 
    38                              <1> ; Settings for Xi 8088
    39                              <1> %ifdef MACHINE_XI8088
    40                              <1> %define	START		8000h		; BIOS starts at offset 8000h
    41                              <1> %define MODEL_BYTE	0FCh		; Pretend it is an IBM PC/AT
    42                              <1> %define AT_RTC				; Has AT-compatible RTC
    43                              <1> %define AT_RTC_NVRAM			; Use AT RTC for BIOS configuration
    44                              <1> %define AT_NMI				; Use port 70h for NMI enable/disable
    45                              <1> %define AT_DELAY			; Use refresh bit of port 61h for delays
    46                              <1> %define SECOND_PIC			; Has two PICs (AT-style)
    47                              <1> %define AT_KEYBOARD			; Has AT-compatible keyboard controller
    48                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
    49                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
    50                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
    51                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
    52                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
    53                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
    54                              <1> 					; EBDA is required for PS/2 aux support
    55                              <1> %endif ; MACHINE_XI8088
    56                              <1> 
    57                              <1> ; Settings for FE2010A
    58                              <1> %ifdef MACHINE_FE2010A
    59                              <1> %define	START		0A000h		; BIOS starts at offset 0A000h
    60                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
    61                              <1> %define AT_RTC				; Has AT-compatible RTC
    62                              <1> %define AT_RTC_AUTODETECT		; Autodetect RTC presence
    63                              <1> %define FLASH_NVRAM			; Use Flash ROM for BIOS configuration
    64                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
    65                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
    66                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
    67                              <1> %define PIT_DELAY			; Use PIT polling for delays
    68                              <1> %endif ; MACHINE_FE2010A
    69                              <1> 
    70                              <1> ; Settings for Book8088
    71                              <1> %ifdef MACHINE_BOOK8088
    72                              <1> %define	START		0C000h		; BIOS starts at 0C000h - 16 KiB total
    73                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
    74                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
    75                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
    76                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
    77                              <1> %define PIT_DELAY			; Use PIT polling for delays
    78                              <1> %endif ; MACHINE_BOOK8088
    79                              <1> 
    80                              <1> ; Settings for IBM PC/XT
    81                              <1> %ifdef MACHINE_XT
    82                              <1> ;%define	START		0E000h		; BIOS starts at offset 0E000h
    83                              <1> %define	START		0C000h		; FIXME: more ROM for development
    84                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
    85                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
    86                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
    87                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
    88                              <1> %define PIT_DELAY			; Use PIT polling for delays
    89                              <1> %endif ; MACHINE_XT
    90                              <1> 
    91                              <1> %ifdef MACHINE_HOMEBREW8088
    92                              <1> %define	START		0C000h		; FIXME: more ROM for development
    93                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
    94                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
    95                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
    96                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
    97                              <1> %define PIT_DELAY			; Use PIT polling for delays
    98                              <1> %define AT_KEYBOARD			; Has AT-compatible keyboard controller
    99                              <1> %define DISABLE_KBD_DURING_INTERRUPTS
   100                              <1> ; Optional: Enable DS12885/DS12887 based RTC
   101                              <1> ;%define AT_RTC				; Has AT-compatible RTC
   102                              <1> ;%define AT_RTC_AUTODETECT		; Autodetect RTC presence
   103                              <1> ; Specify RTC I/O address if different from the default 0x70
   104                              <1> ;%define AT_RTC_PORT	2A0h
   105                              <1> %endif ; MACHINE_HOMEBREW8088
   106                              <1> 
   107                              <1> ; Settings for Breadboard PC 8088
   108                              <1> %ifdef MACHINE_BBPC8088
   109                              <1> %define	START		9000h		; BIOS starts at offset 8000h by default but 9000 leaves 4K for XTIDE Tiny BIOS
   110                              <1> ;%define	START		8000h		     ; BIOS starts at offset 8000h
   111                              <1> ;%define MODEL_BYTE	0FEh		; IBM PC/XT - no key lock!
   112                              <1> ;%define MODEL_BYTE	0F8h		; IBM PS/2 Model 80 (Sub Model 0 by default is 16 MHz Model 80) with Keyboard/Aux on 60 & 64 needed for MS MOUSE Driver to see PS/2 Mouse (model 25&30 are odd)! Could also try FC AT and Sub 4 Model 50 Sub 5 Model 60
   113                              <1> ;%define MODEL_SUB_BYTE  000h            ; (PS/2 Model 80 F8 Sub Model 0 by default is 16 MHz Model 80) Model FC PC/AT and Sub 0 or  Sub 4 PS/2 Model 50 Sub 5 PS/2 Model 60
   114                              <1> %define MODEL_BYTE	0FCh		; IBM PC-AT Sub 4 Model 50 Sub 5 Model 60
   115                              <1> %define MODEL_SUB_BYTE  004h            ; (PS/2 Model 80 F8 Sub Model 0 by default is 16 MHz Model 80) Model FC PC/AT and Sub 0 or  Sub 4 PS/2 Model 50 Sub 5 PS/2 Model 60
   116                              <1> ;%define MODEL_BYTE	0FCh		; Pretend it is an IBM PC/AT but this may enable key lock stuff disabling mouse!
   117                              <1> %define AT_RTC				; Has AT-compatible RTC
   118                              <1> %define AT_RTC_NVRAM			; Use AT RTC for BIOS configuration
   119                              <1> %define AT_DELAY			; Use refresh bit of port 61h for delays
   120                              <1> %define AT_KEYBOARD			; Has AT-compatible keyboard controller
   121                              <1> %define SECOND_PIC			; Has two PICs (AT-style)
   122                              <1> %define PS2_MOUSE			       ; Enable PS/2 auxiliary device support
   123                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   124                              <1> %define MIN_RAM_SIZE	32		 ; At least 32 KiB to boot the system
   125                              <1> %define MAX_RAM_SIZE	512		 ; Scan this much memory during POST
   126                              <1> %define RAM_TEST_BLOCK 16384 ; block size for RAM test
   127                              <1> ;%define PIT_DELAY			; Use PIT polling for delays
   128                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   129                              <1> 					; EBDA is required for PS/2 aux support
   130                              <1> %endif ; MACHINE_BBPC8088
   131                              <1> 
   132                              <1> ; Automatic settings based on the machine settings above
   133                              <1> %ifdef AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   134                              <1> %define BIOS_SETUP			; Include BIOS setup utility
   135                              <1> %endif ; AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   136                              <1> 
   137                              <1> ; Note: while Book8088 does have a turbo mode, it is not software controlled
   138                              <1> %ifdef MACHINE_XI8088 or MACHINE_FE2010A
   139                              <1> %define TURBO_MODE			; Has turbo mode
   140                              <1> %endif ; MACHINE_XI8088 or MACHINE_FE2010A
   141                              <1> 
   142                              <1> ; Default floppy drives configuration for systems without NVRAM/Flash ROM setup
   143                              <1> ; First digit = drive A, second = drive B
   144                              <1> ; 0 - none,	1 - 360 KB,	2 - 1.2 MB
   145                              <1> ; 3 - 720 KB,	4 - 1.44 MB,	6 - 2.88 MB
   146                              <1> ; Use two 1.44 MB drives by default, changed to 1 A-MSB B-LSB
   147                              <1> %define DEFAULT_FLOPPIES 40h
    70                                  %include "errno.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25                              <1> e_boot equ	00h		; Boot the OS
    26                              <1> e_cpu_test	equ	01h		; Start of BIOS POST, CPU test
    27                              <1> e_init_cfg	equ	02h		; Initial chipset configuration:
    28                              <1> 					; initialize PPI, disable NMI
    29                              <1> 					; disable turbo mode, disable display
    30                              <1> e_init_dmac	equ	03h		; Initialize DMAC initialized
    31                              <1> e_low_ram_test	equ	04h		; Test low 32 KiB of RAM
    32                              <1> e_int_table	equ	05h		; Initialize interrupt table
    33                              <1> e_pit_init	equ	06h		; Initialize PIT (timer)
    34                              <1> 					; play power on melody
    35                              <1> e_pic_init	equ	07h		; Initialize PIC
    36                              <1> e_kbd_init	equ	08h		; Initialize KBC and keyboard
    37                              <1> e_int_ena	equ	09h		; Enable interrupts
    38                              <1> e_vid_bios_scan	equ	10h		; Locate video BIOS
    39                              <1> e_vid_bios_init	equ	11h		; Initialize video BIOS
    40                              <1> e_vid_no_bios	equ	12h		; No video BIOS, using MDA/CGA
    41                              <1> e_rtc_init	equ	20h		; Initialize RTC
    42                              <1> e_cpu_detect	equ	21h		; Detect CPU type
    43                              <1> e_fpu_detect	equ	22h		; Detect FPU
    44                              <1> e_serial_scan	equ	24h		; Detect serial ports
    45                              <1> e_parallel_scan	equ	25h		; Detect parallel ports
    46                              <1> e_ram_start	equ	30h		; Start RAM test
    47                              <1> e_ram_complete	equ	31h		; RAM test completed
    48                              <1> e_ram_esc	equ	32h		; RAM test canceled
    49                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
    50                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found, initizalize
    51                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
    52                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
    53                              <1> e_cpu_fail	equ	52h		; CPU test failed
    54                              <1> e_low_ram_fail	equ	54h		; Low 32 KiB RAM test failed
    55                              <1> e_ram_fail	equ	55h		; RAM test failed
    56                              <1> e_kbc_flsh_fail	equ	60h		; Unable to flush KBC output buffer
    57                              <1> e_kbc_cmd_fail	equ	61h		; Unable to send command to KBC
    58                              <1> e_kbc_test_fail	equ	62h		; Keyboard controller self test failed
    59                              <1> e_kbc_int_fail	equ	63h		; Keyboard interface test failed
    60                              <1> e_kbd_bat_fail	equ	70h		; Keyboard BAT test failed
    61                              <1> e_kbd_dis_fail	equ	71h		; Keyboard disable command failed
    62                              <1> e_kbd_ena_fail	equ	72h		; Keyboard enable command failed
    63                              <1> ;-------------------------------------------------------------------------
    64                              <1> ; Minor numbers for keyboard errors
    65                              <1> e_kbd_tout_fail	equ	01h		; Keyboard timeout sending command
    66                              <1> e_kbd_resp_fail	equ	02h		; Keyboard no response
    67                              <1> e_kbd_nack_fail	equ	03h		; Acknowledge response was expected
    68                              <1> 					; but keyboard have sent something else
    69                              <1> e_kbd_rsp2_fail	equ	04h		; Keyboard no response byte 2 for BAT
    70                              <1> e_kbd_nbat_fail	equ	05h		; BAT OK response was expected
    71                              <1> 					; but keyboard have sent something else
    72                              <1> e_kbd_test_fail	equ	06h		; Keyboard controller test failed
    73                              <1> e_kbd_int_fail	equ	07h		; Keyboard interface test failed
    71                                  
    72                                  bioscseg	equ	0F000h
    73                                  biosdseg	equ	0040h
    74                                  
    75                                  pic1_reg0	equ	20h
    76                                  pic1_reg1	equ	21h
    77                                  pit_ch0_reg	equ	40h
    78                                  pit_ch1_reg	equ	41h
    79                                  pit_ch2_reg	equ	42h
    80                                  pit_ctl_reg	equ	43h
    81                                  
    82                                  ; 8255 PPI port A I/O register - Read - keyboard data
    83                                  ppi_pa_reg	equ	60h	; 8255 PPI port A I/O register
    84                                  
    85                                  ; Port 61h - 8255 PPI Port B - Write only
    86                                  ppi_pb_reg	equ	61h	; 8255 PPI port B I/O register
    87                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
    88                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
    89                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
    90                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
    91                                  
    92                                  %ifdef MACHINE_XT or MACHINE_FE2010A
    93                                  ; Port 62h - 8255 PPI Port C - Read only
    94                                  ppi_pc_reg	equ	62h	; 8255 PPI port C I/O registerA
    95                                  ; XT DIP switches 1-4 (read when bit 3 of PPI Port B is 1)
    96                                  sw_post_loop	equ	01h	; XT DIP switch 1 - 1 = Loop on POST
    97                                  sw_fpu_present	equ	02h	; XT DIP switch 2 - 1 = FPU present
    98                                  sw_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
    99                                  sw_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   100                                  sw_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   101                                  sw_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   102                                  ; XT DIP switches 5-8 (read when bit 3 of PPI Port B is 0)
   103                                  sw_vid_none	equ	00h	; XT DIP switches 5-6 - No video, EGA, or VGA
   104                                  sw_vid_color_40	equ	01h	; XT DIP switches 5-6 - CGA, 80x25
   105                                  sw_vid_color_80	equ	02h	; XT DIP switches 5-6 - CGA, 40x25
   106                                  sw_vid_mono	equ	03h	; XT DIP switches 5-6 - Monochome, 80x25
   107                                  sw_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   108                                  sw_two_floppies	equ	01h	; XT DIP switches 7-8 - Two floppies
   109                                  sw_three_floppies equ	02h	; XT DIP switches 7-8 - Three floppies
   110                                  sw_four_floppies  equ	03h	; XT DIP switches 7-8 - Four floppies
   111                                  %endif ; MACHINE_XT or MACHINE_FE2010A
   112                                  
   113                                  ; FE2010/FE2010 - Ports 62h-63h
   114                                  %ifdef MACHINE_FE2010A
   115                                  ; Port 62h - Chipset Control Register - Write
   116                                  fe_control_reg	equ	62h
   117                                  fe_fpu_present	equ	02h	; FPU present
   118                                  fe_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
   119                                  fe_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   120                                  fe_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   121                                  fe_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   122                                  fe_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   123                                  fe_two_floppies	equ	40h	; XT DIP switches 7-8 - Two floppies
   124                                  
   125                                  ; Port 63h - Chipset Configuration Register - Write only
   126                                  fe_config_reg	equ	63h	; Chipset configuration register
   127                                  fe_par_disable	equ	01h	; Disable memory parity checking
   128                                  fe_fpu_nma_ena 	equ	02h	; Enable FPU NMI
   129                                  fe_config_lock	equ	08h	; Write lock of control register and
   130                                  				; bits 0-4 of configuration register
   131                                  fe_clk_7_norm	equ	40h	; FE2010A 7.15 MHz CPU clock frequency, normal WS
   132                                  fe_clk_7_fast	equ	60h	; FE2010A 7.15 MHz CPU clock frequency, fast WS
   133                                  fe_clk_9_norm	equ	80h	; FE2010A 9.54 MHz CPU clock frequency, normal WS
   134                                  fe_clk_9_fast	equ	0C0h	; FE2010A 9.54 MHz CPU clock frequency, fast WS
   135                                  %endif ; MACHINE_FE2010A
   136                                  
   137                                  ; IBM PC/XT - Port 63h - 8255 PPI Control Word
   138                                  %ifdef MACHINE_XT
   139                                  ppi_cwd_reg	equ	63h	; 8255 PPI control word register
   140                                  ppi_cwd_value	equ	99h	; 8255 PPI control word value for IBM XT:
   141                                  				; Port A - mode 0 (simple I/O), input
   142                                  				; Port B - mode 0 (simple I/O), output
   143                                  				; Port C - output
   144                                  %endif ; MACHINE_XT
   145                                  
   146                                  post_reg	equ	80h	; POST status output port
   147                                  %ifdef AT_NMI
   148                                  nmi_mask_reg	equ	70h
   149                                  %else ; AT_NMI
   150                                  nmi_mask_reg	equ	0A0h
   151                                  %endif ; AT_NMI
   152                                  %ifdef SECOND_PIC
   153                                  pic2_reg0	equ	0A0h
   154                                  pic2_reg1	equ	0A1h
   155                                  %endif ; SECOND_PIC
   156                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   157                                  cga_mode_reg	equ	3D8h
   158                                  mda_mode_reg	equ	3B8h
   159                                  
   160                                  ; NMI mask (written to 0A0h)
   161                                  nmi_disable	equ	00h	; disable NMI
   162                                  nmi_disa_mask	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   163                                  nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   164                                  
   165                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   166                                  
   167                                  ;========================================================================
   168                                  ; BIOS data area variables
   169                                  ;------------------------------------------------------------------------
   170                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   171                                  				; or 0 if port doesn't exist
   172                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   173                                  				; or 0 if port doesn't exist
   174                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   175                                  equipment_list	equ	10h	; word - equpment list
   176                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   177                                  equip_fpu	equ	0000000000000010b	; FPU installed
   178                                  equip_mouse	equ	0000000000000100b
   179                                  equip_video	equ	0000000000110000b	; video type bit mask
   180                                  equip_color_40	equ	0000000000010000b	; color 40x24 (mode 1)
   181                                  equip_color_80	equ	0000000000100000b	; color 80x25 (mode 3)
   182                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   183                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   184                                  ;			|||||||||||||||`-- floppy drives installed
   185                                  ;			||||||||||||||`-- FPU installed
   186                                  ;			|||||||||||||`-- PS/2 mouse installed
   187                                  ;			||||||||||||`-- reserved
   188                                  ;			||||||||||`--- initial video mode
   189                                  ;			||||||||`---- number of floppy drives - 1
   190                                  ;			|||||||`---- O = DMA installed
   191                                  ;			||||`------ number of serial ports
   192                                  ;			|||`------ game adapter installed
   193                                  ;			||`------ internal modem?!
   194                                  ;			`------- number of parallel ports
   195                                  
   196                                  post_flags	equ	12h	; byte - post flags
   197                                  post_setup	equ	01h	; run NVRAM setup
   198                                  memory_size	equ	13h	; word - memory size in KiB
   199                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   200                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   201                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   202                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   203                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   204                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   205                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   206                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   207                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   208                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   209                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   210                                  video_mode	equ	49h	; byte - active video mode number
   211                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   212                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   213                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   214                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   215                                  video_cur_shape	equ	60h	; word - cursor shape
   216                                  video_page	equ	62h	; byte - active video page
   217                                  video_port	equ	63h	; word - I/O port for the display adapter
   218                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   219                                  video_palet_reg	equ	66h	; byte - color palette
   220                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   221                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   222                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   223                                  new_day		equ	70h	; byte - 1 = new day flag
   224                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   225                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   226                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   227                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   228                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   229                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   230                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   231                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   232                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   233                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   234                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   235                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   236                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   237                                  vga_table_ptr	equ	0A8h	; dword - BIOS Video Save/Override Pointer
   238                                  				;       Table address
   239                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   240                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   241                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   242                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   243                                  
   244                                  ;=========================================================================
   245                                  ; Extended BIOS data area variables
   246                                  ;-------------------------------------------------------------------------
   247                                  ebda_size	equ	0h
   248                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   249                                  mouse_flags_1	equ	26h
   250                                  mouse_flags_2	equ	27h
   251                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   252                                  
   253                                  	org	START		; Use only upper 32 KiB of ROM
   254                                  
   255                                  ;=========================================================================
   256                                  ; Includes
   257                                  ;-------------------------------------------------------------------------
   258                                  %include	"messages.inc"		; POST messages
     1                              <1> ;=========================================================================
     2                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
    26                              <1> %ifdef MACHINE_XI8088
    27                              <1> 		db	"Xi 8088"
    28                              <1> %endif ; MACHINE_XI8088
    29                              <1> %ifdef MACHINE_FE2010A
    30                              <1> 		db	"Micro 8088"
    31                              <1> %endif ; MACHINE_FE2010A
    32                              <1> %ifdef MACHINE_BOOK8088
    33                              <1> 		db	"Book8088"
    34                              <1> %endif ; MACHINE_BOOK8088
    35                              <1> %ifdef MACHINE_XT
    36                              <1> 		db	"XT 8088"
    37                              <1> %endif ; MACHINE_XT
    38                              <1> %ifdef MACHINE_HOMEBREW8088
    39                              <1> 		db	"Homebrew8088"
    40                              <1> %endif ; MACHINE_HOMEBREW8088
    41                              <1> %ifdef MACHINE_BBPC8088
    42 00000002 424220504320383038- <1> 		db	"BB PC 8088"
    42 0000000B 38                  <1>
    43                              <1> %endif ; MACHINE_BBPC8088
    44 0000000C 2042494F532C205665- <1> 		db	" BIOS, Version "
    44 00000015 7273696F6E20        <1>
    45 0000001B 312E302E30          <1> 		db	VERSION
    46 00000020 2E20                <1> 		db	". "
    47 00000022 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2023 Sergey Kiselev", 0Dh, 0Ah
    47 0000002B 202843292032303130- <1>
    47 00000034 202D20323032332053- <1>
    47 0000003D 6572676579204B6973- <1>
    47 00000046 656C65760D0A        <1>
    48 0000004C 446973747269627574- <1> 		db	"Distributed under the terms of "
    48 00000055 656420756E64657220- <1>
    48 0000005E 746865207465726D73- <1>
    48 00000067 206F6620            <1>
    49 0000006B 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
    49 00000074 656E6572616C205075- <1>
    49 0000007D 626C6963204C696365- <1>
    49 00000086 6E73650D0A          <1>
    50 0000008B 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
    51 0000008E 6E6F6E6500          <1> msg_none	db	'none', 00h
    52 00000093 3A2000              <1> msg_colon	db	': ', 00h
    53 00000096 3B2000              <1> msg_semicolon	db	'; ', 00h
    54                              <1> %ifdef TURBO_MODE
    55                              <1> msg_cpu_clk	db	'CPU clock frequency:        ', 00h
    56                              <1> msg_at		db	' @ ', 00h
    57                              <1> msg_clk_4_77mhz	db	'4.77 MHz ', 00h
    58                              <1> %ifdef MACHINE_FE2010A
    59                              <1> msg_clk_7_16mhz	db	'7.16 MHz ', 00h
    60                              <1> msg_clk_9_55mhz	db	'9.55 MHz ', 00h
    61                              <1> %else ; MACHINE_FE2010A
    62                              <1> msg_clk_turbo	db	'Turbo ', 00h
    63                              <1> %endif ; MACHINE_FE2010A
    64                              <1> %endif ; TURBO_MODE
    65                              <1> %ifdef MACHINE_HOMEBREW8088
    66                              <1> msg_est		db      'Estimated Clock:            ',00h
    67                              <1> msg_mhz		db	"MHz", 00h
    68                              <1> msg_ticks	db	"Ticks ", 0F7h, 00h
    69                              <1> %endif ; MACHINE_HOMEBREW8088
    70 00000099 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
    70 000000A2 6573736F723A202020- <1>
    70 000000AB 202020202020202020- <1>
    70 000000B4 2000                <1>
    71 000000B6 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
    71 000000BF 637320436F2D70726F- <1>
    71 000000C8 636573736F723A2020- <1>
    71 000000D1 2000                <1>
    72 000000D3 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 00h
    72 000000DC 382027373800        <1>
    73 000000E2 5741524E494E473A20- <1> msg_cpu_bug	db      'WARNING: This CPU does not disable interrupts '
    73 000000EB 546869732043505520- <1>
    73 000000F4 646F6573206E6F7420- <1>
    73 000000FD 64697361626C652069- <1>
    73 00000106 6E7465727275707473- <1>
    73 0000010F 20                  <1>
    74 00000110 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
    74 00000119 64696E67207365676D- <1>
    74 00000122 656E74207265676973- <1>
    74 0000012B 74657273210D0A00    <1>
    75 00000133 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
    75 0000013C 3820273831206F7220- <1>
    75 00000145 6C617465722C20      <1>
    76 0000014C 6F72204F4B492D6465- <1> 		db      'or OKI-designed 80C88', 00h
    76 00000155 7369676E6564203830- <1>
    76 0000015E 43383800            <1>
    77 00000162 4861727269732D6465- <1> msg_cpu_harris  db      'Harris-designed 80C88', 00h
    77 0000016B 7369676E6564203830- <1>
    77 00000174 43383800            <1>
    78 00000178 4E45432056323000    <1> msg_cpu_nec_v20 db      'NEC V20', 00h
    79                              <1> %ifdef MACHINE_HOMEBREW8088
    80                              <1> msg_cpu_nec_v40	db	'NEC V40', 00h
    81                              <1> %endif ; MACHINE_HOMEBREW8088
    82 00000180 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
    82 00000189 370D0A00            <1>
    83                              <1> %ifdef MACHINE_FE2010A
    84                              <1> msg_chipset	db	'Chipset:                    ', 00h
    85                              <1> msg_fe2010a	db	'Faraday FE2010A', 0Dh, 0Ah, 00h
    86                              <1> msg_pt8010af	db	'Proton PT8010AF', 0Dh, 0Ah, 00h
    87                              <1> %endif ; MACHINE_FE2010A
    88 0000018D 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
    88 00000196 646170746572205479- <1>
    88 0000019F 70653A202020202020- <1>
    88 000001A8 2000                <1>
    89 000001AA 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
    89 000001B3 566964656F2042494F- <1>
    89 000001BC 532050726573656E74- <1>
    89 000001C5 290D0A00            <1>
    90 000001C9 434741202838307832- <1> msg_disp_cga_80	db      'CGA (80x25)', 0Dh, 0Ah, 00h
    90 000001D2 35290D0A00          <1>
    91 000001D7 434741202834307832- <1> msg_disp_cga_40	db      'CGA (40x25)', 0Dh, 0Ah, 00h
    91 000001E0 35290D0A00          <1>
    92 000001E5 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
    92 000001EE 7263756C65730D0A00  <1>
    93 000001F7 52544320285265616C- <1> msg_rtc		db	'RTC (Real Time Clock):      ', 00h
    93 00000200 2054696D6520436C6F- <1>
    93 00000209 636B293A2020202020- <1>
    93 00000212 2000                <1>
    94 00000214 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
    94 0000021D 736B20647269766573- <1>
    94 00000226 3A2020202020202020- <1>
    94 0000022F 20447269766520303A- <1>
    94 00000238 2000                <1>
    95 0000023A 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
    95 00000243 3A2000              <1>
    96 00000246 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
    96 0000024F 2E32352200          <1>
    97 00000254 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
    97 0000025D 2E32352200          <1>
    98 00000262 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
    98 0000026B 2E352200            <1>
    99 0000026F 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
    99 00000278 332E352200          <1>
   100 0000027D 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   100 00000286 332E352200          <1>
   101                              <1> %ifdef PS2_MOUSE
   102 0000028B 50532F322041757820- <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   102 00000294 44657669636520284D- <1>
   102 0000029D 6F757365293A202020- <1>
   102 000002A6 2000                <1>
   103                              <1> %endif ; PS2_MOUSE
   104 000002A8 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   104 000002B1 00                  <1>
   105 000002B2 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   106 000002BB 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   106 000002C4 7274733A2020202020- <1>
   106 000002CD 202020202020202020- <1>
   106 000002D6 2000                <1>
   107 000002D8 434F4D00            <1> msg_serial_com	db	'COM', 00h
   108 000002DC 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   108 000002E5 506F7274733A202020- <1>
   108 000002EE 202020202020202020- <1>
   108 000002F7 2000                <1>
   109 000002F9 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   110 000002FD 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   110 00000306 414D20284553432074- <1>
   110 0000030F 6F20736B6970293A20- <1>
   110 00000318 2000                <1>
   111 0000031A 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   111 00000323 4661756C7479206D65- <1>
   111 0000032C 6D6F72792064657465- <1>
   111 00000335 637465642061742000  <1>
   112 0000033E 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   112 00000347 6E76656E74696F6E61- <1>
   112 00000350 6C2052414D3A202020- <1>
   112 00000359 202000              <1>
   113                              <1> %ifdef EBDA_SIZE
   114 0000035C 526573657276656420- <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   114 00000365 666F7220454244413A- <1>
   114 0000036E 202020202020202020- <1>
   114 00000377 2000                <1>
   115 00000379 417661696C61626C65- <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   115 00000382 20436F6E76656E7469- <1>
   115 0000038B 6F6E616C2052414D3A- <1>
   115 00000394 2000                <1>
   116                              <1> %endif ; EBDA_SIZE
   117 00000396 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   118 0000039D 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   118 000003A6 65642C207072657373- <1>
   118 000003AF 20616E79206B657920- <1>
   118 000003B8 746F20747279206167- <1>
   118 000003C1 61696E2E2E2E0D0A00  <1>
   119 000003CA 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   119 000003D3 5349430D0A00        <1>
   120 000003D9 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   120 000003E2 5320657874656E7369- <1>
   120 000003EB 6F6E20524F4D206174- <1>
   120 000003F4 2000                <1>
   121 000003F6 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   121 000003FF 6C697A696E672E2E2E- <1>
   121 00000408 0D0A00              <1>
   122 0000040B 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   122 00000414 532E2E2E0D0A00      <1>
   123                              <1> %ifdef AT_RTC
   124 0000041B 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   124 00000424 432062617474657279- <1>
   124 0000042D 206973206261640D0A- <1>
   124 00000436 00                  <1>
   125                              <1> %endif ; AT_RTC
   126                              <1> %ifdef AT_RTC_NVRAM
   127 00000437 4552524F523A204E56- <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   127 00000440 52414D20636865636B- <1>
   127 00000449 73756D20697320696E- <1>
   127 00000452 76616C69642C20      <1>
   128 00000459 6C6F6164696E672064- <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   128 00000462 656661756C74207661- <1>
   128 0000046B 6C75657320746F204E- <1>
   128 00000474 5652414D0D0A00      <1>
   129                              <1> %endif ; AT_RTC_NVRAM
   130                              <1> %ifdef BIOS_SETUP
   131 0000047B 507265737320463120- <1> msg_setup	db	'Press F1 to run BIOS setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   131 00000484 746F2072756E204249- <1>
   131 0000048D 4F532073657475702E- <1>
   131 00000496 2E2E0D0A0D0A00      <1>
   132 0000049D 0D0A57656C636F6D65- <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the BIOS setup utility', 00h
   132 000004A6 20746F207468652042- <1>
   132 000004AF 494F53207365747570- <1>
   132 000004B8 207574696C69747900  <1>
   133 000004C1 0D0A                <1> msg_set_help	db	0Dh, 0Ah
   134 000004C3 42494F532073657475- <1> 		db	'BIOS setup commands:', 0Dh, 0Ah
   134 000004CC 7020636F6D6D616E64- <1>
   134 000004D5 733A0D0A            <1>
   135 000004D9 66202D204368616E67- <1> 		db	'f - Change first floppy drive type', 0Dh, 0Ah
   135 000004E2 652066697273742066- <1>
   135 000004EB 6C6F70707920647269- <1>
   135 000004F4 766520747970650D0A  <1>
   136 000004FD 67202D204368616E67- <1> 		db	'g - Change second floppy drive type', 0Dh, 0Ah
   136 00000506 65207365636F6E6420- <1>
   136 0000050F 666C6F707079206472- <1>
   136 00000518 69766520747970650D- <1>
   136 00000521 0A                  <1>
   137 00000522 65202D204368616E67- <1> 		db	'e - Change BIOS extension ROM scan settings', 0Dh, 0Ah
   137 0000052B 652042494F53206578- <1>
   137 00000534 74656E73696F6E2052- <1>
   137 0000053D 4F4D207363616E2073- <1>
   137 00000546 657474696E67730D0A  <1>
   138 0000054F 6D202D204368616E67- <1> 		db	'm - Change memory test settings', 0Dh, 0Ah
   138 00000558 65206D656D6F727920- <1>
   138 00000561 746573742073657474- <1>
   138 0000056A 696E67730D0A        <1>
   139                              <1> %ifdef TURBO_MODE
   140                              <1> 		db	'c - Set default CPU clock frequency', 0Dh, 0Ah
   141                              <1> %endif ; TURBO_MODE
   142                              <1> %ifdef MACHINE_FE2010A
   143                              <1> 		db	's - Change wait state settings', 0Dh, 0Ah
   144                              <1> %endif ; MACHINE_FE2010A
   145 00000570 00                  <1> 		db	00h
   146                              <1> %ifdef AT_RTC
   147 00000571 74202D205365742074- <1> msg_set_rtc_help db	't - Set time', 0Dh, 0Ah
   147 0000057A 696D650D0A          <1>
   148 0000057F 64202D205365742064- <1> 		db	'd - Set date', 0Dh, 0Ah, 00h
   148 00000588 6174650D0A00        <1>
   149                              <1> %endif ; AT_RTC
   150 0000058E 70202D205072696E74- <1> msg_set_def_help db	'p - Print current settings', 0Dh, 0Ah
   150 00000597 2063757272656E7420- <1>
   150 000005A0 73657474696E67730D- <1>
   150 000005A9 0A                  <1>
   151 000005AA 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   151 000005B3 6368616E6765732061- <1>
   151 000005BC 6E6420657869740D0A  <1>
   152 000005C5 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   152 000005CE 776974686F75742073- <1>
   152 000005D7 6176696E6720636861- <1>
   152 000005E0 6E6765730D0A        <1>
   153 000005E6 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   153 000005EF 746869732068656C70- <1>
   153 000005F8 0D0A00              <1>
   154 000005FB 0D0A456E7465722063- <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   154 00000604 6F6D6D616E64202868- <1>
   154 0000060D 20666F722068656C70- <1>
   154 00000616 293A2000            <1>
   155                              <1> %ifdef TURBO_MODE
   156                              <1> msg_set_clk_help db 	0Dh, 0Ah
   157                              <1> 		db	'CPU clock frequency options:', 0Dh, 0Ah
   158                              <1> 		db	'4 - 4.77 MHz', 0Dh, 0Ah
   159                              <1> %ifdef MACHINE_FE2010A
   160                              <1> 		db	'7 - 7.16 MHz', 0Dh, 0Ah
   161                              <1> 		db	'9 - 9.55 MHz', 0Dh, 0Ah, 00h
   162                              <1> %else ; MACHINE_FE2010A
   163                              <1> 		db	't - Turbo', 0Dh, 0Ah, 00h
   164                              <1> %endif ; MACHINE_FE2010A
   165                              <1> msg_set_clk_prmt db	0Dh, 0Ah, 'Enter CPU clock frequency (h for help): '
   166                              <1> 		db	00h
   167                              <1> %endif ; TURBO_MODE
   168                              <1> %ifdef AT_RTC
   169 0000061A 456E7465722074696D- <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   169 00000623 65202868683A6D6D3A- <1>
   169 0000062C 7373293A2000        <1>
   170 00000632 456E74657220646174- <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   170 0000063B 652028595959592D4D- <1>
   170 00000644 4D2D4444293A2000    <1>
   171 0000064C 4552524F523A20496E- <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   171 00000655 76616C69642074696D- <1>
   171 0000065E 652E0D0A00          <1>
   172 00000663 4552524F523A20496E- <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   172 0000066C 76616C696420646174- <1>
   172 00000675 652E0D0A00          <1>
   173                              <1> %endif ; AT_RTC
   174 0000067A 0D0A                <1> msg_set_fd_help	db	0Dh, 0Ah
   175 0000067C 466C6F707079206472- <1> 		db	'Floppy drive types:', 0Dh, 0Ah
   175 00000685 697665207479706573- <1>
   175 0000068E 3A0D0A              <1>
   176 00000691 30202D204E6F742069- <1> 		db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   176 0000069A 6E7374616C6C656420- <1>
   176 000006A3 202033202D20373230- <1>
   176 000006AC 204B422C20332E3522- <1>
   176 000006B5 0D0A                <1>
   177 000006B7 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   177 000006C0 422C20352E32352220- <1>
   177 000006C9 202034202D20312E34- <1>
   177 000006D2 34204D422C20332E35- <1>
   177 000006DB 220D0A              <1>
   178 000006DE 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah, 00h
   178 000006E7 422C20352E32352220- <1>
   178 000006F0 202036202D20322E38- <1>
   178 000006F9 38204D422C20332E35- <1>
   178 00000702 220D0A00            <1>
   179 00000706 536574757020636F6D- <1> msg_set_sub_help db	'Setup commands:', 0Dh, 0Ah
   179 0000070F 6D616E64733A0D0A    <1>
   180 00000717 72202D205265747572- <1> 		db	'r - Return to the main menu', 0Dh, 0Ah
   180 00000720 6E20746F2074686520- <1>
   180 00000729 6D61696E206D656E75- <1>
   180 00000732 0D0A                <1>
   181 00000734 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   181 0000073D 746869732068656C70- <1>
   181 00000746 0D0A00              <1>
   182 00000749 0D0A456E7465722066- <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   182 00000752 6C6F70707920647269- <1>
   182 0000075B 766520747970652028- <1>
   182 00000764 6820666F722068656C- <1>
   182 0000076D 70293A20            <1>
   183 00000771 00                  <1> 		db	00h
   184 00000772 5363616E2046303030- <1> msg_set_ext	db	'Scan F0000-F8FFF area for BIOS extension ROMs (y/n): '
   184 0000077B 302D46384646462061- <1>
   184 00000784 72656120666F722042- <1>
   184 0000078D 494F5320657874656E- <1>
   184 00000796 73696F6E20524F4D73- <1>
   184 0000079F 2028792F6E293A20    <1>
   185 000007A7 00                  <1> 		db	00h
   186 000007A8 46303030302D463846- <1> msg_ext_scan	db	'F0000-F8FFF BIOS ext. scan: ', 00h
   186 000007B1 46462042494F532065- <1>
   186 000007BA 78742E207363616E3A- <1>
   186 000007C3 2000                <1>
   187 000007C5 456E61626C65206D65- <1> msg_set_mem_tst	db	'Enable memory test (y/n): ', 00h
   187 000007CE 6D6F72792074657374- <1>
   187 000007D7 2028792F6E293A2000  <1>
   188 000007E0 4D656D6F7279207465- <1> msg_mem_test	db	'Memory test:                ', 00h
   188 000007E9 73743A202020202020- <1>
   188 000007F2 202020202020202020- <1>
   188 000007FB 2000                <1>
   189                              <1> %ifdef MACHINE_FE2010A
   190                              <1> msg_set_ws	db	'Fast wait states (y/n, h for help): ', 00h
   191                              <1> msg_ws_help	db	0Dh, 0Ah
   192                              <1> 		db	'Wait states configuration for FE2010A and PT8010AF:',
   193                              <1> 		db	0Dh, 0Ah
   194                              <1> 		db	'7.15 MHz, normal: I/O - 4 WS; Upper memory - 2 WS'
   195                              <1> 		db	0Dh, 0Ah
   196                              <1> 		db	'7.15 MHz, fast:   I/O - 4 WS; Upper memory - 0 WS'
   197                              <1> 		db	0Dh, 0Ah
   198                              <1> 		db	'9.54 MHz, normal: I/O - 6 WS; Upper memory - 4 WS'
   199                              <1> 		db	0Dh, 0Ah
   200                              <1> 		db	'9.54 MHz, fast:   I/O - 4 WS; Upper memory - 2 WS'
   201                              <1> 		db	0Dh, 0Ah, 00h
   202                              <1> msg_ws		db	'Fast wait states:           ', 00h
   203                              <1> %endif ; MACHINE_FE2010A
   204 000007FD 456E61626C656400    <1> msg_enabled	db	'Enabled', 00h
   205 00000805 44697361626C656400  <1> msg_disabled	db	'Disabled', 00h
   206                              <1> %ifdef FLASH_NVRAM
   207                              <1> msg_saving	db	0Dh, 0Ah, 'Saving configuration to Flash ROM... ', 00h
   208                              <1> msg_save_ok	db	'OK', 0Dh, 0Ah, 00h
   209                              <1> msg_save_error	db	'ERROR', 0Dh, 0Ah, 00h
   210                              <1> %endif ; FLASH_NVRAM
   211                              <1> %endif ; BIOS_SETUP
   212 0000080E [8E00]              <1> tbl_floppy	dw	msg_none
   213 00000810 [4602]              <1> 		dw	msg_floppy_360
   214 00000812 [5402]              <1> 		dw	msg_floppy_1200
   215 00000814 [6202]              <1> 		dw	msg_floppy_720
   216 00000816 [6F02]              <1> 		dw	msg_floppy_1440
   217 00000818 [8E00]              <1> 		dw	msg_none
   218 0000081A [7D02]              <1> 		dw	msg_floppy_2880
   219 0000081C [8E00]              <1> 		dw	msg_none
   259                                  %ifndef MACHINE_XT			; No space in XT ROM for font
   260                                  %include	"fnt80-FF.inc"		; font for graphics modes
     1                              <1> ;=========================================================================
     2                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
     3                              <1> ;       Characters from 80h to 0FFh
     4                              <1> ;-------------------------------------------------------------------------
     5                              <1> ;
     6                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     7                              <1> ;
     8                              <1> ; This font is borrowed from kbd package (alt-8x8)
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> int_1F:
    25 0000081E 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
    26 00000826 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
    27 0000082E 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
    28 00000836 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
    29 0000083E 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
    30 00000846 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
    31 0000084E DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
    32 00000856 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
    33 0000085E 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
    34 00000866 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
    35 0000086E 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
    36 00000876 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
    37 0000087E C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
    38 00000886 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
    39 0000088E 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
    40 00000896 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
    41 0000089E 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
    42 000008A6 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
    43 000008AE 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
    44 000008B6 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
    45 000008BE 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
    46 000008C6 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
    47 000008CE 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
    48 000008D6 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
    49 000008DE DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
    50 000008E6 DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
    51 000008EE E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
    52 000008F6 C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
    53 000008FE 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
    54 00000906 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
    55 0000090E CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
    56 00000916 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
    57 0000091E 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
    58 00000926 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
    59 0000092E 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
    60 00000936 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
    61 0000093E 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
    62 00000946 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
    63 0000094E 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
    64 00000956 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
    65 0000095E 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
    66 00000966 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
    67 0000096E 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
    68 00000976 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
    69 0000097E 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
    70 00000986 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
    71 0000098E 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
    72 00000996 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
    73 0000099E 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
    74 000009A6 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
    75 000009AE DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
    76 000009B6 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
    77 000009BE 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
    78 000009C6 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
    79 000009CE 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
    80 000009D6 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
    81 000009DE 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
    82 000009E6 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
    83 000009EE 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
    84 000009F6 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
    85 000009FE 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
    86 00000A06 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
    87 00000A0E 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
    88 00000A16 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
    89 00000A1E 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
    90 00000A26 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
    91 00000A2E 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
    92 00000A36 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
    93 00000A3E 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
    94 00000A46 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
    95 00000A4E 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
    96 00000A56 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
    97 00000A5E 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
    98 00000A66 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
    99 00000A6E 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   100 00000A76 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   101 00000A7E 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   102 00000A86 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   103 00000A8E 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   104 00000A96 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   105 00000A9E 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   106 00000AA6 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   107 00000AAE 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   108 00000AB6 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   109 00000ABE 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   110 00000AC6 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   111 00000ACE 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   112 00000AD6 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   113 00000ADE 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   114 00000AE6 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   115 00000AEE 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   116 00000AF6 FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   117 00000AFE 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   118 00000B06 F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   119 00000B0E 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   120 00000B16 FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   121 00000B1E 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   122 00000B26 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   123 00000B2E 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   124 00000B36 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   125 00000B3E 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   126 00000B46 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   127 00000B4E 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   128 00000B56 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   129 00000B5E 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   130 00000B66 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   131 00000B6E 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   132 00000B76 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   133 00000B7E 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   134 00000B86 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   135 00000B8E 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   136 00000B96 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   137 00000B9E 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   138 00000BA6 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   139 00000BAE 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   140 00000BB6 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   141 00000BBE 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   142 00000BC6 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   143 00000BCE 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   144 00000BD6 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   145 00000BDE 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   146 00000BE6 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   147 00000BEE 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   148 00000BF6 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   149 00000BFE 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   150 00000C06 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   151 00000C0E 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   152 00000C16 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   261                                  %endif ; MACHINE_XT
   262                                  ;%include	"inttrace.inc"		; Uncomment for interrupt debugging
   263                                  %ifdef AT_RTC
   264                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
     1                              <1> ;=========================================================================
     2                              <1> ; rtc.inc - RTC/CMOS read and write functions
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25                              <1> ;-------------------------------------------------------------------------
    26                              <1> ; RTC ports
    27                              <1> rtc_addr_reg	equ	70h	; RTC address port
    28                              <1> rtc_data_reg	equ	71h	; RTC data port
    29                              <1> 
    30                              <1> ;-------------------------------------------------------------------------
    31                              <1> ; locations in RTC and NVRAM
    32                              <1> cmos_seconds	equ	00h	; seconds location in RTC
    33                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
    34                              <1> cmos_minutes	equ	02h	; minutes location in RTC
    35                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
    36                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
    37                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
    38                              <1> cmos_day	equ	06h	; day location in RTC
    39                              <1> cmos_date	equ	07h	; date location in RTC
    40                              <1> cmos_month	equ	08h	; month location in RTC
    41                              <1> cmos_year	equ	09h	; year location in RTC
    42                              <1> cmos_floppy	equ	10h	; floppy type byte
    43                              <1> cmos_equip	equ	14h	; equipment byte
    44                              <1> cmos_config_a	equ	2Dh	; BIOS configuration byte A
    45                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
    46                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
    47                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
    48                              <1> 
    49                              <1> ;-------------------------------------------------------------------------
    50                              <1> ; RTC control register and their bits
    51                              <1> cmos_control_a	equ	0Ah	; RTC control A register
    52                              <1> cmos_uip	equ	80h	; RTC update in progress bit
    53                              <1> cmos_control_b	equ	0Bh	; RTC control B register
    54                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
    55                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
    56                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
    57                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
    58                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
    59                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
    60                              <1> cmos_control_c	equ	0Ch	; RTC control C register
    61                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
    62                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
    63                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
    64                              <1> cmos_control_d	equ	0Dh	; RTC control D register
    65                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
    66                              <1> 
    67                              <1> ;=========================================================================
    68                              <1> ; rtc_read - Read byte from RTC or CMOS memory
    69                              <1> ; Input:
    70                              <1> ;	AL - address and NMI enable bit
    71                              <1> ;		bits 6-0 - address of byte to read
    72                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
    73                              <1> ; Output:
    74                              <1> ;	AL = byte from RTC
    75                              <1> ;-------------------------------------------------------------------------
    76                              <1> rtc_read:
    77 00000C1E FA                  <1> 	cli
    78                              <1> %ifndef AT_RTC_PORT
    79 00000C1F E670                <1> 	out	rtc_addr_reg,al
    80 00000C21 EB00                <1> 	jmp	$+2
    81 00000C23 EB00                <1> 	jmp	$+2
    82 00000C25 EB00                <1> 	jmp	$+2
    83 00000C27 EB00                <1> 	jmp	$+2
    84 00000C29 E471                <1> 	in	al,rtc_data_reg
    85                              <1> %else ; AT_RTC_PORT
    86                              <1> 	push	dx
    87                              <1> 	mov	dx,AT_RTC_PORT
    88                              <1> 	out	dx,al
    89                              <1> 	jmp	$+2
    90                              <1> 	jmp	$+2
    91                              <1> 	jmp	$+2
    92                              <1> 	jmp	$+2
    93                              <1> 	inc	dx			; DX = RTC data register
    94                              <1> 	in	al,dx
    95                              <1> 	pop	dx
    96                              <1> %endif ; AT_RTC_PORT
    97 00000C2B FB                  <1> 	sti
    98 00000C2C C3                  <1> 	ret
    99                              <1> 
   100                              <1> ;=========================================================================
   101                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   102                              <1> ; Input:
   103                              <1> ;	AL - address and NMI enable bit
   104                              <1> ;		bits 6-0 - address of byte to read
   105                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   106                              <1> ;	AH = byte to write to RTC
   107                              <1> ;-------------------------------------------------------------------------
   108                              <1> rtc_write:
   109 00000C2D FA                  <1> 	cli
   110                              <1> %ifndef AT_RTC_PORT
   111 00000C2E E670                <1> 	out	rtc_addr_reg,al
   112 00000C30 EB00                <1> 	jmp	$+2
   113 00000C32 EB00                <1> 	jmp	$+2
   114 00000C34 EB00                <1> 	jmp	$+2
   115 00000C36 EB00                <1> 	jmp	$+2
   116 00000C38 86E0                <1> 	xchg	ah,al
   117 00000C3A E671                <1> 	out	rtc_data_reg,al
   118                              <1> %else ; AT_RTC_PORT
   119                              <1> 	push	dx
   120                              <1> 	mov	dx,AT_RTC_PORT
   121                              <1> 	out	dx,al
   122                              <1> 	jmp	$+2
   123                              <1> 	jmp	$+2
   124                              <1> 	jmp	$+2
   125                              <1> 	jmp	$+2
   126                              <1> 	xchg	ah,al
   127                              <1> 	inc	dx			; DX = RTC data register
   128                              <1> 	out	dx,al
   129                              <1> 	pop	dx
   130                              <1> %endif ; AT_RTC_PORT
   131 00000C3C 86E0                <1> 	xchg	ah,al
   132 00000C3E FB                  <1> 	sti
   133 00000C3F C3                  <1> 	ret
   134                              <1> 
   135                              <1> ;=========================================================================
   136                              <1> ; set_system_timer - set timer variables to RTC time
   137                              <1> ;-------------------------------------------------------------------------
   138                              <1> set_system_timer:
   139 00000C40 50                  <1> 	push	ax
   140 00000C41 53                  <1> 	push	bx
   141 00000C42 51                  <1> 	push	cx
   142 00000C43 52                  <1> 	push	dx
   143 00000C44 56                  <1> 	push	si
   144 00000C45 57                  <1> 	push	di
   145                              <1> 
   146 00000C46 B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   147 00000C48 CD1A                <1> 	int	1Ah
   148                              <1> 
   149                              <1> ; convert time to ticks * 2^11
   150                              <1> 
   151                              <1> ; ticks = seconds * 37287
   152 00000C4A 88F0                <1> 	mov	al,dh
   153 00000C4C E80301              <1> 	call	bcd_to_binary		; convert seconds to binary
   154                              <1> 
   155 00000C4F BAA791              <1> 	mov	dx,37287
   156 00000C52 F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   157                              <1> 
   158 00000C54 89C6                <1> 	mov	si,ax
   159 00000C56 89D7                <1> 	mov	di,dx
   160                              <1> 
   161                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   162 00000C58 88C8                <1> 	mov	al,cl
   163 00000C5A E8F500              <1> 	call	bcd_to_binary		; convert minutes to binary
   164                              <1> 
   165 00000C5D 89C3                <1> 	mov	bx,ax
   166 00000C5F BA2023              <1> 	mov	dx,8992
   167 00000C62 F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   168                              <1> 
   169 00000C64 01C6                <1> 	add	si,ax
   170 00000C66 11D7                <1> 	adc	di,dx
   171                              <1> 
   172 00000C68 89D8                <1> 	mov	ax,bx
   173 00000C6A BA2200              <1> 	mov	dx,34
   174 00000C6D F7E2                <1> 	mul	dx
   175                              <1> 
   176 00000C6F 01C7                <1> 	add	di,ax
   177                              <1> 
   178                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   179 00000C71 88E8                <1> 	mov	al,ch
   180 00000C73 E8DC00              <1> 	call	bcd_to_binary		; convert hours to binary
   181                              <1> 
   182 00000C76 89C3                <1> 	mov	bx,ax
   183 00000C78 BA6A3B              <1> 	mov	dx,15210
   184 00000C7B F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   185                              <1> 
   186 00000C7D 01C6                <1> 	add	si,ax
   187 00000C7F 11D7                <1> 	adc	di,dx
   188                              <1> 
   189 00000C81 89D8                <1> 	mov	ax,bx
   190 00000C83 BA0008              <1> 	mov	dx,2048
   191 00000C86 F7E2                <1> 	mul	dx			; AX = hours * 2048
   192                              <1> 
   193 00000C88 01C7                <1> 	add	di,ax
   194                              <1> 
   195                              <1> ; CX:DX = DI:SI / 2048
   196 00000C8A B10B                <1> 	mov	cl,11
   197 00000C8C D3EE                <1> 	shr	si,cl
   198 00000C8E 89FA                <1> 	mov	dx,di
   199 00000C90 B105                <1> 	mov	cl,5
   200 00000C92 D3E2                <1> 	shl	dx,cl
   201 00000C94 09F2                <1> 	or	dx,si
   202                              <1> 
   203 00000C96 B10B                <1> 	mov	cl,11
   204 00000C98 D3EF                <1> 	shr	di,cl
   205 00000C9A 89F9                <1> 	mov	cx,di
   206                              <1> 
   207                              <1> 					; CX = high word of tick count
   208                              <1> 					; DX = low word of tick count
   209                              <1> 	
   210 00000C9C B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   211 00000C9E CD1A                <1> 	int	1Ah
   212 00000CA0 5F                  <1> 	pop	di
   213 00000CA1 5E                  <1> 	pop	si
   214 00000CA2 5A                  <1> 	pop	dx
   215 00000CA3 59                  <1> 	pop	cx
   216 00000CA4 5B                  <1> 	pop	bx
   217 00000CA5 58                  <1> 	pop	ax
   218 00000CA6 C3                  <1> 	ret
   219                              <1> 
   220                              <1> ;=========================================================================
   221                              <1> ; rtc_init - Initialize RTC
   222                              <1> ; Notes:
   223                              <1> ;	- makes sure RTC battery is OK, resets time if not
   224                              <1> ;	- disables RTC interrupts
   225                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   226                              <1> ;-------------------------------------------------------------------------
   227                              <1> rtc_init:
   228 00000CA7 50                  <1> 	push	ax
   229 00000CA8 53                  <1> 	push	bx
   230 00000CA9 51                  <1> 	push	cx
   231 00000CAA 52                  <1> 	push	dx
   232 00000CAB 56                  <1> 	push	si
   233 00000CAC B020                <1> 	mov	al,e_rtc_init
   234 00000CAE E680                <1> 	out	post_reg,al
   235 00000CB0 B00A                <1> 	mov	al,cmos_control_a	; select control A register
   236 00000CB2 B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   237                              <1> 					; set SQW frequency to 1.024 KHz
   238 00000CB4 E876FF              <1> 	call	rtc_write		; write control register A
   239                              <1> 
   240                              <1> %ifdef AT_RTC_AUTODETECT
   241                              <1> 	call	rtc_read		; read back control A register
   242                              <1> 	cmp	al,26h
   243                              <1> 	jne	.exit			; RTC is not responding, exit
   244                              <1> %endif ; AT_RTC_AUTODETECT
   245                              <1> 
   246 00000CB7 B00B                <1> 	mov	al,cmos_control_b
   247 00000CB9 E862FF              <1> 	call	rtc_read
   248 00000CBC 88C4                <1> 	mov	ah,al
   249 00000CBE 80E401              <1> 	and	ah,cmos_dse		; clear all bits except of DSE
   250 00000CC1 80CC02              <1> 	or	ah,cmos_24hours		; set 24 hours bit, keep BCD format and
   251                              <1> 					; interrupts disabled
   252 00000CC4 B00B                <1> 	mov	al,cmos_control_b
   253 00000CC6 E864FF              <1> 	call	rtc_write		; write control register B
   254                              <1> 
   255 00000CC9 B00C                <1> 	mov	al,cmos_control_c
   256 00000CCB E850FF              <1> 	call	rtc_read		; read control register C - reset
   257                              <1> 					; interrupt flags
   258                              <1> 
   259 00000CCE B00D                <1> 	mov	al,cmos_control_d
   260 00000CD0 E84BFF              <1> 	call	rtc_read		; read control register D
   261 00000CD3 A880                <1> 	test	al,cmos_vrt
   262 00000CD5 7518                <1> 	jnz	.1			; RTC battery is OK
   263 00000CD7 BE[1B04]            <1> 	mov	si,msg_rtc_bad
   264 00000CDA E8D31B              <1> 	call	print
   265                              <1> ; RTC is bad, set initial time
   266 00000CDD B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   267 00000CDF 31C9                <1> 	xor	cx,cx
   268 00000CE1 31D2                <1> 	xor	dx,dx
   269 00000CE3 CD1A                <1> 	int	1Ah
   270 00000CE5 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   271 00000CE7 B91020              <1> 	mov	cx,2010h		; year 2010
   272 00000CEA BA0101              <1> 	mov	dx,0101h		; January 1st
   273 00000CED CD1A                <1> 	int	1Ah
   274                              <1> 
   275                              <1> .1:
   276                              <1> 
   277 00000CEF E84EFF              <1> 	call	set_system_timer		; set timer variables to RTC time
   278                              <1> 
   279                              <1> %ifdef AT_RTC_NVRAM
   280                              <1> ; compare NVRAM checksum with stored value
   281                              <1> 
   282 00000CF2 E86F00              <1> 	call	nvram_checksum
   283                              <1> 
   284 00000CF5 B02E                <1> 	mov	al,cmos_sum_hi
   285 00000CF7 E824FF              <1> 	call	rtc_read
   286 00000CFA 88C4                <1> 	mov	ah,al
   287 00000CFC B02F                <1> 	mov	al,cmos_sum_lo
   288 00000CFE E81DFF              <1> 	call	rtc_read
   289 00000D01 39C3                <1> 	cmp	bx,ax
   290 00000D03 7437                <1> 	je	.update_equipment
   291                              <1> 
   292 00000D05 BE[3704]            <1> 	mov	si,msg_rtc_sum
   293 00000D08 E8A51B              <1> 	call	print
   294                              <1> 
   295                              <1> ; clear NVRAM
   296                              <1> 
   297 00000D0B B81000              <1> 	mov	ax,0010h		; start from 10h, load 00h
   298                              <1> 
   299                              <1> .nvram_clear_loop:
   300 00000D0E E81CFF              <1> 	call	rtc_write
   301 00000D11 FEC0                <1> 	inc	al
   302 00000D13 3C20                <1> 	cmp	al,20h			; last address is 20h
   303 00000D15 76F7                <1> 	jbe	.nvram_clear_loop
   304                              <1> 
   305 00000D17 B010                <1> 	mov	al,cmos_floppy		; write default floppy type
   306 00000D19 2E8A26[310E]        <1>     cs	mov	ah,byte [default_floppy]
   307 00000D1E E80CFF              <1> 	call	rtc_write
   308                              <1> 
   309 00000D21 B014                <1> 	mov	al,cmos_equip		; write default equipment byte
   310 00000D23 2E8A26[320E]        <1>     cs	mov	ah,byte [default_equip]
   311 00000D28 E802FF              <1> 	call	rtc_write
   312                              <1> 
   313                              <1> ; update checksum
   314                              <1> 
   315 00000D2B E83600              <1> 	call	nvram_checksum
   316                              <1> 
   317 00000D2E B02E                <1> 	mov	al,cmos_sum_hi
   318 00000D30 88FC                <1> 	mov	ah,bh
   319 00000D32 E8F8FE              <1> 	call	rtc_write
   320                              <1> 
   321 00000D35 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
   322 00000D37 88DC                <1> 	mov	ah,bl
   323 00000D39 E8F1FE              <1> 	call	rtc_write
   324                              <1> 
   325                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
   326                              <1> 
   327                              <1> .update_equipment:
   328 00000D3C B014                <1> 	mov	al,cmos_equip
   329 00000D3E E8DDFE              <1> 	call	rtc_read
   330 00000D41 24CB                <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
   331 00000D43 8026100034          <1> 	and	byte [equipment_list],equip_video|equip_mouse
   332 00000D48 08061000            <1> 	or	byte [equipment_list],al
   333                              <1> 
   334                              <1> %endif ; AT_RTC_NVRAM
   335                              <1> 
   336                              <1> .exit:
   337 00000D4C 5E                  <1> 	pop	si
   338 00000D4D 5A                  <1> 	pop	dx
   339 00000D4E 59                  <1> 	pop	cx
   340 00000D4F 5B                  <1> 	pop	bx
   341 00000D50 58                  <1> 	pop	ax
   342 00000D51 C3                  <1> 	ret
   343                              <1> 
   344                              <1> bcd_to_binary:
   345 00000D52 51                  <1> 	push	cx
   346 00000D53 88C5                <1> 	mov	ch,al
   347 00000D55 80E50F              <1> 	and	ch,0Fh
   348 00000D58 B104                <1> 	mov	cl,4
   349 00000D5A D2E8                <1> 	shr	al,cl
   350 00000D5C B10A                <1> 	mov	cl,10
   351 00000D5E F6E1                <1> 	mul	cl
   352 00000D60 00E8                <1> 	add	al,ch
   353 00000D62 59                  <1> 	pop	cx
   354 00000D63 C3                  <1> 	ret
   355                              <1> 
   356                              <1> %ifdef AT_RTC_NVRAM
   357                              <1> ;=========================================================================
   358                              <1> ; nvram_checksum - calculate NVRAM checksum
   359                              <1> ; Input:
   360                              <1> ;	none
   361                              <1> ; Output:
   362                              <1> ;	BX = NVRAM checksum
   363                              <1> ;-------------------------------------------------------------------------
   364                              <1> nvram_checksum:
   365 00000D64 50                  <1> 	push	ax
   366 00000D65 31DB                <1> 	xor	bx,bx
   367 00000D67 B410                <1> 	mov	ah,10h			; start from 10h
   368                              <1> 
   369                              <1> .checksum_loop:
   370 00000D69 88E0                <1> 	mov	al,ah
   371 00000D6B E8B0FE              <1> 	call	rtc_read
   372 00000D6E 00C3                <1> 	add	bl,al			; BX += AL
   373 00000D70 80D700              <1> 	adc	bh,0
   374 00000D73 FEC4                <1> 	inc	ah
   375 00000D75 80FC20              <1> 	cmp	ah,20h			; last address is 20h
   376 00000D78 76EF                <1> 	jbe	.checksum_loop
   377 00000D7A 58                  <1> 	pop	ax
   378 00000D7B C3                  <1> 	ret
   379                              <1> 
   380                              <1> ;=========================================================================
   381                              <1> ; nvram_save - Save configuration to CMOS memory
   382                              <1> ; Input:
   383                              <1> ;	CH - CPU Clock speed
   384                              <1> ;	     0 - 4.77 Mhz / Normal
   385                              <1> ;	     1 - 7.16 Mhz / Turbo
   386                              <1> ;	     2 - 9.55 Mhz (FE2010A only)
   387                              <1> ;
   388                              <1> ;	CL - CMOS floppy drive type
   389                              <1> ;	     7-4 - first floppy drive type
   390                              <1> ;	     3-0 - second floppy drive type
   391                              <1> ;-------------------------------------------------------------------------
   392                              <1> nvram_save:
   393 00000D7C 50                  <1> 	push	ax
   394 00000D7D 53                  <1> 	push	bx
   395                              <1> 
   396 00000D7E B02D                <1> 	mov	al,cmos_config_a
   397 00000D80 88EC                <1> 	mov	ah,ch
   398 00000D82 E8A8FE              <1> 	call	rtc_write
   399                              <1> 
   400 00000D85 B010                <1> 	mov	al,cmos_floppy
   401 00000D87 88CC                <1> 	mov	ah,cl
   402 00000D89 E8A1FE              <1> 	call	rtc_write
   403                              <1> 
   404 00000D8C 8A261000            <1> 	mov	ah,byte [equipment_list]
   405 00000D90 80E43E              <1> 	and	ah,03Eh			; mask floppy bits
   406                              <1> 
   407 00000D93 F6C170              <1> 	test	cl,70h
   408 00000D96 7403                <1> 	jz	.second_floppy		; jump if first floppy is not installed
   409 00000D98 80CC01              <1> 	or	ah,01h			; first floppy is installed
   410                              <1> 
   411                              <1> .second_floppy:
   412 00000D9B F6C107              <1> 	test	cl,07h
   413 00000D9E 7403                <1> 	jz	.save_equipment		; jump if second floppy is not installed
   414 00000DA0 80CC41              <1> 	or	ah,41h			; indicate two floppies
   415                              <1> 					; (even if the first one is missing)
   416                              <1> 
   417                              <1> .save_equipment:
   418 00000DA3 88261000            <1> 	mov	byte [equipment_list],ah
   419 00000DA7 B014                <1> 	mov	al,cmos_equip
   420 00000DA9 E881FE              <1> 	call	rtc_write
   421                              <1> 
   422 00000DAC E8B5FF              <1> 	call	nvram_checksum
   423                              <1> 
   424 00000DAF B02E                <1> 	mov	al,cmos_sum_hi
   425 00000DB1 88FC                <1> 	mov	ah,bh
   426 00000DB3 E877FE              <1> 	call	rtc_write
   427                              <1> 
   428 00000DB6 FEC0                <1> 	inc	al			; AL = cmos_sum_lo
   429 00000DB8 88DC                <1> 	mov	ah,bl
   430 00000DBA E870FE              <1> 	call	rtc_write
   431                              <1> 
   432 00000DBD 5B                  <1> 	pop	bx
   433 00000DBE 58                  <1> 	pop	ax
   434 00000DBF C3                  <1> 	ret
   435                              <1> 
   436                              <1> ;=========================================================================
   437                              <1> ; get_config_a - Return BIOS configuration byte A from NVRAM
   438                              <1> ; Input:
   439                              <1> ;	none
   440                              <1> ; Output:
   441                              <1> ;	AL - NVRAM CPU clock frequency configuration setting
   442                              <1> ;		0 - 4.77 MHz / Normal
   443                              <1> ;		1 - 7.16 MHz / Turbo
   444                              <1> ;		2 - 9.55 MHz (FE2010 only)
   445                              <1> ;-------------------------------------------------------------------------
   446                              <1> get_config_a:
   447 00000DC0 B02D                <1> 	mov	al,cmos_config_a	; read BIOS configuration byte A
   448 00000DC2 E859FE              <1> 	call	rtc_read
   449 00000DC5 C3                  <1> 	ret
   450                              <1>   
   451                              <1> ;=========================================================================
   452                              <1> ; get_floppy - Return floppy drive type from NVRAM
   453                              <1> ; Input:
   454                              <1> ;	none
   455                              <1> ; Output:
   456                              <1> ;	AL = floppy drive type
   457                              <1> ;-------------------------------------------------------------------------
   458                              <1> get_floppy:
   459 00000DC6 B010                <1> 	mov     al,cmos_floppy
   460 00000DC8 E853FE              <1> 	call    rtc_read		; read currently configured floppies
   461 00000DCB C3                  <1> 	ret
   462                              <1> 
   463                              <1> %endif ; AT_RTC_NVRAM
   464                              <1> 
   465                              <1> ;=========================================================================
   466                              <1> ; print_rtc - print current RTC date and time
   467                              <1> ; Input:
   468                              <1> ;	none
   469                              <1> ; Output:
   470                              <1> ;	date and time are printed in YYYY-MM-DD hh:mm:ss format
   471                              <1> ; Notes:
   472                              <1> ;	There is a slight probability of getting inconsistent printout.
   473                              <1> ;	In case the function is called just before midnight, it could
   474                              <1> ;	print the previos day's date and next day's time.
   475                              <1> ;-------------------------------------------------------------------------
   476                              <1> print_rtc:
   477 00000DCC 50                  <1> 	push	ax
   478 00000DCD 53                  <1> 	push	bx
   479 00000DCE 51                  <1> 	push	cx
   480 00000DCF 52                  <1> 	push	dx
   481 00000DD0 56                  <1> 	push	si
   482 00000DD1 BE[F701]            <1> 	mov	si,msg_rtc
   483 00000DD4 E8D91A              <1> 	call	print
   484                              <1> 
   485                              <1> %ifdef AT_RTC_AUTODETECT
   486                              <1> 	call	rtc_detect
   487                              <1> 	jnc	.rtc_present
   488                              <1> 	mov	si,msg_absent
   489                              <1> 	call	print
   490                              <1> 	jmp	.exit
   491                              <1> .rtc_present:
   492                              <1> %endif ; AT_RTC_AUTODETECT
   493                              <1> 
   494                              <1> ; print date
   495 00000DD7 B404                <1> 	mov	ah,04h
   496 00000DD9 CD1A                <1> 	int	1Ah			; read RTC date
   497                              <1> 					; CH = BCD century
   498                              <1> 					; CL = BCD year
   499                              <1> 					; DH = BCD month
   500                              <1> 					; DL = BCD date (day of month)
   501 00000DDB 89C8                <1> 	mov	ax,cx
   502 00000DDD E8EB1A              <1> 	call	print_hex		; print 4-digit year
   503 00000DE0 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
   504 00000DE3 BB0700              <1> 	mov	bx,0007h
   505 00000DE6 CD10                <1> 	int	10h			; print dash (-)
   506                              <1> 
   507 00000DE8 88F0                <1> 	mov	al,dh
   508 00000DEA E8E91A              <1> 	call	print_byte		; print 2-digit month
   509 00000DED B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
   510 00000DF0 BB0700              <1> 	mov	bx,0007h
   511 00000DF3 CD10                <1> 	int	10h			; print dash (-)
   512                              <1> 
   513 00000DF5 88D0                <1> 	mov	al,dl
   514 00000DF7 E8DC1A              <1> 	call	print_byte		; print 2-digit date (day of month)
   515                              <1> 
   516 00000DFA B8200E              <1> 	mov	ax,(0Eh << 8) + ' '
   517 00000DFD BB0700              <1> 	mov	bx,0007h
   518 00000E00 CD10                <1> 	int	10h			; print space ( )
   519                              <1> 
   520                              <1> ; print time
   521 00000E02 B402                <1> 	mov	ah,02h
   522 00000E04 CD1A                <1> 	int	1Ah			; read RTC time
   523                              <1> 					; CH = BCD hours
   524                              <1> 					; CL = BCD minutes
   525                              <1> 					; DH = BCD seconds
   526                              <1> 					; DL = daylight saving flag
   527 00000E06 88E8                <1> 	mov	al,ch
   528 00000E08 E8CB1A              <1> 	call	print_byte		; print 2-digit hours
   529                              <1> 	
   530 00000E0B B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
   531 00000E0E BB0700              <1> 	mov	bx,0007h
   532 00000E11 CD10                <1> 	int	10h			; print colon (:)
   533                              <1> 
   534 00000E13 88C8                <1> 	mov	al,cl
   535 00000E15 E8BE1A              <1> 	call	print_byte		; print 2-digit minutes
   536                              <1> 	
   537 00000E18 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
   538 00000E1B BB0700              <1> 	mov	bx,0007h
   539 00000E1E CD10                <1> 	int	10h			; print colon (:)
   540                              <1> 
   541 00000E20 88F0                <1> 	mov	al,dh
   542 00000E22 E8B11A              <1> 	call	print_byte		; print 2-digit seconds
   543 00000E25 BE[8B00]            <1> 	mov	si,msg_crlf
   544 00000E28 E8851A              <1> 	call	print
   545                              <1> 
   546                              <1> .exit:
   547 00000E2B 5E                  <1> 	pop	si
   548 00000E2C 5A                  <1> 	pop	dx
   549 00000E2D 59                  <1> 	pop	cx
   550 00000E2E 5B                  <1> 	pop	bx
   551 00000E2F 58                  <1> 	pop	ax
   552 00000E30 C3                  <1> 	ret
   553                              <1> 
   554                              <1> %ifdef AT_RTC_AUTODETECT
   555                              <1> ;=========================================================================
   556                              <1> ; rtc_detect - Check RTC is present at 0x70 port
   557                              <1> ; Input:
   558                              <1> ;	none
   559                              <1> ; Output:
   560                              <1> ;	CF == 0 - RTC is present
   561                              <1> ;	CF == 1 - RTC is not detected
   562                              <1> ;-------------------------------------------------------------------------
   563                              <1> rtc_detect:
   564                              <1> 	push ax
   565                              <1> 	mov	al,cmos_control_a	; select control A register
   566                              <1> 	call    rtc_read		; check if RTC is present
   567                              <1> 	cmp     al,26h
   568                              <1> 	je	.rtc_present
   569                              <1> 	stc				; no RTC - set CF
   570                              <1> 	jmp	.exit
   571                              <1> 
   572                              <1> .rtc_present:
   573                              <1> 	clc				; RTC detected - clear CF
   574                              <1> 
   575                              <1> .exit:
   576                              <1> 	pop ax
   577                              <1> 	ret
   578                              <1> %endif ; AT_RTC_AUTODETECT
   265                                  %endif ; AT_RTC
   266                                  %ifdef FLASH_NVRAM
   267                                  %include	"flash.inc"		; Flash ROM configuration functions
   268                                  %endif ; FLASH_NVRAM
   269                                  %ifdef BIOS_SETUP
   270                                  %include	"setup.inc"		; NVRAM setup functions
     1                              <1> ;=========================================================================
     2                              <1> ; setup.inc - NVRAM setup functions
     3                              <1> ; Works either with AT-style RTC/NVRAM or with Flash ROM
     4                              <1> ;-------------------------------------------------------------------------
     5                              <1> ;
     6                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     9                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;=========================================================================
    25                              <1> 
    26 00000E31 40                  <1> default_floppy	db	type_1440 << 4	; one 1.44 MB floppy drive
    27 00000E32 21                  <1> default_equip	db	21h		; CGA 80x25, one floppy drive
    28                              <1> %ifdef BIOS_SETUP
    29 00000E33 00                  <1> default_config_a db	00000000b	; NVRAM BIOS configuration byte A
    30                              <1> ;			||||||`---------; 00 = 4.77 MHz / Turbo off
    31                              <1> ;			|||||`----------; 0 = F0000-F7FFF ROM scan enabled
    32                              <1> ;			||||`-----------; 0 = Memory test enabled
    33                              <1> ;                       |||`------------; 0 = Fast wait states for FE2010A
    34                              <1> ;			`---------------; reserved
    35                              <1> nvram_trbo_mask equ	03h		; turbo mask
    36                              <1> nvram_ext_scan	equ	04h		; F0000-F7FFF BIOS extension scan bit
    37                              <1> 					; (0 - enabled, 1 - disabled)
    38                              <1> nvram_mem_test	equ	08h		; Memory test bit
    39                              <1> 					; (0 - enabled, 1 - disabled)
    40                              <1> nvram_fast_ws	equ	10h		; Less wait states for FE2010A 
    41                              <1> 					; (0 - enabled, 1 - disabled)
    42                              <1> %endif ; BIOS_SETUP
    43                              <1> 
    44                              <1> ;=========================================================================
    45                              <1> ; nvram_setup - NVRAM configuration utility
    46                              <1> ; Input:
    47                              <1> ;	none
    48                              <1> ; Output:
    49                              <1> ;	none
    50                              <1> ;-------------------------------------------------------------------------
    51                              <1> nvram_setup:
    52 00000E34 50                  <1> 	push	ax
    53 00000E35 53                  <1> 	push	bx
    54 00000E36 51                  <1> 	push	cx
    55 00000E37 52                  <1> 	push	dx
    56 00000E38 56                  <1> 	push	si
    57                              <1> 
    58 00000E39 E884FF              <1> 	call	get_config_a		; read BIOS configuration byte A
    59 00000E3C 88C5                <1> 	mov	ch,al			; save it to CH
    60 00000E3E E885FF              <1> 	call	get_floppy		; read currently configured floppies
    61 00000E41 88C1                <1> 	mov	cl,al			; save it to CL
    62                              <1> 	
    63 00000E43 BE[9D04]            <1> 	mov	si,msg_set_welcome
    64 00000E46 E8671A              <1> 	call	print
    65                              <1> 
    66                              <1> .menu_loop:
    67 00000E49 BE[FB05]            <1> 	mov	si,msg_set_prompt
    68 00000E4C E8611A              <1> 	call	print
    69                              <1> 
    70                              <1> .menu_input:
    71 00000E4F B400                <1> 	mov	ah,00h
    72 00000E51 CD16                <1> 	int	16h
    73 00000E53 0C20                <1> 	or	al,20h			; convert to lower case
    74 00000E55 B200                <1> 	mov	dl,0			; floppy 0
    75 00000E57 3C66                <1> 	cmp	al,'f'
    76 00000E59 7458                <1> 	je	.set_floppy
    77 00000E5B FEC2                <1> 	inc	dl			; floppy 1
    78 00000E5D 3C67                <1> 	cmp	al,'g'
    79 00000E5F 7452                <1> 	je	.set_floppy
    80 00000E61 3C70                <1> 	cmp	al,'p'
    81 00000E63 7503E9B100          <1> 	je	.print_settings
    82                              <1> %ifdef TURBO_MODE
    83                              <1> 	cmp	al,'c'
    84                              <1> 	je	.set_cpu_clk
    85                              <1> %endif ; TURBO_MODE
    86                              <1> %ifdef MACHINE_FE2010A
    87                              <1> 	cmp	al,'s'
    88                              <1> 	je	.set_ws
    89                              <1> %endif ; MACHINE_FE2010A
    90                              <1> %ifdef AT_RTC
    91                              <1> 	%ifdef AT_RTC_AUTODETECT
    92                              <1> 		call	rtc_detect
    93                              <1> 		jc	.rtc_absent_2
    94                              <1> 	%endif ; AT_RTC_AUTODETECT
    95 00000E68 3C74                <1> 	cmp	al,'t'
    96 00000E6A 7503E9F600          <1> 	je	.set_time
    97 00000E6F 3C64                <1> 	cmp	al,'d'
    98 00000E71 7503E96A01          <1> 	je	.set_date
    99                              <1> 	
   100                              <1> .rtc_absent_2:
   101                              <1> %endif ; AT_RTC
   102 00000E76 3C65                <1> 	cmp	al,'e'
   103 00000E78 7503E92B02          <1> 	je	.set_ext_scan
   104 00000E7D 3C6D                <1> 	cmp	al,'m'
   105 00000E7F 7503E96C02          <1> 	je	.set_mem_test
   106 00000E84 3C77                <1> 	cmp	al,'w'
   107 00000E86 7503E9AD02          <1> 	je	.save
   108 00000E8B 3C71                <1> 	cmp	al,'q'
   109 00000E8D 7503E9B502          <1> 	je	.no_save
   110 00000E92 3C68                <1> 	cmp	al,'h'
   111 00000E94 7402                <1> 	je	.help
   112 00000E96 EBB7                <1> 	jmp	.menu_input
   113                              <1> 
   114                              <1> .help:
   115 00000E98 B40E                <1> 	mov	ah,0Eh			; echo
   116 00000E9A BB0700              <1> 	mov	bx,0007h
   117 00000E9D CD10                <1> 	int	10h
   118 00000E9F BE[C104]            <1> 	mov	si,msg_set_help
   119 00000EA2 E80B1A              <1> 	call	print
   120                              <1> 
   121                              <1> %ifdef AT_RTC
   122                              <1> 	
   123                              <1> %ifdef AT_RTC_AUTODETECT
   124                              <1> 	call	rtc_detect
   125                              <1> 	jc	.rtc_absent
   126                              <1> %endif ; AT_RTC_AUTODETECT
   127                              <1> 
   128 00000EA5 BE[7105]            <1> 	mov	si,msg_set_rtc_help
   129 00000EA8 E8051A              <1> 	call	print
   130                              <1> 
   131                              <1> .rtc_absent:
   132                              <1> %endif ; AT_RTC
   133                              <1> 
   134 00000EAB BE[8E05]            <1> 	mov	si,msg_set_def_help
   135 00000EAE E8FF19              <1> 	call	print
   136 00000EB1 EB96                <1> 	jmp	.menu_loop
   137                              <1> 
   138                              <1> .set_floppy:
   139 00000EB3 B40E                <1> 	mov	ah,0Eh			; echo
   140 00000EB5 BB0700              <1> 	mov	bx,0007h
   141 00000EB8 CD10                <1> 	int	10h
   142                              <1> 
   143                              <1> .set_floppy_prompt:
   144 00000EBA BE[4907]            <1> 	mov	si,msg_set_fd_prmt
   145 00000EBD E8F019              <1> 	call	print
   146                              <1> 
   147                              <1> .floppy_input:
   148 00000EC0 B400                <1> 	mov	ah,00h
   149 00000EC2 CD16                <1> 	int	16h
   150 00000EC4 0C20                <1> 	or	al,20h			; convert to lower case
   151 00000EC6 3C72                <1> 	cmp	al,'r'
   152 00000EC8 7430                <1> 	je	.floppy_exit
   153 00000ECA 3C68                <1> 	cmp	al,'h'
   154 00000ECC 7436                <1> 	je	.floppy_help
   155 00000ECE 3C30                <1> 	cmp	al,'0'
   156 00000ED0 72EE                <1> 	jb	.floppy_input
   157 00000ED2 3C36                <1> 	cmp	al,'6'
   158 00000ED4 77EA                <1> 	ja	.floppy_input
   159 00000ED6 3C35                <1> 	cmp	al,'5'
   160 00000ED8 74E6                <1> 	je	.floppy_input
   161 00000EDA B40E                <1> 	mov	ah,0Eh			; echo
   162 00000EDC BB0700              <1> 	mov	bx,0007h
   163 00000EDF CD10                <1> 	int	10h
   164 00000EE1 2C30                <1> 	sub	al,'0'
   165 00000EE3 B6F0                <1> 	mov	dh,0F0h
   166 00000EE5 08D2                <1> 	or	dl,dl			; drive	0?
   167 00000EE7 750A                <1> 	jnz	.drive_1
   168 00000EE9 D0E0                <1> 	shl	al,1
   169 00000EEB D0E0                <1> 	shl	al,1
   170 00000EED D0E0                <1> 	shl	al,1
   171 00000EEF D0E0                <1> 	shl	al,1
   172 00000EF1 B60F                <1> 	mov	dh,0Fh
   173                              <1> .drive_1:
   174 00000EF3 20F1                <1> 	and	cl,dh
   175 00000EF5 08C1                <1> 	or	cl,al
   176 00000EF7 E94FFF              <1> 	jmp	.menu_loop
   177                              <1> 
   178                              <1> .floppy_exit:
   179 00000EFA B40E                <1> 	mov	ah,0Eh			; echo
   180 00000EFC BB0700              <1> 	mov	bx,0007h
   181 00000EFF CD10                <1> 	int	10h
   182 00000F01 E945FF              <1> 	jmp	.menu_loop
   183                              <1> 
   184                              <1> .floppy_help:
   185 00000F04 B40E                <1> 	mov	ah,0Eh			; echo
   186 00000F06 BB0700              <1> 	mov	bx,0007h
   187 00000F09 CD10                <1> 	int	10h
   188 00000F0B BE[7A06]            <1> 	mov	si,msg_set_fd_help
   189 00000F0E E89F19              <1> 	call	print
   190 00000F11 BE[0607]            <1> 	mov	si,msg_set_sub_help
   191 00000F14 E89919              <1> 	call	print
   192 00000F17 EBA1                <1> 	jmp	.set_floppy_prompt
   193                              <1> 
   194                              <1> %ifdef TURBO_MODE
   195                              <1> .set_cpu_clk:
   196                              <1> 	mov	ah,0Eh			; echo
   197                              <1> 	mov	bx,0007h
   198                              <1> 	int	10h
   199                              <1> 
   200                              <1> .set_cpu_clk_prompt:
   201                              <1> 	mov	si,msg_set_clk_prmt
   202                              <1> 	call	print
   203                              <1> 
   204                              <1> .cpu_clk_input:
   205                              <1> 	mov	ah,00h
   206                              <1> 	int	16h
   207                              <1> 	or	al,20h			; convert to lower case
   208                              <1> 	cmp	al,'r'
   209                              <1> 	je	.cpu_clk_exit
   210                              <1> 	cmp	al,'h'
   211                              <1> 	je	.cpu_clk_help
   212                              <1> 	cmp	al,'4'
   213                              <1> 	je	.cpu_clk_4_77mhz
   214                              <1> %ifdef MACHINE_FE2010A
   215                              <1> 	cmp	al,'7'
   216                              <1> 	je	.cpu_clk_7_16mhz
   217                              <1> 	cmp	al,'9'
   218                              <1> 	je	.cpu_clk_9_55mhz
   219                              <1> %else ; MACHINE_FE2010A
   220                              <1> 	cmp	al,'t'
   221                              <1> 	je	.cpu_clk_turbo
   222                              <1> %endif ; MACHINE_FE2010A
   223                              <1> 	jmp	.cpu_clk_input
   224                              <1> 
   225                              <1> .cpu_clk_4_77mhz:
   226                              <1> 	mov	ah,0Eh			; echo
   227                              <1> 	mov	bx,0007h
   228                              <1> 	int	10h
   229                              <1> 	and	ch,~nvram_trbo_mask	; CH[1:0] = 0 -> 4.77 MHz
   230                              <1> 	jmp	.menu_loop
   231                              <1> 
   232                              <1> %ifdef MACHINE_FE2010A
   233                              <1> .cpu_clk_7_16mhz:
   234                              <1> 	mov	ah,0Eh			; echo
   235                              <1> 	mov	bx,0007h
   236                              <1> 	int	10h
   237                              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   238                              <1> 	or	ch,1			; CH[1:0] = 1 -> 7.16 MHz
   239                              <1> 	jmp	.menu_loop
   240                              <1> 
   241                              <1> .cpu_clk_9_55mhz:
   242                              <1> 	mov	ah,0Eh			; echo
   243                              <1> 	mov	bx,0007h
   244                              <1> 	int	10h
   245                              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   246                              <1> 	or	ch,2			; CH[1:0] = 2 -> 9.55 MHz
   247                              <1> 	jmp	.menu_loop
   248                              <1> %else ; MACHINE_FE2010A
   249                              <1> .cpu_clk_turbo:
   250                              <1> 	mov	ah,0Eh			; echo
   251                              <1> 	mov	bx,0007h
   252                              <1> 	int	10h
   253                              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   254                              <1> 	or	ch,1			; CH[1:0] = 1 -> Turbo
   255                              <1> 	jmp	.menu_loop
   256                              <1> %endif ; MACHINE_FE2010A
   257                              <1> 
   258                              <1> .cpu_clk_exit:
   259                              <1> 	mov	ah,0Eh			; echo
   260                              <1> 	mov	bx,0007h
   261                              <1> 	int	10h
   262                              <1> 	jmp	.menu_loop
   263                              <1> 
   264                              <1> .cpu_clk_help:
   265                              <1> 	mov	ah,0Eh			; echo
   266                              <1> 	mov	bx,0007h
   267                              <1> 	int	10h
   268                              <1> 	mov	si,msg_set_clk_help
   269                              <1> 	call	print
   270                              <1> 	mov	si,msg_set_sub_help
   271                              <1> 	call	print
   272                              <1> 	jmp	.set_cpu_clk_prompt
   273                              <1> %endif ; TURBO_MODE
   274                              <1> 
   275                              <1> .print_settings:
   276 00000F19 B40E                <1> 	mov	ah,0Eh			; echo
   277 00000F1B BB0700              <1> 	mov	bx,0007h
   278 00000F1E CD10                <1> 	int	10h
   279 00000F20 BE[8B00]            <1> 	mov	si,msg_crlf
   280 00000F23 E88A19              <1> 	call	print
   281                              <1> 
   282                              <1> %ifdef TURBO_MODE
   283                              <1> 	mov	si,msg_cpu_clk
   284                              <1> 	call	print
   285                              <1> 	mov	al,ch
   286                              <1> 	call	print_cpu_clk
   287                              <1> 	mov	si,msg_crlf
   288                              <1> 	call	print
   289                              <1> %endif ; TURBO_MODE
   290                              <1> 
   291                              <1> %ifdef MACHINE_FE2010A
   292                              <1> 	mov	si,msg_ws
   293                              <1> 	call	print
   294                              <1> 	mov	si,msg_enabled		; assume fast wait states
   295                              <1> 	test	ch,nvram_fast_ws
   296                              <1> 	jz	.print_ws
   297                              <1> 	mov	si,msg_disabled
   298                              <1> 
   299                              <1> .print_ws:
   300                              <1> 	call	print
   301                              <1> 	mov	si,msg_crlf
   302                              <1> 	call	print
   303                              <1> %endif ; MACHINE_FE2010A
   304                              <1> 
   305                              <1> %ifdef AT_RTC
   306 00000F26 E8A3FE              <1> 	call	print_rtc		; print current RTC time
   307                              <1> %endif ; AT_RTC
   308 00000F29 88C8                <1> 	mov	al,cl			; floppy bytes to AL
   309 00000F2B E8560B              <1> 	call	print_floppy
   310 00000F2E BE[A807]            <1> 	mov	si,msg_ext_scan
   311 00000F31 E87C19              <1> 	call	print
   312 00000F34 BE[FD07]            <1> 	mov	si,msg_enabled		; assume F0000-F7FFF ROM scan enabled
   313 00000F37 F6C504              <1> 	test	ch,nvram_ext_scan
   314 00000F3A 7403                <1> 	jz	.print_ext_scan
   315 00000F3C BE[0508]            <1> 	mov	si,msg_disabled		; F0000-F7FFF ROM scan disabled
   316                              <1> 
   317                              <1> .print_ext_scan:
   318 00000F3F E86E19              <1> 	call	print
   319 00000F42 BE[8B00]            <1> 	mov	si,msg_crlf
   320 00000F45 E86819              <1> 	call	print
   321 00000F48 BE[E007]            <1> 	mov	si,msg_mem_test
   322 00000F4B E86219              <1> 	call	print
   323 00000F4E BE[FD07]            <1> 	mov	si,msg_enabled		; assume memory test enabled
   324 00000F51 F6C508              <1> 	test	ch,nvram_mem_test
   325 00000F54 7403                <1> 	jz	.print_mem_test
   326 00000F56 BE[0508]            <1> 	mov	si,msg_disabled
   327                              <1> 
   328                              <1> .print_mem_test:
   329 00000F59 E85419              <1> 	call	print
   330 00000F5C BE[8B00]            <1> 	mov	si,msg_crlf
   331 00000F5F E84E19              <1> 	call	print
   332 00000F62 E9E4FE              <1> 	jmp	.menu_loop
   333                              <1> 
   334                              <1> %ifdef AT_RTC
   335                              <1> .set_time:
   336 00000F65 51                  <1> 	push	cx
   337 00000F66 57                  <1> 	push	di
   338 00000F67 06                  <1> 	push	es
   339 00000F68 B40E                <1> 	mov	ah,0Eh			; echo
   340 00000F6A BB0700              <1> 	mov	bx,0007h
   341 00000F6D CD10                <1> 	int	10h
   342 00000F6F BE[8B00]            <1> 	mov	si,msg_crlf
   343 00000F72 E83B19              <1> 	call	print
   344                              <1> 
   345 00000F75 BE[1A06]            <1> 	mov	si,msg_set_time
   346 00000F78 E83519              <1> 	call	print
   347                              <1> 
   348 00000F7B B402                <1> 	mov	ah,02h
   349 00000F7D CD1A                <1> 	int	1Ah			; get current time
   350                              <1> 
   351 00000F7F B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
   352 00000F82 8EC0                <1> 	mov	es,ax
   353 00000F84 31FF                <1> 	xor	di,di
   354 00000F86 B80800              <1> 	mov	ax,8			; length of the time string
   355                              <1> 
   356 00000F89 E8CE01              <1> 	call	get_line
   357                              <1> 
   358 00000F8C 09C0                <1> 	or	ax,ax			; empty string?
   359 00000F8E 7442                <1> 	jz	.set_time_exit
   360                              <1> 
   361 00000F90 E83902              <1> 	call	atoi
   362                              <1> 
   363 00000F93 83F817              <1> 	cmp	ax,23			; hours are greater than 23?
   364 00000F96 7740                <1> 	ja	.set_time_invalid
   365                              <1> 
   366 00000F98 E85602              <1> 	call	bin_to_bcd		; convert to BCD
   367                              <1> 
   368 00000F9B 88C5                <1> 	mov	ch,al			; CH = hours
   369                              <1> 
   370 00000F9D 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
   371 00000FA1 7535                <1> 	jne	.set_time_invalid
   372                              <1> 
   373 00000FA3 47                  <1> 	inc	di
   374                              <1> 
   375 00000FA4 E82502              <1> 	call	atoi
   376                              <1> 
   377 00000FA7 83F83B              <1> 	cmp	ax,59			; minutes are greater than 59?
   378 00000FAA 772C                <1> 	ja	.set_time_invalid
   379                              <1> 
   380 00000FAC E84202              <1> 	call	bin_to_bcd
   381                              <1> 
   382 00000FAF 88C1                <1> 	mov	cl,al			; CL = minutes
   383                              <1> 
   384 00000FB1 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
   385 00000FB5 7521                <1> 	jne	.set_time_invalid
   386                              <1> 
   387 00000FB7 47                  <1> 	inc	di
   388                              <1> 
   389 00000FB8 E81102              <1> 	call	atoi
   390                              <1> 
   391 00000FBB 83F83B              <1> 	cmp	ax,59			; seconds are greater than 59?
   392 00000FBE 7718                <1> 	ja	.set_time_invalid
   393                              <1> 
   394 00000FC0 E82E02              <1> 	call	bin_to_bcd
   395                              <1> 
   396 00000FC3 88C6                <1> 	mov	dh,al			; DH = seconds
   397                              <1> 
   398 00000FC5 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
   399 00000FC9 750D                <1> 	jne	.set_time_invalid
   400                              <1> 
   401 00000FCB B403                <1> 	mov	ah,03h			; set RTC time
   402 00000FCD CD1A                <1> 	int	1Ah
   403 00000FCF E86EFC              <1> 	call	set_system_timer		; set timer variables to RTC time
   404                              <1> 
   405                              <1> .set_time_exit:
   406 00000FD2 07                  <1> 	pop	es
   407 00000FD3 5F                  <1> 	pop	di
   408 00000FD4 59                  <1> 	pop	cx
   409 00000FD5 E971FE              <1> 	jmp	.menu_loop
   410                              <1> 
   411                              <1> .set_time_invalid:
   412 00000FD8 BE[4C06]            <1> 	mov	si,msg_time_inval
   413 00000FDB E8D218              <1> 	call	print
   414 00000FDE EBF2                <1> 	jmp	.set_time_exit
   415                              <1> 
   416                              <1> .set_date:
   417 00000FE0 51                  <1> 	push	cx
   418 00000FE1 57                  <1> 	push	di
   419 00000FE2 06                  <1> 	push	es
   420 00000FE3 B40E                <1> 	mov	ah,0Eh			; echo
   421 00000FE5 BB0700              <1> 	mov	bx,0007h
   422 00000FE8 CD10                <1> 	int	10h
   423 00000FEA BE[8B00]            <1> 	mov	si,msg_crlf
   424 00000FED E8C018              <1> 	call	print
   425 00000FF0 BE[3206]            <1> 	mov	si,msg_set_date
   426 00000FF3 E8BA18              <1> 	call	print
   427                              <1> 
   428 00000FF6 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
   429 00000FF9 8EC0                <1> 	mov	es,ax
   430 00000FFB 31FF                <1> 	xor	di,di
   431 00000FFD B80A00              <1> 	mov	ax,10			; length of the date string
   432                              <1> 
   433 00001000 E85701              <1> 	call	get_line
   434                              <1> 
   435 00001003 09C0                <1> 	or	ax,ax			; empty string?
   436 00001005 7503E99000          <1> 	jz	.set_date_exit
   437                              <1> 
   438 0000100A E8BF01              <1> 	call	atoi
   439                              <1> 
   440 0000100D 3D0F27              <1> 	cmp	ax,9999			; year is greater than 9999?
   441 00001010 7603E98B00          <1> 	ja	.set_date_invalid
   442                              <1> 
   443 00001015 89C3                <1> 	mov	bx,ax			; store binary year in BX
   444                              <1> 
   445 00001017 E8D701              <1> 	call	bin_to_bcd		; convert to BCD
   446                              <1> 
   447 0000101A 89C1                <1> 	mov	cx,ax			; CH = century, CL = year
   448                              <1> 	
   449 0000101C 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
   450 00001020 757E                <1> 	jne	.set_date_invalid
   451                              <1> 
   452 00001022 47                  <1> 	inc	di
   453                              <1> 
   454 00001023 E8A601              <1> 	call	atoi
   455                              <1> 
   456 00001026 83F801              <1> 	cmp	ax,1			; month is lower than 1?
   457 00001029 7275                <1> 	jb	.set_date_invalid
   458                              <1> 
   459 0000102B 83F80C              <1> 	cmp	ax,12			; month is greater than 12?
   460 0000102E 7770                <1> 	ja	.set_date_invalid
   461                              <1> 
   462 00001030 E8BE01              <1> 	call	bin_to_bcd
   463                              <1> 
   464 00001033 88C6                <1> 	mov	dh,al			; DH = month
   465                              <1> 
   466 00001035 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
   467 00001039 7565                <1> 	jne	.set_date_invalid
   468                              <1> 
   469 0000103B 47                  <1> 	inc	di
   470                              <1> 
   471 0000103C E88D01              <1> 	call	atoi
   472                              <1> 
   473 0000103F 83F801              <1> 	cmp	ax,1			; day is lower than 1?
   474 00001042 725C                <1> 	jb	.set_date_invalid
   475                              <1> 
   476 00001044 80FE02              <1> 	cmp	dh,02h			; February
   477 00001047 7430                <1> 	je	.set_date_february
   478                              <1> 
   479 00001049 80FE04              <1> 	cmp	dh,04h			; April
   480 0000104C 7416                <1> 	je	.set_date_30_days
   481                              <1> 
   482 0000104E 80FE06              <1> 	cmp	dh,06h			; July
   483 00001051 7411                <1> 	je	.set_date_30_days
   484                              <1> 
   485 00001053 80FE09              <1> 	cmp	dh,09h			; September
   486 00001056 740C                <1> 	je	.set_date_30_days
   487                              <1> 
   488 00001058 80FE11              <1> 	cmp	dh,11h			; November
   489 0000105B 7407                <1> 	je	.set_date_30_days
   490                              <1> 
   491                              <1> .set_date_31_days:
   492 0000105D 83F81F              <1> 	cmp	ax,31			; day of month is greater than 31?
   493 00001060 773E                <1> 	ja	.set_date_invalid
   494 00001062 EB27                <1> 	jmp	.set_date_set_day
   495                              <1> 
   496                              <1> .set_date_30_days:
   497 00001064 83F81E              <1> 	cmp	ax,30			; day of month is greater than 30?
   498 00001067 7737                <1> 	ja	.set_date_invalid
   499 00001069 EB20                <1> 	jmp	.set_date_set_day
   500                              <1> 
   501                              <1> .set_date_29_days:
   502 0000106B 83F81D              <1> 	cmp	ax,29			; day of month is greater than 28?
   503 0000106E 7730                <1> 	ja	.set_date_invalid
   504 00001070 EB19                <1> 	jmp	.set_date_set_day
   505                              <1> 
   506                              <1> .set_date_28_days:
   507 00001072 83F81C              <1> 	cmp	ax,28			; day of month is greater than 28?
   508 00001075 7729                <1> 	ja	.set_date_invalid
   509 00001077 EB12                <1> 	jmp	.set_date_set_day
   510                              <1> 
   511                              <1> .set_date_february:
   512 00001079 F7C30300            <1> 	test	bx,0003h		; check if years divides by 4
   513 0000107D 75F3                <1> 	jnz	.set_date_28_days	; not a leap year
   514                              <1> 
   515 0000107F 80F900              <1> 	cmp	cl,00h			; year doesn't end with 00
   516 00001082 75E7                <1> 	jne	.set_date_29_days	; a leap year
   517                              <1> 
   518 00001084 F6C503              <1> 	test	ch,03h			; check if century divides by 4
   519 00001087 74E2                <1> 	jz	.set_date_29_days	; year divides by 400
   520 00001089 EBE7                <1> 	jmp	.set_date_28_days	; year divides by 100 but not by 400
   521                              <1> 
   522                              <1> .set_date_set_day:
   523 0000108B E86301              <1> 	call	bin_to_bcd
   524                              <1> 
   525 0000108E 88C2                <1> 	mov	dl,al			; DL = date (day of month)
   526                              <1> 
   527 00001090 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
   528 00001094 750A                <1> 	jne	.set_date_invalid
   529                              <1> 
   530 00001096 B405                <1> 	mov	ah,05h			; set RTC date
   531 00001098 CD1A                <1> 	int	1Ah
   532                              <1> 
   533                              <1> .set_date_exit:
   534 0000109A 07                  <1> 	pop	es
   535 0000109B 5F                  <1> 	pop	di
   536 0000109C 59                  <1> 	pop	cx
   537 0000109D E9A9FD              <1> 	jmp	.menu_loop
   538                              <1> 
   539                              <1> .set_date_invalid:
   540 000010A0 BE[6306]            <1> 	mov	si,msg_date_inval
   541 000010A3 E80A18              <1> 	call	print
   542 000010A6 EBF2                <1> 	jmp	.set_date_exit
   543                              <1> 
   544                              <1> %endif ; AT_RTC
   545                              <1> 
   546                              <1> .set_ext_scan:
   547 000010A8 B40E                <1> 	mov	ah,0Eh			; echo
   548 000010AA BB0700              <1> 	mov	bx,0007h
   549 000010AD CD10                <1> 	int	10h
   550 000010AF BE[8B00]            <1> 	mov	si,msg_crlf
   551 000010B2 E8FB17              <1> 	call	print
   552 000010B5 BE[7207]            <1> 	mov	si,msg_set_ext
   553 000010B8 E8F517              <1> 	call	print
   554                              <1> 
   555                              <1> .set_ext_input:
   556 000010BB B400                <1> 	mov	ah,00h
   557 000010BD CD16                <1> 	int	16h
   558 000010BF 3C0D                <1> 	cmp	al,0Dh
   559 000010C1 7424                <1> 	je	.set_ext_exit
   560 000010C3 0C20                <1> 	or	al,20h			; convert to lower case
   561 000010C5 3C6E                <1> 	cmp	al,'n'
   562 000010C7 7406                <1> 	je	.set_ext_disable
   563 000010C9 3C79                <1> 	cmp	al,'y'
   564 000010CB 740E                <1> 	je	.set_ext_enable
   565 000010CD EBEC                <1> 	jmp	.set_ext_input
   566                              <1> 
   567                              <1> .set_ext_disable:
   568 000010CF B40E                <1> 	mov	ah,0Eh			; echo
   569 000010D1 BB0700              <1> 	mov	bx,0007h
   570 000010D4 CD10                <1> 	int	10h
   571 000010D6 80CD04              <1> 	or	ch,nvram_ext_scan	; bit set = disable scan
   572 000010D9 EB0C                <1> 	jmp	.set_ext_exit
   573                              <1> 
   574                              <1> .set_ext_enable:
   575 000010DB B40E                <1> 	mov	ah,0Eh			; echo
   576 000010DD BB0700              <1> 	mov	bx,0007h
   577 000010E0 CD10                <1> 	int	10h
   578 000010E2 80E5FB              <1> 	and	ch,~nvram_ext_scan	; bit clear = enable scan
   579 000010E5 EB00                <1> 	jmp	.set_ext_exit
   580                              <1> 
   581                              <1> .set_ext_exit:
   582 000010E7 BE[8B00]            <1> 	mov	si,msg_crlf
   583 000010EA E8C317              <1> 	call	print
   584 000010ED E959FD              <1> 	jmp	.menu_loop
   585                              <1> 
   586                              <1> .set_mem_test:
   587 000010F0 B40E                <1> 	mov	ah,0Eh			; echo
   588 000010F2 BB0700              <1> 	mov	bx,0007h
   589 000010F5 CD10                <1> 	int	10h
   590 000010F7 BE[8B00]            <1> 	mov	si,msg_crlf
   591 000010FA E8B317              <1> 	call	print
   592 000010FD BE[C507]            <1> 	mov	si,msg_set_mem_tst
   593 00001100 E8AD17              <1> 	call	print
   594                              <1> 
   595                              <1> .set_mem_test_input:
   596 00001103 B400                <1> 	mov	ah,00h
   597 00001105 CD16                <1> 	int	16h
   598 00001107 3C0D                <1> 	cmp	al,0Dh
   599 00001109 7424                <1> 	je	.set_mem_test_exit
   600 0000110B 0C20                <1> 	or	al,20h			; convert to lower case
   601 0000110D 3C6E                <1> 	cmp	al,'n'
   602 0000110F 7406                <1> 	je	.set_mem_test_disable
   603 00001111 3C79                <1> 	cmp	al,'y'
   604 00001113 740E                <1> 	je	.set_mem_test_enable
   605 00001115 EBEC                <1> 	jmp	.set_mem_test_input
   606                              <1> 
   607                              <1> .set_mem_test_disable:
   608 00001117 B40E                <1> 	mov	ah,0Eh			; echo
   609 00001119 BB0700              <1> 	mov	bx,0007h
   610 0000111C CD10                <1> 	int	10h
   611 0000111E 80CD08              <1> 	or	ch,nvram_mem_test	; bit set = disable test
   612 00001121 EB0C                <1> 	jmp	.set_mem_test_exit
   613                              <1> 
   614                              <1> .set_mem_test_enable:
   615 00001123 B40E                <1> 	mov	ah,0Eh			; echo
   616 00001125 BB0700              <1> 	mov	bx,0007h
   617 00001128 CD10                <1> 	int	10h
   618 0000112A 80E5F7              <1> 	and	ch,~nvram_mem_test	; bit clear = enable test
   619 0000112D EB00                <1> 	jmp	.set_mem_test_exit
   620                              <1> 
   621                              <1> .set_mem_test_exit:
   622 0000112F BE[8B00]            <1> 	mov	si,msg_crlf
   623 00001132 E87B17              <1> 	call	print
   624 00001135 E911FD              <1> 	jmp	.menu_loop
   625                              <1> 
   626                              <1> %ifdef MACHINE_FE2010A
   627                              <1> .set_ws:
   628                              <1> 	mov	ah,0Eh			; echo
   629                              <1> 	mov	bx,0007h
   630                              <1> 	int	10h
   631                              <1> 	mov	si,msg_crlf
   632                              <1> 	call	print
   633                              <1> .set_ws_loop:
   634                              <1> 	mov	si,msg_set_ws
   635                              <1> 	call	print
   636                              <1> 
   637                              <1> .set_ws_input:
   638                              <1> 	mov	ah,00h
   639                              <1> 	int	16h
   640                              <1> 	cmp	al,0Dh
   641                              <1> 	je	.set_ws_exit
   642                              <1> 	or	al,20h			; convert to lower case
   643                              <1> 	cmp	al,'n'
   644                              <1> 	je	.set_ws_disable
   645                              <1> 	cmp	al,'y'
   646                              <1> 	je	.set_ws_enable
   647                              <1> 	cmp	al,'h'
   648                              <1> 	je	.set_ws_help
   649                              <1> 	jmp	.set_ws_input
   650                              <1> 
   651                              <1> .set_ws_disable:
   652                              <1> 	mov	ah,0Eh			; echo
   653                              <1> 	mov	bx,0007h
   654                              <1> 	int	10h
   655                              <1> 	or	ch,nvram_fast_ws	; bit set = fast waitstates
   656                              <1> 	jmp	.set_ws_exit
   657                              <1> 
   658                              <1> .set_ws_enable:
   659                              <1> 	mov	ah,0Eh			; echo
   660                              <1> 	mov	bx,0007h
   661                              <1> 	int	10h
   662                              <1> 	and	ch,~nvram_fast_ws	; bit clear = normal waitstates
   663                              <1> 	jmp	.set_ws_exit
   664                              <1> 
   665                              <1> .set_ws_help:
   666                              <1> 	mov	ah,0Eh			; echo
   667                              <1> 	mov	bx,0007h
   668                              <1> 	int	10h
   669                              <1> 	mov	si,msg_ws_help
   670                              <1> 	call	print
   671                              <1> 	jmp	.set_ws_loop
   672                              <1> 
   673                              <1> .set_ws_exit:
   674                              <1> 	mov	si,msg_crlf
   675                              <1> 	call	print
   676                              <1> 	jmp	.menu_loop
   677                              <1> %endif ; MACHINE_FE2010A
   678                              <1> 
   679                              <1> .save:
   680 00001138 B40E                <1> 	mov	ah,0Eh			; echo
   681 0000113A BB0700              <1> 	mov	bx,0007h
   682 0000113D CD10                <1> 	int	10h
   683                              <1> 
   684                              <1> %ifdef AT_RTC_NVRAM
   685 0000113F E83AFC              <1> 	call	nvram_save
   686                              <1> %endif ; AT_RTC_NVRAM
   687                              <1> %ifdef FLASH_NVRAM
   688                              <1> 	call	flash_save
   689                              <1> %endif ; FLASH_NVRAM
   690 00001142 E80809              <1> 	call	detect_floppy		; set floppies in equipment_list
   691 00001145 EB07                <1> 	jmp	.exit
   692                              <1> 
   693                              <1> .no_save:
   694 00001147 B40E                <1> 	mov	ah,0Eh			; echo
   695 00001149 BB0700              <1> 	mov	bx,0007h
   696 0000114C CD10                <1> 	int	10h
   697                              <1> 
   698                              <1> .exit:
   699 0000114E BE[8B00]            <1> 	mov	si,msg_crlf
   700 00001151 E85C17              <1> 	call	print
   701 00001154 5E                  <1> 	pop	si
   702 00001155 5A                  <1> 	pop	dx
   703 00001156 59                  <1> 	pop	cx
   704 00001157 5B                  <1> 	pop	bx
   705 00001158 58                  <1> 	pop	ax
   706 00001159 C3                  <1> 	ret
   707                              <1> 
   708                              <1> ;=========================================================================
   709                              <1> ; get_line - read an ASCIIZ string from the console
   710                              <1> ; Input:
   711                              <1> ;	ES:DI - pointer to the buffer
   712                              <1> ;	AX - max string length
   713                              <1> ; Output:
   714                              <1> ;	AX - string length
   715                              <1> ; Notes:
   716                              <1> ;	Buffer must have size of max string length + 1 to accomodate 00h
   717                              <1> ;-------------------------------------------------------------------------
   718                              <1> get_line:
   719 0000115A 53                  <1> 	push	bx
   720 0000115B 52                  <1> 	push	dx
   721 0000115C 56                  <1> 	push	si
   722 0000115D 57                  <1> 	push	di
   723                              <1> 
   724 0000115E FC                  <1> 	cld
   725 0000115F 89FE                <1> 	mov	si,di
   726 00001161 01C6                <1> 	add	si,ax			; SI = last character position
   727 00001163 31D2                <1> 	xor	dx,dx			; DX = 0 - string length
   728                              <1> 
   729                              <1> .read_char_loop:
   730 00001165 B400                <1> 	mov	ah,00h			; read character from keyboard
   731 00001167 CD16                <1> 	int	16h
   732                              <1> 
   733 00001169 3C08                <1> 	cmp	al,08h			; <Backspace> key
   734 0000116B 741B                <1> 	jz	.backspace
   735                              <1> 
   736 0000116D 3C0D                <1> 	cmp	al,0Dh			; <Enter> key
   737 0000116F 7441                <1> 	jz	.enter
   738                              <1> 
   739 00001171 3C20                <1> 	cmp	al,20h			; below printable ASCII code?
   740 00001173 7233                <1> 	jb	.error_input
   741                              <1> 
   742 00001175 3C7E                <1> 	cmp	al,7Eh			; above printable ASCII code?
   743 00001177 772F                <1> 	ja	.error_input
   744                              <1> 
   745 00001179 39F7                <1> 	cmp	di,si			; end of buffer reached?
   746 0000117B 732B                <1> 	jae	.error_input
   747                              <1> 
   748 0000117D AA                  <1> 	stosb				; store character in the buffer
   749 0000117E 42                  <1> 	inc	dx			; increment strng length
   750                              <1> 
   751 0000117F B40E                <1> 	mov	ah,0Eh			; teletype output (echo)
   752 00001181 BB0700              <1> 	mov	bx,0007h
   753 00001184 CD10                <1> 	int	10h
   754                              <1> 
   755 00001186 EBDD                <1> 	jmp	.read_char_loop
   756                              <1> 
   757                              <1> .backspace:
   758 00001188 09D2                <1> 	or	dx,dx			; empty string?
   759 0000118A 741C                <1> 	jz	.error_input
   760                              <1> 
   761 0000118C 4F                  <1> 	dec	di			; move pointer back
   762 0000118D 4A                  <1> 	dec	dx			; decrement string size
   763                              <1> 
   764 0000118E B8080E              <1> 	mov	ax,0E08h		; move the cursor back
   765 00001191 BB0700              <1> 	mov	bx,0007h
   766 00001194 CD10                <1> 	int	10h
   767                              <1> 
   768 00001196 B8200E              <1> 	mov	ax,0E20h		; erase the character under the cursor
   769 00001199 BB0700              <1> 	mov	bx,0007h
   770 0000119C CD10                <1> 	int	10h
   771                              <1> 
   772 0000119E B8080E              <1> 	mov	ax,0E08h		; move the cursor back again
   773 000011A1 BB0700              <1> 	mov	bx,0007h
   774 000011A4 CD10                <1> 	int	10h
   775                              <1> 
   776 000011A6 EBBD                <1> 	jmp	.read_char_loop
   777                              <1> 
   778                              <1> .error_input:
   779 000011A8 B8070E              <1> 	mov	ax,0E07h		; beep
   780 000011AB BB0700              <1> 	mov	bx,0007h
   781 000011AE CD10                <1> 	int	10h
   782                              <1> 
   783 000011B0 EBB3                <1> 	jmp	.read_char_loop
   784                              <1> 
   785                              <1> .enter:
   786 000011B2 B000                <1> 	mov	al,00h			; store 00h at the end of the string
   787 000011B4 AA                  <1> 	stosb
   788                              <1> 
   789 000011B5 B80D0E              <1> 	mov	ax,0E0Dh		; CR
   790 000011B8 BB0700              <1> 	mov	bx,0007h
   791 000011BB CD10                <1> 	int	10h
   792                              <1> 
   793 000011BD B80A0E              <1> 	mov	ax,0E0Ah		; LF
   794 000011C0 BB0700              <1> 	mov	bx,0007h
   795 000011C3 CD10                <1> 	int	10h
   796                              <1> 
   797 000011C5 89D0                <1> 	mov	ax,dx			; string length to AX
   798                              <1> 
   799 000011C7 5F                  <1> 	pop	di
   800 000011C8 5E                  <1> 	pop	si
   801 000011C9 5A                  <1> 	pop	dx
   802 000011CA 5B                  <1> 	pop	bx
   803 000011CB C3                  <1> 	ret
   804                              <1> 
   805                              <1> ;=========================================================================
   806                              <1> ; atoi - convert ASCIIZ string to an 16-bit integer number
   807                              <1> ; Input:
   808                              <1> ;	ES:DI - pointer to string
   809                              <1> ; Output:
   810                              <1> ;	AX - number
   811                              <1> ; 	ES:DI - pointer moved to the position following the number
   812                              <1> ;-------------------------------------------------------------------------
   813                              <1> atoi:
   814 000011CC 53                  <1> 	push	bx
   815 000011CD 51                  <1> 	push	cx
   816 000011CE 52                  <1> 	push	dx
   817                              <1> 
   818 000011CF 31C0                <1> 	xor	ax,ax			; zero the result
   819 000011D1 BB0A00              <1> 	mov	bx,10			; multiplier
   820                              <1> 
   821                              <1> .atoi_loop:
   822 000011D4 268A0D              <1>     es	mov	cl,byte [di]
   823                              <1> 
   824 000011D7 80F930              <1> 	cmp	cl,'0'			; ASCII code below '0'
   825 000011DA 7211                <1> 	jb	.exit
   826                              <1> 
   827 000011DC 80F939              <1> 	cmp	cl,'9'			; ASCII code above '9'
   828 000011DF 770C                <1> 	ja	.exit
   829                              <1> 
   830 000011E1 47                  <1> 	inc	di			; move to the next character
   831                              <1> 
   832 000011E2 80E930              <1> 	sub	cl,'0'			; convert to ASCII to binary
   833                              <1> 
   834 000011E5 F7E3                <1> 	mul	bx			; DX:AX = AX * 10
   835 000011E7 B500                <1> 	mov	ch,0
   836 000011E9 01C8                <1> 	add	ax,cx			; AX = AX + CX
   837                              <1> 	
   838 000011EB EBE7                <1> 	jmp	.atoi_loop
   839                              <1> 
   840                              <1> .exit:
   841 000011ED 5A                  <1> 	pop	dx
   842 000011EE 59                  <1> 	pop	cx
   843 000011EF 5B                  <1> 	pop	bx
   844 000011F0 C3                  <1> 	ret
   845                              <1> 
   846                              <1> ;=========================================================================
   847                              <1> ; bin_to_bcd - convert binary number to a packed BCD
   848                              <1> ; Input:
   849                              <1> ;	AX - binary number
   850                              <1> ; Output:
   851                              <1> ;	AX - packed BCD number
   852                              <1> ;-------------------------------------------------------------------------
   853                              <1> bin_to_bcd:
   854 000011F1 53                  <1> 	push	bx
   855 000011F2 51                  <1> 	push	cx
   856 000011F3 52                  <1> 	push	dx
   857 000011F4 56                  <1> 	push	si
   858                              <1> 
   859 000011F5 B100                <1> 	mov	cl,0			; shift amount
   860 000011F7 31F6                <1> 	xor	si,si			; zero result
   861 000011F9 BB0A00              <1> 	mov	bx,10			; BX - divisor
   862                              <1> 
   863                              <1> .bin_to_bcd_loop:
   864 000011FC 31D2                <1> 	xor	dx,dx			; DX - zero for 32-bit div operand
   865 000011FE F7F3                <1> 	div	bx
   866                              <1> 
   867 00001200 D3E2                <1> 	shl	dx,cl			; shift digit to the required position
   868 00001202 80C104              <1> 	add	cl,4			; calculate next position
   869                              <1> 
   870 00001205 01D6                <1> 	add	si,dx			; add reminder to the result
   871 00001207 09C0                <1> 	or	ax,ax			; quotient is zero?
   872 00001209 75F1                <1> 	jnz	.bin_to_bcd_loop
   873                              <1> 
   874 0000120B 89F0                <1> 	mov	ax,si			; result to AX
   875                              <1> 
   876 0000120D 5E                  <1> 	pop	si
   877 0000120E 5A                  <1> 	pop	dx
   878 0000120F 59                  <1> 	pop	cx
   879 00001210 5B                  <1> 	pop	bx
   880 00001211 C3                  <1> 	ret
   271                                  %endif ; BIOS_SETUP
   272                                  %include	"delay.inc"		; delay function
     1                              <1> ;=========================================================================
     2                              <1> ; delay.inc - Delay functions
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25                              <1> %ifdef AT_DELAY
    26                              <1> 
    27                              <1> ;=========================================================================
    28                              <1> ; delay_15us - delay for multiplies of 15 microseconds
    29                              <1> ; Input:
    30                              <1> ;	CX = time to delay (in 15 microsecond units)
    31                              <1> ; Notes:
    32                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
    33                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
    34                              <1> ;	    timer channel 1. Will not function properly if timer gets
    35                              <1> ;	    reprogrammed by an application or if it was not initialized yet
    36                              <1> ;-------------------------------------------------------------------------
    37                              <1> delay_15us:
    38 00001212 50                  <1> 	push	ax
    39 00001213 51                  <1> 	push	cx
    40                              <1> .zero:
    41 00001214 E461                <1> 	in	al,ppi_pb_reg
    42 00001216 A810                <1> 	test	al,refresh_flag
    43 00001218 74FA                <1> 	jz	.zero
    44 0000121A 49                  <1> 	dec	cx
    45 0000121B 7409                <1> 	jz	.exit
    46                              <1> .one:
    47 0000121D E461                <1> 	in	al,ppi_pb_reg
    48 0000121F A810                <1> 	test	al,refresh_flag
    49 00001221 75FA                <1> 	jnz	.one
    50 00001223 49                  <1> 	dec	cx
    51 00001224 75EE                <1> 	jnz	.zero
    52                              <1> .exit:
    53 00001226 59                  <1> 	pop	cx
    54 00001227 58                  <1> 	pop	ax
    55 00001228 C3                  <1> 	ret
    56                              <1> 
    57                              <1> %else ; AT_DELAY
    58                              <1> %ifdef PIT_DELAY
    59                              <1> 
    60                              <1> ;=========================================================================
    61                              <1> ; delay_15us - delay for multiplies of 15 microseconds using PIT
    62                              <1> ; Input:
    63                              <1> ;	CX = time to delay (in 15 microsecond units)
    64                              <1> ;
    65                              <1> ; - Calculate the total number of PIT ticks necessary
    66                              <1> ;	1,193,182 / 1000 ms / 1000 us / * 15 us * 2 = ~ 36 ticks/us
    67                              <1> ; - Latch the PIT and draw down the countdown total on each read.
    68                              <1> ; - Exit when countdown underflows.
    69                              <1> ;
    70                              <1> ; Note: Mode 3 (Square Wave) decements the readable counter by 2, so the
    71                              <1> ; effective frequency of the counter is actually 2,386,360 Hz.
    72                              <1> ;
    73                              <1> ; Contributed by @640-KB (under GPL-3.0 license)
    74                              <1> ; Based on contribution by @Raffzahn (under CC BY-SA 4.0):
    75                              <1> ; https://retrocomputing.stackexchange.com/a/24874/21323
    76                              <1> ;-------------------------------------------------------------------------
    77                              <1> delay_15us:
    78                              <1> 	push	ax
    79                              <1> 	push	bx
    80                              <1> 	push	cx
    81                              <1> 	push	dx
    82                              <1> 	mov	ax,2*15*pic_freq/1000/1000+1	; ~ 36 ticks/us	
    83                              <1> 	mul	cx		; dx:ax = countdown of pit ticks to wait
    84                              <1> 	xchg	ax,bx		; dx:bx = countdown ticks
    85                              <1> 	call	io_wait_latch	; ax = start read
    86                              <1> 	mov	cx,ax		; cx = last read
    87                              <1> .tick_loop:
    88                              <1> 	call	io_wait_latch	; ax = current counter reading
    89                              <1> 	sub	cx,ax		; cx = # of ticks elapsed since last reading
    90                              <1> 	sub	bx,cx		; subtract change in ticks from countdown
    91                              <1> 	mov	cx,ax		; cx = save the last read
    92                              <1> 	sbb	dx,0		; borrow out of high word (if necessary)
    93                              <1> 	jae	.tick_loop	; loop while countdown >= 0
    94                              <1> 	pop	dx
    95                              <1> 	pop	cx
    96                              <1> 	pop	bx
    97                              <1> 	pop	ax
    98                              <1> 	ret
    99                              <1> 
   100                              <1> ;=========================================================================
   101                              <1> ; Latch PIT 0 and read counter
   102                              <1> ; Output:
   103                              <1> ;	AX = current counter
   104                              <1> ;-------------------------------------------------------------------------
   105                              <1> io_wait_latch:
   106                              <1> 	mov	al,0		; counter 0, latch (00b)
   107                              <1> 	pushf			; save current IF
   108                              <1> 	cli			; disable interrupts
   109                              <1> 	out	pit_ctl_reg,al	; write command to ctc
   110                              <1> 	in	al,pit_ch0_reg	; read low byte of counter 0 latch
   111                              <1> 	mov	ah,al		; save it
   112                              <1> 	in	al,pit_ch0_reg	; read high byte of counter 0 latch
   113                              <1> 	popf			; restore IF state
   114                              <1> 	xchg	al,ah		; convert endian
   115                              <1> 	ret
   116                              <1> 
   117                              <1> %else ; LOOP_DELAY
   118                              <1> 
   119                              <1> ;=========================================================================
   120                              <1> ; delay_15us - delay for multiplies of approximately 15 microseconds
   121                              <1> ; Input:
   122                              <1> ;	CX = time to delay (in 15 microsecond units)
   123                              <1> ; Notes:
   124                              <1> ;	This implementation does not provide precise timing
   125                              <1> ;	The actual delay depends on the CPU clock frequency
   126                              <1> ;-------------------------------------------------------------------------
   127                              <1> delay_15us:
   128                              <1> 	push	ax
   129                              <1> 	push	cx
   130                              <1> .1:
   131                              <1> 	mov	al,4
   132                              <1> .2:
   133                              <1> 	dec	al
   134                              <1> 	jnz	.2
   135                              <1> 	loop	.1
   136                              <1> 	pop	cx
   137                              <1> 	pop	ax
   138                              <1> 	ret
   139                              <1> 
   140                              <1> %endif ; PIT_DELAY
   141                              <1> %endif ; AT_DELAY
   142                              <1> 
   143                              <1> %if 0
   144                              <1> ;=========================================================================
   145                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
   146                              <1> ; Input:
   147                              <1> ;	DX:AX	- dividend
   148                              <1> ;	CX	- divisor
   149                              <1> ; Output:
   150                              <1> ;	DX:AX	- quotient
   151                              <1> ;-------------------------------------------------------------------------
   152                              <1> divide_32:
   153                              <1> 	or	dx,dx
   154                              <1> 	jnz	.1
   155                              <1> 	div	cx
   156                              <1> 	xor	dx,dx
   157                              <1> 	ret
   158                              <1> .1:
   159                              <1> 	push	bx
   160                              <1> 	mov	bx,ax
   161                              <1> 	mov	ax,dx
   162                              <1> 	xor	dx,dx
   163                              <1> 	div	cx
   164                              <1> 	xchg	bx,ax
   165                              <1> 	div	cx
   166                              <1> 	mov	dx,bx
   167                              <1> 	pop	bx
   168                              <1> 	ret
   169                              <1> %endif ; 0
   273                                  %include	"time1.inc"		; time services
     1                              <1> ;=========================================================================
     2                              <1> ; time1.inc - BIOS Time Services
     3                              <1> ;       INT 1Ah - BIOS Time Services
     4                              <1> ;		functions AH=00h to AH=07h
     5                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
     6                              <1> ;-------------------------------------------------------------------------
     7                              <1> ;
     8                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     9                              <1> ;
    10                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    11                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    12                              <1> ;
    13                              <1> ; This program is free software: you can redistribute it and/or modify
    14                              <1> ; it under the terms of the GNU General Public License as published by
    15                              <1> ; the Free Software Foundation, either version 3 of the License, or
    16                              <1> ; (at your option) any later version.
    17                              <1> ;
    18                              <1> ; This program is distributed in the hope that it will be useful,
    19                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                              <1> ; GNU General Public License for more details.
    22                              <1> ;
    23                              <1> ; You should have received a copy of the GNU General Public License
    24                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    25                              <1> ;
    26                              <1> ;=========================================================================
    27                              <1> 
    28                              <1> ;=========================================================================
    29                              <1> ; int_1A_fn00 - Read current time
    30                              <1> ; Input:
    31                              <1> ;	AH = 0 - read current time
    32                              <1> ; Output:
    33                              <1> ;	CX = high word of tick count
    34                              <1> ;	DX = low word of tick count
    35                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
    36                              <1> ;-------------------------------------------------------------------------
    37                              <1> int_1A_fn00:
    38 00001229 8B166C00            <1> 	mov	dx,word [ticks_lo]
    39 0000122D 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
    40 00001231 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
    41 00001234 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
    42 00001238 E95A5C              <1> 	jmp	int_1A_exit
    43                              <1> 
    44                              <1> ;=========================================================================
    45                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
    46                              <1> ; Input:
    47                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
    48                              <1> ;	CX = high word of tick count
    49                              <1> ;	DX = low word of tick count
    50                              <1> ; Output:
    51                              <1> ;	None
    52                              <1> ;-------------------------------------------------------------------------
    53                              <1> int_1A_fn01:
    54 0000123B 89166C00            <1> 	mov	word [ticks_lo],dx
    55 0000123F 890E6E00            <1> 	mov	word [ticks_hi],cx
    56 00001243 C606700000          <1> 	mov	byte [new_day],00h
    57 00001248 E94A5C              <1> 	jmp	int_1A_exit
    58                              <1> 
    59                              <1> %ifdef AT_RTC
    60                              <1> 
    61                              <1> ;=========================================================================
    62                              <1> ; int_1A_fn02 - Read real time clock (RTC)
    63                              <1> ; Input:
    64                              <1> ;	AH = 02h - function 02h - read RTC time
    65                              <1> ; Output:
    66                              <1> ;	CF set if RTC update is in progress and operation was not performed
    67                              <1> ;	CH = BCD hours
    68                              <1> ;	CL = BCD minutes
    69                              <1> ;	DH = BCD seconds
    70                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
    71                              <1> ;-------------------------------------------------------------------------
    72                              <1> int_1A_fn02:
    73                              <1> %ifdef AT_RTC_AUTODETECT
    74                              <1> 	call	rtc_detect		; check that RTC is present
    75                              <1> 	jc	int_1A_exitf		; error - no RTC
    76                              <1> %endif ; AT_RTC_AUTODETECT
    77 0000124B 50                  <1> 	push	ax
    78 0000124C B00A                <1> 	mov	al,cmos_control_a
    79 0000124E E8CDF9              <1> 	call	rtc_read		; read control A register
    80 00001251 A880                <1> 	test	al,cmos_uip
    81 00001253 7405                <1> 	jz	.1			; no update in progess
    82 00001255 F9                  <1> 	stc
    83 00001256 58                  <1> 	pop	ax
    84 00001257 E93E5C              <1> 	jmp	int_1A_exitf
    85                              <1> .1:
    86 0000125A B00B                <1> 	mov	al,cmos_control_b
    87 0000125C E8BFF9              <1> 	call	rtc_read		; read control B register
    88 0000125F 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
    89 00001261 88C2                <1> 	mov	dl,al
    90 00001263 B000                <1> 	mov	al,cmos_seconds
    91 00001265 E8B6F9              <1> 	call	rtc_read		; read seconds
    92 00001268 88C6                <1> 	mov	dh,al
    93 0000126A B002                <1> 	mov	al,cmos_minutes
    94 0000126C E8AFF9              <1> 	call	rtc_read		; read minutes
    95 0000126F 88C1                <1> 	mov	cl,al
    96 00001271 B004                <1> 	mov	al,cmos_hours
    97 00001273 E8A8F9              <1> 	call	rtc_read		; read hours
    98 00001276 88C5                <1> 	mov	ch,al
    99 00001278 F8                  <1> 	clc
   100 00001279 58                  <1> 	pop	ax
   101 0000127A E91B5C              <1> 	jmp	int_1A_exitf
   102                              <1> 
   103                              <1> ;=========================================================================
   104                              <1> ; int_1A_fn03 - Set real time clock
   105                              <1> ; Input:
   106                              <1> ;	AH = 03h - function 03h - set RTC time
   107                              <1> ;	CH = BCD hours
   108                              <1> ;	CL = BCD minutes
   109                              <1> ;	DH = BCD seconds
   110                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   111                              <1> ; Output:
   112                              <1> ;	None
   113                              <1> ;-------------------------------------------------------------------------
   114                              <1> int_1A_fn03:
   115                              <1> %ifdef AT_RTC_AUTODETECT
   116                              <1> 	call	rtc_detect		; check that RTC is present
   117                              <1> 	jc	int_1A_exitf		; error - no RTC
   118                              <1> %endif ; AT_RTC_AUTODETECT
   119 0000127D 50                  <1> 	push	ax
   120 0000127E B00B                <1> 	mov	al,cmos_control_b
   121 00001280 E89BF9              <1> 	call	rtc_read		; read control B register
   122 00001283 88C4                <1> 	mov	ah,al
   123 00001285 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   124 00001288 B00B                <1> 	mov	al,cmos_control_b
   125 0000128A E8A0F9              <1> 	call	rtc_write		; write control B register
   126                              <1> 
   127 0000128D 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
   128 00001290 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
   129 00001293 08D4                <1> 	or	ah,dl			; add it from the input
   130 00001295 B00B                <1> 	mov	al,cmos_control_b
   131 00001297 E893F9              <1> 	call	rtc_write		; write control B register
   132                              <1> 
   133 0000129A B000                <1> 	mov	al,cmos_seconds
   134 0000129C 88F4                <1> 	mov	ah,dh
   135 0000129E E88CF9              <1> 	call	rtc_write		; write seconds
   136 000012A1 B002                <1> 	mov	al,cmos_minutes
   137 000012A3 88CC                <1> 	mov	ah,cl
   138 000012A5 E885F9              <1> 	call	rtc_write		; write minutes
   139 000012A8 B004                <1> 	mov	al,cmos_hours
   140 000012AA 88EC                <1> 	mov	ah,ch
   141 000012AC E87EF9              <1> 	call	rtc_write		; write hours
   142                              <1> 
   143 000012AF B00B                <1> 	mov	al,cmos_control_b
   144 000012B1 E86AF9              <1> 	call	rtc_read		; read control B register
   145 000012B4 88C4                <1> 	mov	ah,al
   146 000012B6 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   147 000012B9 B00B                <1> 	mov	al,cmos_control_b
   148 000012BB E86FF9              <1> 	call	rtc_write		; write control B register
   149 000012BE 58                  <1> 	pop	ax
   150 000012BF E9D35B              <1> 	jmp	int_1A_exit
   151                              <1> 
   152                              <1> ;=========================================================================
   153                              <1> ; int_1A_fn04 - Read date from real time clock
   154                              <1> ; Input:
   155                              <1> ;	AH = 04h - function 04h - read RTC date
   156                              <1> ; Output:
   157                              <1> ;	CF set if RTC update is in progress and operation was not performed
   158                              <1> ;	CH = BCD century
   159                              <1> ;	CL = BCD year
   160                              <1> ;	DH = BCD month
   161                              <1> ;	DL = BCD date
   162                              <1> ;-------------------------------------------------------------------------
   163                              <1> int_1A_fn04:
   164                              <1> %ifdef AT_RTC_AUTODETECT
   165                              <1> 	call	rtc_detect		; check that RTC is present
   166                              <1> 	jc	int_1A_exitf		; error - no RTC
   167                              <1> %endif ; AT_RTC_AUTODETECT
   168 000012C2 50                  <1> 	push	ax
   169 000012C3 B00A                <1> 	mov	al,cmos_control_a
   170 000012C5 E856F9              <1> 	call	rtc_read		; read control A register
   171 000012C8 A880                <1> 	test	al,cmos_uip
   172 000012CA 7405                <1> 	jz	.1			; no update in progess
   173 000012CC F9                  <1> 	stc
   174 000012CD 58                  <1> 	pop	ax
   175 000012CE E9C75B              <1> 	jmp	int_1A_exitf
   176                              <1> .1:
   177 000012D1 B007                <1> 	mov	al,cmos_date
   178 000012D3 E848F9              <1> 	call	rtc_read		; read date
   179 000012D6 88C2                <1> 	mov	dl,al
   180 000012D8 B008                <1> 	mov	al,cmos_month
   181 000012DA E841F9              <1> 	call	rtc_read		; read month
   182 000012DD 88C6                <1> 	mov	dh,al
   183 000012DF B009                <1> 	mov	al,cmos_year
   184 000012E1 E83AF9              <1> 	call	rtc_read		; read year
   185 000012E4 88C1                <1> 	mov	cl,al
   186 000012E6 B032                <1> 	mov	al,cmos_century
   187 000012E8 E833F9              <1> 	call	rtc_read		; read century
   188 000012EB 88C5                <1> 	mov	ch,al
   189 000012ED F8                  <1> 	clc
   190 000012EE 58                  <1> 	pop	ax
   191 000012EF E9A65B              <1> 	jmp	int_1A_exitf
   192                              <1> 
   193                              <1> ;=========================================================================
   194                              <1> ; int_1A_fn05 - Set date in real time clock
   195                              <1> ; Input:
   196                              <1> ;	AH = 05h - function 05h - set RTC date
   197                              <1> ;	CH = BCD century
   198                              <1> ;	CL = BCD year
   199                              <1> ;	DH = BCD month
   200                              <1> ;	DL = BCD date
   201                              <1> ; Output:
   202                              <1> ;	None
   203                              <1> ;-------------------------------------------------------------------------
   204                              <1> int_1A_fn05:
   205                              <1> %ifdef AT_RTC_AUTODETECT
   206                              <1> 	call	rtc_detect		; check that RTC is present
   207                              <1> 	jc	int_1A_exitf		; error - no RTC
   208                              <1> %endif ; AT_RTC_AUTODETECT
   209 000012F2 50                  <1> 	push	ax
   210 000012F3 B00B                <1> 	mov	al,cmos_control_b
   211 000012F5 E826F9              <1> 	call	rtc_read		; read control B register
   212 000012F8 88C4                <1> 	mov	ah,al
   213 000012FA 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   214 000012FD B00B                <1> 	mov	al,cmos_control_b
   215 000012FF E82BF9              <1> 	call	rtc_write		; write control B register
   216                              <1> 
   217 00001302 B007                <1> 	mov	al,cmos_date
   218 00001304 88D4                <1> 	mov	ah,dl
   219 00001306 E824F9              <1> 	call	rtc_write		; write date
   220                              <1> 
   221 00001309 B008                <1> 	mov	al,cmos_month
   222 0000130B 88F4                <1> 	mov	ah,dh
   223 0000130D E81DF9              <1> 	call	rtc_write		; write month
   224 00001310 B009                <1> 	mov	al,cmos_year
   225 00001312 88CC                <1> 	mov	ah,cl
   226 00001314 E816F9              <1> 	call	rtc_write		; write year
   227 00001317 B032                <1> 	mov	al,cmos_century
   228 00001319 88EC                <1> 	mov	ah,ch
   229 0000131B E80FF9              <1> 	call	rtc_write		; write centry
   230                              <1> 
   231 0000131E B00B                <1> 	mov	al,cmos_control_b
   232 00001320 E8FBF8              <1> 	call	rtc_read		; read control B register
   233 00001323 88C4                <1> 	mov	ah,al
   234 00001325 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   235 00001328 B00B                <1> 	mov	al,cmos_control_b
   236 0000132A E800F9              <1> 	call	rtc_write		; write control B register
   237 0000132D 58                  <1> 	pop	ax
   238 0000132E E9645B              <1> 	jmp	int_1A_exit
   239                              <1> 
   240                              <1> ;=========================================================================
   241                              <1> ; int_1A_fn06 - Set real time clock alarm
   242                              <1> ; Input:
   243                              <1> ;	AH = 06h - function 06h - set RTC alarm time
   244                              <1> ;	CH = BCD hours
   245                              <1> ;	CL = BCD minutes
   246                              <1> ;	DH = BCD seconds
   247                              <1> ; Output:
   248                              <1> ;	CF = 1 - alarm already set
   249                              <1> ;-------------------------------------------------------------------------
   250                              <1> int_1A_fn06:
   251                              <1> %ifdef AT_RTC_AUTODETECT
   252                              <1> 	call	rtc_detect		; check that RTC is present
   253                              <1> 	jc	int_1A_exitf		; error - no RTC
   254                              <1> %endif ; AT_RTC_AUTODETECT
   255 00001331 50                  <1> 	push	ax
   256 00001332 B00B                <1> 	mov	al,cmos_control_b
   257 00001334 E8E7F8              <1> 	call	rtc_read		; read control B register
   258 00001337 A820                <1> 	test	al,cmos_aie
   259 00001339 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
   260 0000133B F9                  <1> 	stc
   261 0000133C 58                  <1> 	pop	ax
   262 0000133D E9585B              <1> 	jmp	int_1A_exitf
   263                              <1> .1:
   264 00001340 88C4                <1> 	mov	ah,al
   265 00001342 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   266 00001345 B00B                <1> 	mov	al,cmos_control_b
   267 00001347 E8E3F8              <1> 	call	rtc_write		; write control B register
   268                              <1> 
   269 0000134A B001                <1> 	mov	al,cmos_alarm_secs
   270 0000134C 88F4                <1> 	mov	ah,dh
   271 0000134E E8DCF8              <1> 	call	rtc_write		; write alarm seconds
   272 00001351 B003                <1> 	mov	al,cmos_alarm_mins
   273 00001353 88CC                <1> 	mov	ah,cl
   274 00001355 E8D5F8              <1> 	call	rtc_write		; write alarm minutes
   275 00001358 B005                <1> 	mov	al,cmos_alarm_hrs
   276 0000135A 88EC                <1> 	mov	ah,ch
   277 0000135C E8CEF8              <1> 	call	rtc_write		; write alarm hours
   278                              <1> 
   279 0000135F B00B                <1> 	mov	al,cmos_control_b
   280 00001361 E8BAF8              <1> 	call	rtc_read		; read control B register
   281 00001364 88C4                <1> 	mov	ah,al
   282 00001366 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
   283 00001369 B00B                <1> 	mov	al,cmos_control_b
   284 0000136B E8BFF8              <1> 	call	rtc_write		; write control B register
   285                              <1> 
   286 0000136E B00B                <1> 	mov	al,cmos_control_b
   287 00001370 E8ABF8              <1> 	call	rtc_read		; read control B register
   288 00001373 88C4                <1> 	mov	ah,al
   289 00001375 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
   290 00001378 B00B                <1> 	mov	al,cmos_control_b
   291 0000137A E8B0F8              <1> 	call	rtc_write		; write control B register with AIE set
   292                              <1> 
   293 0000137D 58                  <1> 	pop	ax
   294 0000137E F8                  <1> 	clc
   295 0000137F E9165B              <1> 	jmp	int_1A_exitf
   296                              <1> 
   297                              <1> ;=========================================================================
   298                              <1> ; int_1A_fn07 - Reset real time clock alarm
   299                              <1> ; Input:
   300                              <1> ;	AH = 07h - function 07h - set RTC time
   301                              <1> ; Output:
   302                              <1> ;	None
   303                              <1> ;-------------------------------------------------------------------------
   304                              <1> int_1A_fn07:
   305                              <1> %ifdef AT_RTC_AUTODETECT
   306                              <1> 	call	rtc_detect		; check that RTC is present
   307                              <1> 	jc	int_1A_exitf		; error - no RTC
   308                              <1> %endif ; AT_RTC_AUTODETECT
   309 00001382 50                  <1> 	push	ax
   310                              <1> 
   311 00001383 B00B                <1> 	mov	al,cmos_control_b
   312 00001385 E896F8              <1> 	call	rtc_read		; read control B register
   313 00001388 88C4                <1> 	mov	ah,al
   314 0000138A 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
   315 0000138D B00B                <1> 	mov	al,cmos_control_b
   316 0000138F E89BF8              <1> 	call	rtc_write		; write control B reg. with AIE cleared
   317                              <1> 
   318 00001392 58                  <1> 	pop	ax
   319 00001393 E9FF5A              <1> 	jmp	int_1A_exit
   320                              <1> 	
   321                              <1> %ifdef SECOND_PIC
   322                              <1> ;=========================================================================
   323                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
   324                              <1> ; Notes:
   325                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
   326                              <1> ;-------------------------------------------------------------------------
   327                              <1> int_70:
   328 00001396 50                  <1> 	push	ax
   329 00001397 B020                <1> 	mov	al,20h
   330 00001399 E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
   331 0000139B E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
   332 0000139D B00C                <1> 	mov	al,cmos_control_c
   333 0000139F E87CF8              <1> 	call	rtc_read		; read control C register
   334 000013A2 A840                <1> 	test	al,cmos_af		; check for alarm flag
   335 000013A4 7402                <1> 	jz	.1
   336 000013A6 CD4A                <1> 	int	4Ah			; call INT 4Ah
   337                              <1> .1:
   338 000013A8 58                  <1> 	pop	ax
   339 000013A9 CF                  <1> 	iret
   340                              <1> %endif ; SECOND_PIC
   341                              <1> 
   342                              <1> %endif ; AT_RTC
   274                                  %include	"floppy1.inc"		; floppy services
     1                              <1> ;=========================================================================
     2                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
     3                              <1> ;	INT 13h, function AH=00h
     4                              <1> ;	INT 13h, function AH=01h
     5                              <1> ;	INT 13h, function AH=08h
     6                              <1> ;	INT 13h, function AH=15h
     7                              <1> ;	INT 13h, function AH=16h
     8                              <1> ;	INT 13h, function AH=17h
     9                              <1> ;	INT 13h, function AH=18h
    10                              <1> ;	INT 13h, function AH=08h
    11                              <1> ;	- see floppy2.inc for other INT 13h functions
    12                              <1> ;-------------------------------------------------------------------------
    13                              <1> ;
    14                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    15                              <1> ;
    16                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    17                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    18                              <1> ;
    19                              <1> ; This program is free software: you can redistribute it and/or modify
    20                              <1> ; it under the terms of the GNU General Public License as published by
    21                              <1> ; the Free Software Foundation, either version 3 of the License, or
    22                              <1> ; (at your option) any later version.
    23                              <1> ;
    24                              <1> ; This program is distributed in the hope that it will be useful,
    25                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    26                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    27                              <1> ; GNU General Public License for more details.
    28                              <1> ;
    29                              <1> ; You should have received a copy of the GNU General Public License
    30                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    31                              <1> ;
    32                              <1> ; Modifications by DH for DMA controller issues with register writes and byte order
    33                              <1> ; Updated 18/07/2024 to disable DMA and use Programmed IO based on PCJr BIOS
    34                              <1> ;
    35                              <1> ;=========================================================================
    36                              <1> 
    37                              <1> ;-------------------------------------------------------------------------
    38                              <1> ; FDC registers
    39                              <1> 
    40                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
    41                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
    42                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
    43                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W) AKA LDCR
    44                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R) AKA LDCR
    45                              <1> 
    46                              <1> ; FDC status register bits
    47                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
    48                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
    49                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
    50                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
    51                              <1> fdc_exec_mode	equ	20h		; 1 = BBPC Execution Mode when DMA disabled 0 = Results Mode 
    52                              <1> 
    53                              <1> ;-------------------------------------------------------------------------
    54                              <1> ; DMAC registers
    55                              <1> 
    56                              <1> dmac_ch0_addr_reg	equ	00h	; DMAC channel 0 base addres (W)
    57                              <1> dmac_ch0_count_reg	equ	01h	; DMAC channel 0 word count (W)
    58                              <1> dmac_ch1_addr_reg	equ	02h	; DMAC channel 1 base addres (W)
    59                              <1> dmac_ch1_count_reg	equ	03h	; DMAC channel 1 word count (W)
    60                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
    61                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
    62                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
    63                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
    64                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
    65                              <1> 					; first / last flip-flop
    66                              <1> dmac_all_mask_reg	equ	0Fh	; DMAC single mask bit register (W)
    67                              <1> 
    68                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
    69                              <1> 
    70                              <1> ;-------------------------------------------------------------------------
    71                              <1> ; Floppy disk services - error codes
    72                              <1> 
    73                              <1> fdc_e_success	equ	00h		; successful completion
    74                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
    75                              <1> fdc_e_address	equ	02h		; address mark not found
    76                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
    77                              <1> fdc_e_notfound	equ	04h		; sector not found
    78                              <1> fdc_e_changed	equ	06h		; disk changed
    79                              <1> fdc_e_dma	equ	08h		; DMA overrun
    80                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
    81                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
    82                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
    83                              <1> fdc_e_failure	equ	20h		; controller failure
    84                              <1> fdc_e_seek	equ	40h		; seek failed
    85                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
    86                              <1> 
    87                              <1> ;-------------------------------------------------------------------------
    88                              <1> ; Drive media state for fdc_media_state
    89                              <1> 
    90                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
    91                              <1> 					; 00b = 500 Kbit/sec
    92                              <1> 					; 01b = 300 Kbit/sec
    93                              <1> 					; 10b = 250 Kbit/sec
    94                              <1> 					; 11b = 1 Mbit/sec
    95                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
    96                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
    97                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
    98                              <1> 					; 000b = trying 360K in 360K drive
    99                              <1> 					; 001b = trying 360K in 1.2M drive
   100                              <1> 					; 010b = trying 1.2M in 1.2M drive
   101                              <1> 					; 011b = known 360K in 360K drive
   102                              <1> 					; 100b = known 360K in 1.2M drive
   103                              <1> 					; 101b = known 1.2M in 1.2M drive
   104                              <1> 					; 110b = not used
   105                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
   106                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
   107                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
   108                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
   109                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
   110                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
   111                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
   112                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
   113                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
   114                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
   115                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
   116                              <1> 
   117                              <1> ;-------------------------------------------------------------------------
   118                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
   119                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
   120                              <1> 
   121                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
   122                              <1> 
   123                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
   124                              <1> ;	       unset for read or verify
   125                              <1> 
   126                              <1> fdc_write_flag	equ	80h		; write or format operation
   127                              <1> 
   128                              <1> ;-------------------------------------------------------------------------
   129                              <1> ; floppy drive type definitions
   130                              <1> 
   131                              <1> type_none	equ	00h
   132                              <1> type_360	equ	01h
   133                              <1> type_1200	equ	02h
   134                              <1> type_720	equ	03h
   135                              <1> type_1440	equ	04h
   136                              <1> type_2880	equ	06h
   137                              <1> 
   138                              <1> ;=========================================================================
   139                              <1> ; int_13_fn00: Reset disk system
   140                              <1> ; Input:
   141                              <1> ;	AH = 00h
   142                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   143                              <1> ; Output:
   144                              <1> ;	CF clear if successful
   145                              <1> ;		AH = 00h - successful completion
   146                              <1> ;	CF set on error
   147                              <1> ;		AH = 20h - controller failure
   148                              <1> ;		AH = 80h - timeout / device not ready
   149                              <1> ; Note:
   150                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   151                              <1> ;	normally will call this functions if bit 7 of DL is not set
   152                              <1> ;-------------------------------------------------------------------------
   153                              <1> int_13_fn00:
   154 000013AA E80700              <1> 	call	fdc_init
   155 000013AD 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   156 000013B1 E93D49              <1> 	jmp	int_13_exit
   157                              <1> 
   158                              <1> ;=========================================================================
   159                              <1> ; fdc_init - Initialize floppy disk controller
   160                              <1> ; Input:
   161                              <1> ;	none
   162                              <1> ; Output:
   163                              <1> ;	CF clear on success
   164                              <1> ;		AH = 00h - successful completion
   165                              <1> ;	CF set if error
   166                              <1> ;		AH = 20h - controller failure
   167                              <1> ;		AH = 80h - timeout / device not ready
   168                              <1> ;-------------------------------------------------------------------------
   169                              <1> fdc_init:
   170 000013B4 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
   171 000013B9 E82605              <1> 	call	fdc_reset		; reset FDC
   172 000013BC 723D                <1> 	jc	fdc_init_error
   173 000013BE BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   174 000013C1 EC                  <1> 	in	al,dx
   175 000013C2 A880                <1> 	test	al,80h
   176 000013C4 7404                <1> 	jz	.try_again		; try again if FDC not ready
   177 000013C6 A840                <1> 	test	al,40h
   178 000013C8 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
   179                              <1> .try_again:
   180 000013CA E81505              <1> 	call	fdc_reset
   181 000013CD BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   182 000013D0 EC                  <1> 	in	al,dx
   183 000013D1 A880                <1> 	test	al,80h
   184 000013D3 7426                <1> 	jz	fdc_init_error
   185 000013D5 A840                <1> 	test	al,40h
   186 000013D7 7522                <1> 	jnz	fdc_init_error
   187                              <1> .fdc_ready:
   188                              <1> 
   189                              <1> ;	mov	al,08h			; FDC Sense Interrupt Status command, this returns C0 under DMA and causes issues with NO DMA status polling as reset does not raise IRQ!!
   190                              <1> ;	call	fdc_write		; send the command
   191                              <1> ;	jc	fdc_init_error
   192                              <1> ;	call	fdc_read		; read ST0
   193                              <1> ;	jc	fdc_init_error
   194                              <1> ;	mov	byte [fdc_ctrl_status],al  ; save ST0
   195                              <1> ;	mov	ah,al			; save AL to AH
   196                              <1> ;	call	fdc_read		; read current cylinder
   197                              <1> ;	jc	fdc_init_error
   198                              <1> ;	mov	byte [fdc_ctrl_status+1],al  ; save
   199                              <1> ;	and	ah,0C0h
   200                              <1> ;	cmp	ah,0C0h			; abnormal termination?
   201                              <1> ;	jne	fdc_init_error	; not an abnormal termination
   202                              <1> 
   203                              <1> ; fall through to fdc_send_specify
   204                              <1> 
   205                              <1> ;=========================================================================
   206                              <1> ; fdc_send_specify - Send specify command to FDC
   207                              <1> ; Input:
   208                              <1> ;	none
   209                              <1> ; Output:
   210                              <1> ;	CF clear on success
   211                              <1> ;		AH = 00 - successful completion
   212                              <1> ;	CF set if error
   213                              <1> ;		AH = 20h - controller failure
   214                              <1> ;	AX,CL,SI trashed
   215                              <1> ; Note:
   216                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
   217                              <1> ;       BBPC Modified to set Byte 1 bit 0 ND=1 to disable DMA
   218                              <1> ;-------------------------------------------------------------------------
   219                              <1> fdc_send_specify:
   220 000013D9 1E                  <1> 	push	ds
   221 000013DA 53                  <1>         push    bx
   222 000013DB 31F6                <1> 	xor	si,si
   223 000013DD 8EDE                <1> 	mov	ds,si
   224                              <1>                                         ; BBPC Changed to disable DMA by setting ND bit, no need to change media bytes
   225 000013DF C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   226 000013E3 B003                <1> 	mov	al,3		 	; FDC Specify command
   227 000013E5 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
   228 000013E7 8B5C01              <1> 	mov	bx,word [si+1]		; specify command - byte 1, do this first so we can disable DMA
   229 000013EA 80CB01              <1>         or      bl, 0x01                ; Bit 0 on Byte 1 is ND Non-DMA =1 for disable DMA
   230 000013ED 89DE                <1>         mov     si, word bx             ; Copy bl to si (bh don't care)
   231                              <1> 
   232 000013EF B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low, SI - High don't care)
   233 000013F1 5B                  <1>         pop     bx
   234 000013F2 1F                  <1> 	pop	ds
   235 000013F3 E8E103              <1> 	call	fdc_send_cmd		; send specify command to FDC
   236 000013F6 7203                <1> 	jc	fdc_init_error
   237 000013F8 B400                <1> 	mov	ah,fdc_e_success	; successful completion
   238 000013FA C3                  <1> 	ret
   239                              <1> 
   240                              <1> fdc_init_error:
   241 000013FB B420                <1> 	mov	ah,fdc_e_failure
   242 000013FD F9                  <1> 	stc
   243 000013FE C3                  <1> 	ret
   244                              <1> 
   245                              <1> ;=========================================================================
   246                              <1> ; int_13_fn01 - Get status of last operation
   247                              <1> ; Input:
   248                              <1> ;	AH = 01h
   249                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   250                              <1> ; Output:
   251                              <1> ;	CF clear if last operation was successful
   252                              <1> ;		AH = 00h - successful completion
   253                              <1> ;	CF set on error
   254                              <1> ;		AH - error code of the last operation
   255                              <1> ; Note:
   256                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   257                              <1> ;	normally will call this functions if bit 7 of DL is not set
   258                              <1> ;-------------------------------------------------------------------------
   259                              <1> int_13_fn01:
   260 000013FF 8A264100            <1> 	mov	ah,byte [fdc_last_error]
   261 00001403 08E4                <1> 	or	ah,ah
   262 00001405 7401                <1> 	jz	.no_error
   263 00001407 F9                  <1> 	stc
   264                              <1> .no_error:
   265 00001408 E9E648              <1> 	jmp	int_13_exit
   266                              <1> 
   267                              <1> ;=========================================================================
   268                              <1> ; int_13_fn08: Get drive parameters
   269                              <1> ; Input:
   270                              <1> ;	AH = 08h
   271                              <1> ;	DL = drive number (0 - 7Fh)
   272                              <1> ; Output:
   273                              <1> ;	CF clear if successful
   274                              <1> ;		AX = 0000h
   275                              <1> ;		BH = 00h
   276                              <1> ;		BL = drive type
   277                              <1> ;		CH = maximal cylinder number - 1
   278                              <1> ;		CL = maximal sector number
   279                              <1> ;		DH = maximal head number
   280                              <1> ;		DL = number of drives
   281                              <1> ;		ES:DI -> diskette parameter table
   282                              <1> ;	CF set on error
   283                              <1> ;		AH = 01h - drive number is greater than 7Fh
   284                              <1> ; Notes:
   285                              <1> ;	- If non-existent drive number is specified, function returns zeros in
   286                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
   287                              <1> ;	- If media type is not established function sets media parameters 
   288                              <1> ;	based on drive type
   289                              <1> ;-------------------------------------------------------------------------
   290                              <1> int_13_fn08:
   291                              <1> 
   292 0000140B 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
   293 0000140E 7203E99E00          <1> 	jae	.invalid_drive		; hard drive number specified
   294 00001413 A01000              <1> 	mov	al,byte [equipment_list]
   295 00001416 2441                <1> 	and	al,equip_floppies|equip_floppy2
   296 00001418 B402                <1> 	mov	ah,2			; assume two floppy drives
   297 0000141A 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
   298 0000141C 7406                <1> 	je	.check_drive_number
   299 0000141E FECC                <1> 	dec	ah			; assume one floppy drive
   300 00001420 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
   301 00001422 757B                <1> 	jne	.no_drives
   302                              <1> 
   303                              <1> .check_drive_number:
   304 00001424 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
   305 00001427 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
   306                              <1> 					; than number of disks?
   307 00001429 7378                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
   308 0000142B E83506              <1> 	call	get_drive_type		; returns drive type in AL
   309 0000142E 7273                <1> 	jc	.non_existent_drive	; return no drive if there is an error
   310                              <1> 
   311 00001430 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
   312 00001434 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass drive type to caller
   313 00001437 8CC9                <1> 	mov	cx,cs
   314 00001439 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
   315                              <1> 
   316 0000143B 3C01                <1> 	cmp	al,type_360
   317 0000143D 7417                <1> 	je	.set_360
   318 0000143F 3C03                <1> 	cmp	al,type_720
   319 00001441 741E                <1> 	je	.set_720
   320 00001443 3C02                <1> 	cmp	al,type_1200
   321 00001445 7425                <1> 	je	.set_1200
   322 00001447 3C04                <1> 	cmp	al,type_1440
   323 00001449 742C                <1> 	je	.set_1440
   324                              <1> 
   325                              <1> .set_2880:
   326 0000144B B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
   327 0000144D 8D3E[B05F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
   328 00001451 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
   329 00001454 EB2A                <1> 	jmp	.set_media_type
   330                              <1> 
   331                              <1> .set_360:
   332 00001456 B093                <1> 	mov	al,fdc_m_360in360
   333 00001458 8D3E[6F5F]          <1> 	lea	di,[media_360_in_360]
   334 0000145C B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
   335 0000145F EB1F                <1> 	jmp	.set_media_type
   336                              <1> 
   337                              <1> .set_720:
   338 00001461 B097                <1> 	mov	al,fdc_m_720
   339 00001463 8D3E[895F]          <1> 	lea	di,[media_720]
   340 00001467 B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
   341 0000146A EB14                <1> 	jmp	.set_media_type
   342                              <1> 
   343                              <1> .set_1200:
   344 0000146C B002                <1> 	mov	al,fdc_m_try_1200in1200
   345 0000146E 8D3E[7C5F]          <1> 	lea	di,[media_1200]
   346 00001472 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
   347 00001475 EB09                <1> 	jmp	.set_media_type
   348                              <1> 
   349                              <1> .set_1440:
   350 00001477 B007                <1> 	mov	al,fdc_m_try_1440
   351 00001479 8D3E[965F]          <1> 	lea	di,[media_1440]
   352 0000147D B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
   353                              <1> 
   354                              <1> .set_media_type:
   355 00001480 E88005              <1> 	call	get_media_state
   356 00001483 F6C310              <1> 	test	bl,fdc_m_established	; media type established?
   357 00001486 7503                <1> 	jnz	.set_parameters		; no need to update if established
   358 00001488 E88205              <1> 	call	set_media_state
   359                              <1> 
   360                              <1> .set_parameters:
   361 0000148B 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
   362 0000148D 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
   363 00001490 A24100              <1> 	mov	byte [fdc_last_error],al
   364 00001493 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
   365 00001496 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
   366 00001499 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
   367 0000149C E95248              <1> 	jmp	int_13_exit
   368                              <1> 
   369                              <1> .no_drives:
   370 0000149F C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
   371                              <1> 
   372                              <1> .non_existent_drive:
   373 000014A3 31C9                <1> 	xor	cx,cx
   374 000014A5 31FF                <1> 	xor	di,di
   375 000014A7 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; drive type is zero
   376 000014AA 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
   377 000014AD 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
   378 000014AF EBDA                <1> 	jmp	.set_parameters
   379                              <1> 
   380                              <1> .invalid_drive:
   381 000014B1 B401                <1> 	mov	ah,fdc_e_invalid
   382 000014B3 F9                  <1> 	stc
   383 000014B4 E93A48              <1> 	jmp	int_13_exit
   384                              <1> 
   385                              <1> ;=========================================================================
   386                              <1> ; int_13_fn15: Get disk type
   387                              <1> ; Input:
   388                              <1> ;	AH = 15h
   389                              <1> ;	DL = drive number (0 or 1)
   390                              <1> ; Output:
   391                              <1> ;	AH = type code:
   392                              <1> ;		00h - no such drive (invalid drive specified)
   393                              <1> ;		01h - floppy without change-line support
   394                              <1> ;		02h - floppy with change-line support
   395                              <1> ;-------------------------------------------------------------------------
   396                              <1> int_13_fn15:
   397 000014B7 B400                <1> 	mov	ah,00h			; assume no drive
   398 000014B9 3C00                <1> 	cmp	al,type_none
   399 000014BB 740C                <1> 	je	.exit
   400 000014BD B401                <1> 	mov	ah,01h			; assume no change-line support
   401 000014BF 3C01                <1> 	cmp	al,type_360
   402 000014C1 7406                <1> 	je	.exit
   403 000014C3 3C03                <1> 	cmp	al,type_720		; no change-line support on 720K drives?
   404 000014C5 7402                <1> 	je	.exit
   405 000014C7 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
   406                              <1> 
   407                              <1> .exit:
   408 000014C9 F8                  <1> 	clc
   409 000014CA C606410000          <1> 	mov	byte [fdc_last_error],0
   410 000014CF E91F48              <1> 	jmp	int_13_exit
   411                              <1> 
   412                              <1> ;=========================================================================
   413                              <1> ; int_13_fn16 - Detect disk change
   414                              <1> ; Input:
   415                              <1> ;	AH = 16h
   416                              <1> ;	DL = drive number (0 or 1)
   417                              <1> ; Output:
   418                              <1> ;	CF clear if change line inactive
   419                              <1> ;		AH = 00h - disk not changed
   420                              <1> ;	CF set if change line active or error
   421                              <1> ;		AH = 01h - invalid drive number
   422                              <1> ;		AH = 06h - disk changed or change line not supported
   423                              <1> ;		AH = 80h - timeout / device not ready
   424                              <1> ;-------------------------------------------------------------------------
   425                              <1> int_13_fn16:
   426 000014D2 3C01                <1> 	cmp	al,type_360
   427 000014D4 7430                <1> 	je	.no_change_line		; report disk changed for 360K drives
   428 000014D6 3C03                <1> 	cmp	al,type_720
   429 000014D8 742C                <1> 	je	.no_change_line		; report disk changed for 720K drives
   430                              <1> 
   431 000014DA E80002              <1> 	call	fdc_motor_on		; turn motor on
   432 000014DD 30E4                <1> 	xor	ah,ah			; assume disk not changed
   433 000014DF BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
   434 000014E2 EC                  <1> 	in	al,dx			; read disk change line
   435                              <1>   ; WD37C65C in DIP form does not support disk change, fake no change!
   436 000014E3 B07F                <1>   mov al, 0x7f
   437 000014E5 D0E0                <1> 	shl	al,1			; bit 7 to CF
   438 000014E7 7303                <1> 	jnc	.exit
   439 000014E9 B406                <1> 	mov	ah,fdc_e_changed
   440 000014EB F9                  <1> 	stc
   441                              <1> 
   442                              <1> .exit:
   443 000014EC 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   444 000014F0 9C                  <1> 	pushf
   445 000014F1 1E                  <1> 	push	ds
   446 000014F2 31F6                <1> 	xor	si,si
   447 000014F4 8EDE                <1> 	mov	ds,si
   448 000014F6 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   449 000014FA 8A4C02              <1> 	mov	cl,byte [si+2]
   450 000014FD 1F                  <1> 	pop	ds
   451 000014FE 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
   452 00001502 9D                  <1> 	popf
   453 00001503 E9EB47              <1> 	jmp	int_13_exit
   454                              <1> 
   455                              <1> .no_change_line:
   456 00001506 B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
   457 00001508 F9                  <1> 	stc
   458 00001509 88264100            <1> 	mov	byte [fdc_last_error],ah
   459 0000150D E9E147              <1> 	jmp	int_13_exit
   460                              <1> 
   461                              <1> .invalid_drive:
   462 00001510 B401                <1> 	mov	ah,fdc_e_invalid
   463 00001512 F9                  <1> 	stc
   464 00001513 E9DB47              <1> 	jmp	int_13_exit
   465                              <1> 
   466                              <1> ;=========================================================================
   467                              <1> ; int_13_fn17 - Set disk type for format
   468                              <1> ; Input:
   469                              <1> ;	AH = 17h
   470                              <1> ;	AL = format type
   471                              <1> ;		01h - 320K / 360K disk in 360K drive
   472                              <1> ;		02h - 320K / 360K disk in 1.2M drive
   473                              <1> ;		03h - 1.2M disk in 1.2M drive
   474                              <1> ;		04h - 720K disk in 720K or 1.2M drive
   475                              <1> ;	DL = drive number (0 or 1)
   476                              <1> ; Output:
   477                              <1> ;	CF clear if successful
   478                              <1> ;		AH = 00h - successful completion
   479                              <1> ;	CF set on error
   480                              <1> ;		AH = 01h - invalid drive number
   481                              <1> ;		AH = 06h - disk changed
   482                              <1> ;		AH = 80h - timeout / device not ready
   483                              <1> ;-------------------------------------------------------------------------
   484                              <1> int_13_fn17:
   485 00001516 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; get original AL value to CL
   486 00001519 80F900              <1> 	cmp	cl,0			; validate parameters
   487 0000151C 744F                <1> 	je	.invalid_parameters
   488 0000151E 80F904              <1> 	cmp	cl,4
   489 00001521 774A                <1> 	ja	.invalid_parameters
   490 00001523 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
   491 00001526 7506                <1> 	jne	.not_360in360
   492 00001528 B400                <1> 	mov	ah,0			; no error
   493 0000152A B093                <1> 	mov	al,fdc_m_360in360	; 360K disk in 360K drive
   494 0000152C EB30                <1> 	jmp	.exit_check_error
   495                              <1> 
   496                              <1> .not_360in360:
   497 0000152E E8AC01              <1> 	call	fdc_motor_on
   498 00001531 E84E02              <1> 	call	fdc_disk_change		; check if disk has been changed
   499 00001534 80FC06              <1> 	cmp	ah,fdc_e_changed
   500 00001537 7611                <1> 	jbe	.set_type		; disk changed (no errors other than
   501                              <1> 					; "disk changed" from fdc_disk_change)
   502 00001539 80FC80              <1> 	cmp	ah,fdc_e_timeout
   503 0000153C 750C                <1> 	jne	.set_type		; floppy disk is installed
   504 0000153E E8C204              <1> 	call	get_media_state		; BL = media state
   505 00001541 80FB97              <1> 	cmp	bl,fdc_m_720		; 250 Kbps and not 5.25?
   506 00001544 7418                <1> 	je	.exit_check_error
   507 00001546 B061                <1> 	mov	al,fdc_m_try_360in1200	; 300 Kpbs, try 360 in 1.2M
   508 00001548 EB14                <1> 	jmp	.exit_check_error
   509                              <1> 
   510                              <1> .set_type:
   511 0000154A 80F904              <1> 	cmp	cl,4			; 720K in 720K?
   512 0000154D 7504                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
   513 0000154F B097                <1> 	mov	al,fdc_m_720
   514 00001551 EB0B                <1> 	jmp	.exit_check_error
   515                              <1> 
   516                              <1> .check_360in1200:
   517 00001553 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
   518 00001556 7504                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
   519 00001558 B074                <1> 	mov	al,fdc_m_360in1200
   520 0000155A EB02                <1> 	jmp	.exit_check_error
   521                              <1> 
   522                              <1> .set_1200in1200:
   523 0000155C B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M
   524                              <1> 
   525                              <1> .exit_check_error:
   526 0000155E E8AC04              <1> 	call	set_media_state		; set media state to value in AL
   527 00001561 88264100            <1> 	mov	byte [fdc_last_error],ah
   528 00001565 08E4                <1> 	or	ah,ah
   529 00001567 7401                <1> 	jz	.exit			; jump if no error
   530 00001569 F9                  <1> 	stc				; indicate error
   531                              <1> 
   532                              <1> .exit:
   533 0000156A E96547              <1> 	jmp	int_13_upd_exit
   534                              <1> 
   535                              <1> .invalid_parameters:
   536 0000156D B401                <1> 	mov	ah,fdc_e_invalid
   537 0000156F EBF9                <1> 	jmp	.exit
   538                              <1> 
   539                              <1> ;=========================================================================
   540                              <1> ; int_13_fn18 - Set media type for format
   541                              <1> ; Input:
   542                              <1> ;	AH = 18h
   543                              <1> ;	DL = drive number (0 or 1)
   544                              <1> ;	CH = number of cylinders - 1
   545                              <1> ;	CL = sectors per track
   546                              <1> ; Output:
   547                              <1> ;	CF = clear if successful
   548                              <1> ;		AH = 00h - requested format is supported
   549                              <1> ;		ES:DI -> diskette parameter table
   550                              <1> ;	CF = set on error
   551                              <1> ;		AH = 01h - invalid drive number specified
   552                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
   553                              <1> ;-------------------------------------------------------------------------
   554                              <1> int_13_fn18:
   555 00001571 3C01                <1> 	cmp	al,type_360		; 360K drive?
   556 00001573 750E                <1> 	jne	.try_drive_1200
   557 00001575 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
   558 00001579 7573                <1> 	jnz	.unsupported_format
   559 0000157B B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
   560 0000157D 8D3E[6F5F]          <1> 	lea	di,[media_360_in_360]
   561 00001581 EB54                <1> 	jmp	.set_media
   562                              <1> 
   563                              <1> .try_drive_1200:
   564 00001583 3C02                <1> 	cmp	al,type_1200		; 1.2M drive?
   565 00001585 751C                <1> 	jne	.try_drive_2880
   566 00001587 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
   567 0000158B 7508                <1> 	jne	.try_media_360_in_1200
   568 0000158D B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
   569 0000158F 8D3E[7C5F]          <1> 	lea	di,[media_1200]		; 1.2M
   570 00001593 EB42                <1> 	jmp	.set_media
   571                              <1> 
   572                              <1> .try_media_360_in_1200:
   573 00001595 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
   574 00001599 7553                <1> 	jne	.unsupported_format
   575 0000159B B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
   576 0000159D 8D3E[A35F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
   577 000015A1 EB34                <1> 	jmp	.set_media
   578                              <1> 
   579                              <1> .try_drive_2880:
   580 000015A3 3C06                <1> 	cmp	al,type_2880		; 2.88M drive?
   581 000015A5 750E                <1> 	jne	.try_drive_1440
   582 000015A7 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
   583 000015AB 750C                <1> 	jne	.try_media_1440
   584 000015AD B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
   585 000015AF 8D3E[B05F]          <1> 	lea	di,[media_2880]
   586 000015B3 EB22                <1> 	jmp	.set_media
   587                              <1> 
   588                              <1> .try_drive_1440:
   589 000015B5 3C04                <1> 	cmp	al,type_1440		; 1.44M drive?
   590 000015B7 750E                <1> 	jne	.try_drive_720
   591                              <1> 
   592                              <1> .try_media_1440:
   593 000015B9 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
   594 000015BD 750C                <1> 	jne	.try_media_720
   595 000015BF B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
   596 000015C1 8D3E[965F]          <1> 	lea	di,[media_1440]
   597 000015C5 EB10                <1> 	jmp	.set_media
   598                              <1> 
   599                              <1> .try_drive_720:
   600 000015C7 3C03                <1> 	cmp	al,type_720		; 720K drive?
   601 000015C9 7523                <1> 	jne	.unsupported_format	; should never happen...
   602                              <1> 
   603                              <1> .try_media_720:	
   604 000015CB 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
   605 000015CF 751D                <1> 	jne	.unsupported_format
   606 000015D1 B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
   607 000015D3 8D3E[895F]          <1> 	lea	di,[media_720]		; 720K
   608                              <1> 
   609                              <1> .set_media:
   610 000015D7 E83304              <1> 	call	set_media_state		; set drive media state (in AL)
   611 000015DA E8FE03              <1> 	call	fdc_set_rate		; transfer rate in AL (bits 7-6)
   612 000015DD 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
   613 000015E0 8CC9                <1> 	mov	cx,cs
   614 000015E2 8EC1                <1> 	mov	es,cx			; return parameters table - segment
   615 000015E4 C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
   616 000015E9 30E4                <1> 	xor	ah,ah
   617 000015EB E9E446              <1> 	jmp	int_13_upd_exit
   618                              <1> 
   619                              <1> .unsupported_format:
   620 000015EE B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
   621 000015F0 F9                  <1> 	stc
   622 000015F1 E9DE46              <1> 	jmp	int_13_upd_exit
   623                              <1> 
   624                              <1> ;=========================================================================
   625                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
   626                              <1> ; Input:
   627                              <1> ;	[BP+int_13_dl] = drive number (0 or 1)
   628                              <1> ; Output:
   629                              <1> ;	CF clear if successful
   630                              <1> ;		AH = 00h - successful completion
   631                              <1> ;	CF set on error
   632                              <1> ;		AH = 20h - controller failure
   633                              <1> ;		AH = 20h - timeout
   634                              <1> ;	AH trashed
   635                              <1> ;-------------------------------------------------------------------------
   636                              <1> fdc_recalibrate:
   637 000015F4 56                  <1> 	push	si
   638 000015F5 51                  <1> 	push	cx
   639 000015F6 52                  <1> 	push	dx
   640 000015F7 B007                <1> 	mov	al,07h			; FDC Recalibrate command
   641 000015F9 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; drive number - 2nd byte of command
   642 000015FC B102                <1> 	mov	cl,2			; 2 bytes command
   643 000015FE 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   644 00001603 E8D101              <1> 	call	fdc_send_cmd
   645 00001606 7215                <1> 	jc	recal_end		; failure
   646                              <1> 	;call	fdc_wait_irq		; wait for IRQ
   647 00001608 E8D604              <1>     call    chk_stat_2              ; Wait for Seek End in ST0 bit 5, already has Sense code in it
   648 0000160B 7210                <1> 	jc	recal_end		; timeout waiting for interrupt
   649                              <1> 	;mov	al,08h			; FDC Sense Interrupt Status command
   650                              <1> 	;mov	cl,1			; 1 byte command
   651                              <1> 	;call	fdc_send_cmd
   652                              <1> 	;jc	recal_end		; failure
   653                              <1> 	;mov	cx,2			; 2 bytes result
   654                              <1> 	;call	fdc_get_result		; store result
   655                              <1> 	;jc	recal_end		; failure
   656                              <1> 	;mov	bx,fdc_ctrl_status
   657                              <1> 	;mov	ah,fdc_e_seek
   658                              <1> 	;mov	dl,byte [bx]			; ST0
   659                              <1> 	;and	dl,60h
   660                              <1> 	;cmp	dl,60h			; abnormal termination + seek end
   661                              <1> 	;stc				; indicate error
   662                              <1> 	;je	recal_end		; failure
   663                              <1> 
   664 0000160D B500                <1> 	mov	ch,0
   665 0000160F E81304              <1> 	call	set_cylinder		; set current cylinder to 0
   666 00001612 E82A04              <1> 	call	set_drive_calibrated	; set drive calibrated in data area
   667 00001615 B94300              <1> 	mov	cx,43h
   668 00001618 E8F7FB              <1> 	call	delay_15us		; 1 ms delay
   669 0000161B 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
   670                              <1> 
   671                              <1> recal_end:
   672 0000161D 88264100            <1> 	mov	byte [fdc_last_error],ah
   673 00001621 5A                  <1> 	pop	dx
   674 00001622 59                  <1> 	pop	cx
   675 00001623 5E                  <1> 	pop	si
   676 00001624 C3                  <1> 	ret
   677                              <1> 
   678                              <1> ;=========================================================================
   679                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
   680                              <1> ; Input:
   681                              <1> ;	DL = drive number
   682                              <1> ;	DH = head number
   683                              <1> ;	CH = cylinder
   684                              <1> ; Output:
   685                              <1> ;	CF clear if successful
   686                              <1> ;		AH = 00h - successful completion
   687                              <1> ;	CF set on error
   688                              <1> ;		AH = 20h - controller failure
   689                              <1> ;		AH = 40h - seek failed
   690                              <1> ;		AH = 80h - timeout / device not ready
   691                              <1> ;-------------------------------------------------------------------------
   692                              <1> fdc_seek:
   693 00001625 53                  <1> 	push	bx
   694 00001626 51                  <1> 	push	cx
   695 00001627 52                  <1> 	push	dx
   696 00001628 E80604              <1> 	call	check_drive_calibrated
   697 0000162B 720D                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
   698 0000162D E8C4FF              <1> 	call	fdc_recalibrate
   699 00001630 7308                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
   700 00001632 E8BFFF              <1> 	call	fdc_recalibrate		; try recalibrating again
   701 00001635 7303E98100          <1> 	jc	.exit			; no luck...
   702                              <1> 
   703                              <1> .skip_recalibrate:
   704 0000163A E8C603              <1> 	call	get_media_state		; BL = media state
   705 0000163D F6C320              <1> 	test	bl,fdc_m_double_step 	; check double stepping bit
   706 00001640 7402                <1> 	jz	.no_double_stepping
   707 00001642 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
   708                              <1> 
   709                              <1> .no_double_stepping:
   710 00001644 E8D203              <1> 	call	check_cylinder		; already at the right cylinder?
   711 00001647 750B                <1> 	jnz	.do_seek		; jump if seek is required
   712 00001649 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
   713 0000164E 7404                <1> 	je	.do_seek		; jump if it was a seek error
   714 00001650 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
   715 00001652 EB67                <1> 	jmp	.exit
   716                              <1> 
   717                              <1> .do_seek:
   718 00001654 B0D5                <1> 	mov	al, 0xD5		; Seek DL/CH/DH Will output Track/Cylinder to Port 80 with D5
   719 00001656 E680                <1> 	out	post_reg,al
   720 00001658 88E8                <1> 	mov	al,ch			; cylinder
   721 0000165A E680                <1> 	out	post_reg,al
   722 0000165C 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
   723 0000165E B00F                <1> 	mov	al,0Fh			; FDC Seek command
   724 00001660 88F4                <1> 	mov	ah,dh			; head
   725 00001662 D0E4                <1> 	shl	ah,1			; move head to bit 2
   726 00001664 D0E4                <1> 	shl	ah,1
   727 00001666 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; seek - byte 1 (head / drive)
   728 00001669 B103                <1> 	mov	cl,3			; 3 bytes command
   729 0000166B 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   730 00001670 E86401              <1> 	call	fdc_send_cmd
   731 00001673 7242                <1> 	jc	.set_result		; seek error
   732                              <1> ;	call	fdc_wait_irq		; wait for IRQ
   733 00001675 E86904              <1>     call    chk_stat_2              ; Wait for Seek End in ST0 bit 5
   734 00001678 723D                <1> 	jc	.set_result		; timeout waiting for interrupt
   735                              <1> 
   736 0000167A B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   737 0000167C B101                <1> 	mov	cl,1			; 1 byte command
   738 0000167E E85601              <1> 	call	fdc_send_cmd
   739 00001681 7234                <1> 	jc	.set_result		; failure
   740 00001683 B102                <1> 	mov	cl,2
   741 00001685 53                  <1> 	push	bx
   742 00001686 E8C001              <1> 	call	fdc_get_result		; read result bytes
   743 00001689 5B                  <1> 	pop	bx
   744 0000168A 722B                <1> 	jc	.set_result		; error
   745 0000168C B440                <1> 	mov	ah,fdc_e_seek
   746 0000168E A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
   747 00001691 2460                <1> 	and	al,60h
   748 00001693 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
   749 00001695 F9                  <1> 	stc
   750 00001696 741F                <1> 	je	.set_result		; seek error
   751 00001698 E88A03              <1> 	call	set_cylinder		; save new cylinder number
   752                              <1> 
   753 0000169B 1E                  <1> 	push	ds
   754 0000169C 31F6                <1> 	xor	si,si
   755 0000169E 8EDE                <1> 	mov	ds,si
   756 000016A0 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   757 000016A4 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
   758 000016A7 1F                  <1> 	pop	ds
   759                              <1> 
   760 000016A8 08C0                <1> 	or	al,al			; head settle time is zero?!
   761 000016AA 7413                <1> 	jz	.get_settle_time
   762                              <1> 
   763 000016AC B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
   764 000016AE F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
   765 000016B0 89C1                <1> 	mov	cx,ax
   766                              <1> 
   767                              <1> .wait:
   768 000016B2 E85DFB              <1> 	call	delay_15us
   769                              <1> 
   770                              <1> .wait_end:
   771 000016B5 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
   772                              <1> 
   773                              <1> .set_result:
   774 000016B7 88264100            <1> 	mov	byte [fdc_last_error],ah
   775                              <1> 
   776                              <1> .exit:
   777 000016BB 5A                  <1> 	pop	dx
   778 000016BC 59                  <1> 	pop	cx
   779 000016BD 5B                  <1> 	pop	bx
   780 000016BE C3                  <1> 	ret
   781                              <1> 
   782                              <1> .get_settle_time:
   783 000016BF F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
   784 000016C4 74EF                <1> 	jz	.wait_end		; jump if read / verify - no wait
   785                              <1> 
   786 000016C6 E83A03              <1> 	call	get_media_state	
   787 000016C9 88DC                <1> 	mov	ah,bl			; AH = media state
   788 000016CB 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
   789 000016CE B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
   790 000016D1 74DF                <1> 	jz	.wait			; jump if 360K, media not established
   791 000016D3 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
   792 000016D6 74DA                <1> 	je	.wait			; jump if 360K, media established
   793 000016D8 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
   794 000016DB EBD5                <1> 	jmp	.wait
   795                              <1> 
   796                              <1> ;=========================================================================
   797                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
   798                              <1> ; Input:
   799                              <1> ;	DL = drive number (0 or 1) -- FIXME: Does it receive DL?
   800                              <1> ; Output:
   801                              <1> ;	none
   802                              <1> ;-------------------------------------------------------------------------
   803                              <1> fdc_motor_on:
   804 000016DD 50                  <1> 	push	ax
   805 000016DE 51                  <1> 	push	cx
   806 000016DF 52                  <1> 	push	dx
   807 000016E0 FA                  <1> 	cli				; entering critical section
   808 000016E1 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
   809 000016E6 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL = drive number
   810 000016E9 88D1                <1> 	mov	cl,dl			; CL = drive number
   811 000016EB FEC1                <1> 	inc	cl			; CL = drive number + 1
   812 000016ED A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
   813 000016F0 88C6                <1> 	mov	dh,al			; keep a copy in motor state in DH
   814 000016F2 24CF                <1> 	and	al,0CFh			; clear drive select bits (5-4)
   815                              <1> 
   816 000016F4 D0E2                <1> 	shl	dl,1			; shift drive number to bits (5-4)
   817 000016F6 D0E2                <1> 	shl	dl,1
   818 000016F8 D0E2                <1> 	shl	dl,1
   819 000016FA D0E2                <1> 	shl	dl,1
   820 000016FC 08D0                <1> 	or	al,dl			; select drive
   821 000016FE D2EE                <1> 	shr	dh,cl			; set CF if motor for is on
   822 00001700 724A                <1> 	jc	.already_on
   823 00001702 B201                <1> 	mov	dl,1
   824 00001704 FEC9                <1> 	dec	cl
   825 00001706 D2E2                <1> 	shl	dl,cl
   826 00001708 08D0                <1> 	or	al,dl			; indicate that motor is on
   827 0000170A A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state in data area
   828 0000170D FB                  <1> 	sti
   829 0000170E 0C40                <1> 	or	al,40h			; no reset,  note set_fdc_dor rotates right 4 bits 40h=04h!
   830 00001710 E8E102              <1> 	call	set_fdc_dor
   831 00001713 B8FD90              <1> 	mov	ax,90FDh
   832 00001716 CD15                <1> 	int	15h			; call OS hook
   833 00001718 722E                <1> 	jc	.exit
   834 0000171A 1E                  <1> 	push	ds
   835 0000171B 56                  <1> 	push	si
   836 0000171C 31F6                <1> 	xor	si,si
   837 0000171E 8EDE                <1> 	mov	ds,si
   838 00001720 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   839 00001724 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
   840 00001727 5E                  <1> 	pop	si
   841 00001728 1F                  <1> 	pop	ds
   842                              <1> 
   843 00001729 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
   844 0000172E 7408                <1> 	jz	.read_verify		; jump if not write operation
   845 00001730 3C08                <1> 	cmp	al,8
   846 00001732 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
   847 00001734 B008                <1> 	mov	al,8			; wait at least 1 second for write
   848 00001736 EB06                <1> 	jmp	.wait_loop
   849                              <1> 
   850                              <1> .read_verify:
   851 00001738 3C05                <1> 	cmp	al,5
   852 0000173A 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
   853 0000173C B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
   854                              <1> 
   855                              <1> .wait_loop:
   856 0000173E B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
   857 00001741 E8CEFA              <1> 	call	delay_15us		; wait 125 ms
   858 00001744 FEC8                <1> 	dec	al
   859 00001746 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
   860                              <1> 
   861                              <1> .exit:
   862 00001748 5A                  <1> 	pop	dx
   863 00001749 59                  <1> 	pop	cx
   864 0000174A 58                  <1> 	pop	ax
   865 0000174B C3                  <1> 	ret
   866                              <1> 
   867                              <1> .already_on:
   868 0000174C A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state (AL) in data area
   869 0000174F FB                  <1> 	sti
   870 00001750 0C40                <1> 	or	al,40h			; no reset,  note set_fdc_dor rotates right 4 bits 40h=04h!
   871 00001752 E89F02              <1> 	call	set_fdc_dor
   872 00001755 EBF1                <1> 	jmp	.exit
   873                              <1> 
   874                              <1> ;=========================================================================
   875                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
   876                              <1> ; Input:
   877                              <1> ;	CH = cylinder
   878                              <1> ;	DH = head
   879                              <1> ; Output:
   880                              <1> ;	BL = next sector to be transferred
   881                              <1> ;-------------------------------------------------------------------------	
   882                              <1> fdc_end_io:
   883 00001757 50                  <1> 	push	ax
   884 00001758 1E                  <1> 	push	ds
   885 00001759 31DB                <1> 	xor	bx,bx
   886 0000175B 8EDB                <1> 	mov	ds,bx
   887 0000175D C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
   888 00001761 8A6702              <1> 	mov	ah,byte [bx+2]		; motor timeout (ticks)
   889 00001764 8A4704              <1> 	mov	al,byte [bx+4]		; sectors per track
   890 00001767 FEC0                <1> 	inc	al
   891 00001769 1F                  <1> 	pop	ds
   892 0000176A BB4200              <1> 	mov	bx,fdc_ctrl_status
   893 0000176D 3A6F03              <1> 	cmp	ch,byte [bx+3]		; same result cylinder?
   894 00001770 7508                <1> 	jne	.exit
   895 00001772 3A7704              <1> 	cmp	dh,byte [bx+4]		; same result head?
   896 00001775 7503                <1> 	jne	.exit
   897 00001777 8A4705              <1> 	mov	al,byte [bx+5]		; result sector number
   898                              <1> .exit:
   899 0000177A 88264000            <1> 	mov	byte [fdc_motor_tout],ah  ; motor timeout
   900 0000177E 88C3                <1> 	mov	bl,al			; next sector to be transferred
   901 00001780 58                  <1> 	pop	ax
   902 00001781 C3                  <1> 	ret
   903                              <1> 
   904                              <1> ;========================================================================
   905                              <1> ; fdc_disk_change - Read disk change line, reset it if active
   906                              <1> ; Input:
   907                              <1> ;	AL = drive type
   908                              <1> ; Output:
   909                              <1> ;	CF clear if disk not changed
   910                              <1> ;		AH = 00h - disk not changed
   911                              <1> ;	CF set if disk changed or on error
   912                              <1> ;		AH = 06h - disk changed
   913                              <1> ;		AH = error code
   914                              <1> ;		AL - trashed
   915                              <1> ; Note:
   916                              <1> ;	Motor needs to be turned on before calling this function
   917                              <1> ;------------------------------------------------------------------------
   918                              <1> fdc_disk_change:
   919 00001782 53                  <1> 	push	bx
   920 00001783 51                  <1> 	push	cx
   921 00001784 B400                <1> 	mov	ah,0
   922 00001786 3C01                <1> 	cmp	al,type_360
   923 00001788 7447                <1> 	je	.exit			; jump if 360K drive (no change line)
   924 0000178A 3C03                <1> 	cmp	al,type_720
   925 0000178C 7443                <1> 	je	.exit			; jump if 720K drive (no change line)
   926                              <1> 
   927 0000178E E87202              <1> 	call	get_media_state
   928 00001791 88D8                <1> 	mov	al,bl			; AL = drive media state
   929 00001793 2407                <1> 	and	al,fdc_m_state_bits
   930 00001795 743A                <1> 	jz	.exit			; jump if 360K drive (no change line)
   931 00001797 3C03                <1> 	cmp	al,3
   932 00001799 7436                <1> 	je	.exit			; jump if 360K drive (no change line)
   933 0000179B BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
   934 0000179E EC                  <1> 	in	al,dx			; read disk change line
   935                              <1>   ; WD37C65C in DIP form does not support disk change, fake no change!
   936 0000179F B07F                <1>   mov al, 0x7f
   937 000017A1 D0E0                <1> 	shl	al,1
   938 000017A3 732C                <1> 	jnc	.exit			; no disk change
   939 000017A5 88D8                <1> 	mov	al,bl			; AL = drive media state
   940 000017A7 24EF                <1> 	and	al,~fdc_m_established	; media not detected
   941 000017A9 E86102              <1> 	call	set_media_state
   942 000017AC E805FC              <1> 	call	fdc_init		; full initialization
   943 000017AF 7220                <1> 	jc	.exit
   944 000017B1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
   945 000017B4 B501                <1> 	mov	ch,1
   946 000017B6 E86CFE              <1> 	call	fdc_seek		; seek to cylinder 1
   947 000017B9 7216                <1> 	jc	.exit
   948 000017BB B500                <1> 	mov	ch,0
   949 000017BD E865FE              <1> 	call	fdc_seek		; seek to cylinder 0
   950 000017C0 720F                <1> 	jc	.exit
   951 000017C2 B406                <1> 	mov	ah,fdc_e_changed
   952 000017C4 BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
   953 000017C7 EC                  <1> 	in	al,dx			; read disk change line
   954                              <1>   ; WD37C65C in DIP form does not support disk change, fake no change!
   955 000017C8 B07F                <1>   mov al, 0x7f
   956 000017CA D0E0                <1> 	shl	al,1
   957 000017CC 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
   958 000017CE B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
   959                              <1> 
   960                              <1> .changed_or_error:
   961 000017D0 F9                  <1> 	stc
   962                              <1> 
   963                              <1> .exit:
   964 000017D1 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
   965 000017D4 59                  <1> 	pop	cx
   966 000017D5 5B                  <1> 	pop	bx
   967 000017D6 C3                  <1> 	ret
   968                              <1> 
   969                              <1> ;=========================================================================
   970                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
   971                              <1> ; Input:
   972                              <1> ;	AL = DMA mode byte
   973                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
   974                              <1> ;		46h - read   (single mode, addr increment, write, channel 2) These are from RAM perspective, read disk via IO, write RAM via DMA
   975                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2) These are from RAM perspective, write disk via IO, read RAM via DMA
   976                              <1> ;	CX = byte count (minus 1)
   977                              <1> ;	ES:BX -> buffer address for DMA operation (BX is from [BP+int_13_bx])
   978                              <1> ; Output:
   979                              <1> ;	CF clear on success
   980                              <1> ;	CF set if error
   981                              <1> ;		AH = 08h - DMA overrun
   982                              <1> ;	AX,BX trashed
   983                              <1> ; Note:
   984                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
   985                              <1> ;-------------------------------------------------------------------------
   986                              <1> ; fdc_configure_dma:
   987                              <1> 	; push	dx
   988                              <1> 	; mov	bx,word [bp+int_13_bx]	; get BX from the stack
   989                              <1> 	; mov	dx,es			; user's buffer segment
   990                              <1> 	; rol	dx,1
   991                              <1> 	; rol	dx,1
   992                              <1> 	; rol	dx,1
   993                              <1> 	; rol	dx,1
   994                              <1> 	; mov	ah,dl			; calculate DMA page number
   995                              <1> 	; and	ah,0Fh			; AH = page number: bits 19 - 16 of ES
   996                              <1> 	; and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
   997                              <1> 	; add	dx,bx			; add user's buffer offset
   998                              <1> 	; adc	ah,0			; increment page number on overflow
   999                              <1> 
  1000                              <1> 	; mov	bx,dx			; check if crossing DMA page boundary:
  1001                              <1> 	; add	bx,cx			;   add DMA buffer address to byte count
  1002                              <1> 	; jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  1003                              <1> 
  1004                              <1> 	; cli
  1005                              <1>         ; push ax
  1006                              <1> 
  1007                              <1> 	; mov	al,6
  1008                              <1> 	; out	dmac_mask_reg,al	; disable DMA channel 2 via mask
  1009                              <1>         ; pop ax
  1010                              <1> 	; jmp	$+2
  1011                              <1> 	; jmp	$+2
  1012                              <1> 	; out	dmac_mode_reg,al	; send DMA mode byte
  1013                              <1> 	; jmp	$+2
  1014                              <1> 	; jmp	$+2
  1015                              <1>         ; ; The Intersil chip still seems to reverse the MSB and LSB of the DMA address despite everything attempted
  1016                              <1>         ; ; If we read from the same port then it will reverse the order MSB first then LSB, see if this works
  1017                              <1>         ; ; 1 Put read in as last commands to see if this leaves the DMAC in the correct order!
  1018                              <1>         ; ; 2 Just change Flip Flip write to Read
  1019                              <1>         ; ; 3 Change Flip Flip write to Read AND reverse MSB and LSB writes
  1020                              <1>         ; ; Following DMATEST4 nothing much seems to change the behavior with curent physical design 
  1021                              <1>         ; ; BUT re-reading registers and repeating appears to work eventually!
  1022                              <1> 
  1023                              <1> ; .retry_dma:                             ; When we read registers after setting and not right will return here!
  1024                              <1> 
  1025                              <1> 	; out	dmac_ff_reg,al		; clear first/last flip-flop
  1026                              <1> 	; jmp	$+2
  1027                              <1> 	; jmp	$+2
  1028                              <1> 	; mov	al,cl
  1029                              <1> 	; out	dmac_ch2_count_reg,al	; send word count - low byte
  1030                              <1> 	; jmp	$+2
  1031                              <1> 	; jmp	$+2
  1032                              <1> 	; mov	al,ch
  1033                              <1> 	; out	dmac_ch2_count_reg,al	; send word count - high byte
  1034                              <1> 	; jmp	$+2
  1035                              <1> 	; jmp	$+2
  1036                              <1> 
  1037                              <1>         ; ; Read count back. If different jump to .retry_dma
  1038                              <1>         
  1039                              <1> 	; in	al,dmac_ch2_count_reg	; read count - low byte
  1040                              <1>         ; cmp     al, cl
  1041                              <1>         ; jne      .retry_dma
  1042                              <1> 	; jmp	$+2
  1043                              <1> 	; jmp	$+2
  1044                              <1> 	; in	al,dmac_ch2_count_reg	; read count - high byte
  1045                              <1>         ; cmp     al, ch
  1046                              <1>         ; jne      .retry_dma
  1047                              <1> 
  1048                              <1> ; .setdmaaddress:
  1049                              <1> 	; out	dmac_ff_reg,al		; clear first/last flip-flop
  1050                              <1> 	; jmp	$+2
  1051                              <1> 	; jmp	$+2
  1052                              <1> 	; mov	al,dl
  1053                              <1> 	; out	dmac_ch2_addr_reg,al	; send base address - low byte
  1054                              <1> 	; jmp	$+2
  1055                              <1> 	; jmp	$+2
  1056                              <1> 	; mov	al,dh
  1057                              <1> 	; out	dmac_ch2_addr_reg,al	; send base address - high byte
  1058                              <1> 	; jmp	$+2
  1059                              <1> 	; jmp	$+2
  1060                              <1> 
  1061                              <1>         ; ; Read address back. If different jump to .retry_dma
  1062                              <1>         
  1063                              <1> 	; in	al,dmac_ch2_addr_reg	; read base address - low byte
  1064                              <1>         ; cmp     al, dl
  1065                              <1>         ; jne      .retry_dma
  1066                              <1> 	; jmp	$+2
  1067                              <1> 	; jmp	$+2
  1068                              <1> 	; in	al,dmac_ch2_addr_reg	; read base address - high byte
  1069                              <1>         ; cmp     al, dh
  1070                              <1>         ; jne      .retry_dma
  1071                              <1> 
  1072                              <1> 	; mov	al,ah
  1073                              <1> 	; out	dmapage_ch2_reg,al	; channel 2 page register
  1074                              <1> 	; jmp	$+2
  1075                              <1> 	; jmp	$+2
  1076                              <1> 	; mov	al,2
  1077                              <1> 	; out	dmac_mask_reg,al	; enable DMA channel 2
  1078                              <1> 
  1079                              <1> 	; jmp	$+2
  1080                              <1> 	; jmp	$+2
  1081                              <1>         ; ; 1 Put read in as last commands to see if this leaves the DMAC in the correct order!
  1082                              <1> ; ;        in 	al, dmac_ff_reg         ; This sets the address register order to MSB then LSB when writing and reading - perhaps bug in chip when generating DMA addresses
  1083                              <1> ; ;       xor     al,al
  1084                              <1> ; ; 	out	dmac_ff_reg,al		; clear first/last flip-flop - leave in cleared state as seems to get MSB and LSB confused
  1085                              <1> ; ;	jmp	$+2
  1086                              <1> ; ;	jmp	$+2
  1087                              <1>   
  1088                              <1> 	; sti
  1089                              <1> 	; clc				; CF = 0 - no error 
  1090                              <1> 
  1091                              <1> ; .exit:
  1092                              <1> 	; pop	dx
  1093                              <1> 	; ret
  1094                              <1> 
  1095                              <1> ; .dma_boundary:				; Note: CF is already set
  1096                              <1> 	; mov	ah,fdc_e_boundary
  1097                              <1> 	; jmp	.exit
  1098                              <1> 
  1099                              <1> ;=========================================================================
  1100                              <1> ; fdc_send_cmd - Send a command to FDC
  1101                              <1> ; Input:
  1102                              <1> ;	AL = 1st byte of the command
  1103                              <1> ;	AH = 2nd byte of the command
  1104                              <1> ;	SI = 3rd and 4th bytes of the command
  1105                              <1> ;	DI = 5th and 6th bytes of the command
  1106                              <1> ;	BL = 7th byte of the command
  1107                              <1> ;	BH = 8th byte of the command
  1108                              <1> ;	CH = 9th byte of the command
  1109                              <1> ;	CL = command length (number of bytes)
  1110                              <1> ; Output:
  1111                              <1> ;	CF clear if successful
  1112                              <1> ;		AH = 00h - successful completion
  1113                              <1> ;	CF set on error
  1114                              <1> ;		AH = 20h - controller failure
  1115                              <1> ;		AH = 80h - timeout / device not ready
  1116                              <1> ;	AX trashed
  1117                              <1> ;-------------------------------------------------------------------------
  1118                              <1> fdc_send_cmd:
  1119 000017D7 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  1120 000017DA FEC9                <1> 	dec	cl
  1121 000017DC 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1122 000017DE 88E0                <1> 	mov	al,ah
  1123 000017E0 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  1124 000017E3 FEC9                <1> 	dec	cl
  1125 000017E5 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1126 000017E7 89F0                <1> 	mov	ax,si
  1127 000017E9 E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  1128 000017EC FEC9                <1> 	dec	cl
  1129 000017EE 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1130 000017F0 88E0                <1> 	mov	al,ah
  1131 000017F2 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  1132 000017F5 FEC9                <1> 	dec	cl
  1133 000017F7 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1134 000017F9 89F8                <1> 	mov	ax,di
  1135 000017FB E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  1136 000017FE FEC9                <1> 	dec	cl
  1137 00001800 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1138 00001802 88E0                <1> 	mov	al,ah
  1139 00001804 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  1140 00001807 FEC9                <1> 	dec	cl
  1141 00001809 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1142 0000180B 88D8                <1> 	mov	al,bl
  1143 0000180D E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  1144 00001810 FEC9                <1> 	dec	cl
  1145 00001812 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1146 00001814 88F8                <1> 	mov	al,bh
  1147 00001816 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  1148 00001819 FEC9                <1> 	dec	cl
  1149 0000181B 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1150 0000181D 88E8                <1> 	mov	al,ch
  1151 0000181F E80100              <1> 	call	fdc_write		; send CH (9th byte)
  1152                              <1> 
  1153                              <1> .send_cmd_exit:
  1154 00001822 C3                  <1> 	ret
  1155                              <1> 
  1156                              <1> ;=========================================================================
  1157                              <1> ; fdc_write - Send byte to FDC
  1158                              <1> ; Input:
  1159                              <1> ;	AL = byte to send
  1160                              <1> ; Output:
  1161                              <1> ;	CF clear if successful
  1162                              <1> ;	CF set if timeout
  1163                              <1> ;		AH = 80h - timeout / device not ready
  1164                              <1> ;-------------------------------------------------------------------------
  1165                              <1> fdc_write:
  1166 00001823 51                  <1> 	push	cx
  1167 00001824 52                  <1> 	push	dx
  1168 00001825 50                  <1> 	push	ax
  1169 00001826 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1170 00001829 31C9                <1> 	xor	cx,cx			; busy wait counter
  1171                              <1> 
  1172                              <1> .wait_ready:
  1173 0000182B EC                  <1> 	in	al,dx			; read fdc_status_reg
  1174 0000182C A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1175 0000182E 7508                <1> 	jnz	 .fdc_ready
  1176 00001830 E2F9                <1> 	loop	.wait_ready         ; retry until timeout
  1177 00001832 58                  <1> 	pop	ax
  1178 00001833 B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1179 00001835 F9                  <1> 	stc				; indicate error
  1180 00001836 EB08                <1> 	jmp	.exit
  1181                              <1> 
  1182                              <1> .fdc_ready:
  1183 00001838 A860                <1> 	test	al,fdc_stat_dir|fdc_stat_dma ; check that DIR and DMA flags are 0
  1184 0000183A 7507                <1> 	jnz	.failure		; FDC failure if they are set
  1185 0000183C 58                  <1> 	pop	ax
  1186 0000183D 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1187 0000183E EE                  <1> 	out	dx,al			; write byte
  1188 0000183F F8                  <1> 	clc				; no error
  1189                              <1> 
  1190                              <1> .exit:
  1191 00001840 5A                  <1> 	pop	dx
  1192 00001841 59                  <1> 	pop	cx
  1193 00001842 C3                  <1> 	ret
  1194                              <1> 
  1195                              <1> .failure:
  1196 00001843 58                  <1> 	pop	ax
  1197 00001844 B420                <1> 	mov	ah,fdc_e_failure	; FDC failure
  1198 00001846 F9                  <1> 	stc
  1199 00001847 EBF7                <1> 	jmp	.exit
  1200                              <1> 
  1201                              <1> ;=========================================================================
  1202                              <1> ; fdc_get_result - Read FDC result
  1203                              <1> ; Input:
  1204                              <1> ;	none
  1205                              <1> ; Output:
  1206                              <1> ;	CF clear if successful
  1207                              <1> ;		AH = 00h - operation successful
  1208                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  1209                              <1> ;	CF set on error
  1210                              <1> ;		AH = 20h - controller failure
  1211                              <1> ;		AH = 80h - timeout / device not ready
  1212                              <1> ;	AL,BX - trashed
  1213                              <1> ;-------------------------------------------------------------------------
  1214                              <1> fdc_get_result:
  1215 00001849 51                  <1> 	push	cx
  1216 0000184A 52                  <1> 	push	dx
  1217 0000184B BB4200              <1> 	mov	bx,fdc_ctrl_status
  1218 0000184E BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1219                              <1> 
  1220                              <1> .next_byte:
  1221 00001851 31C9                <1>         xor     cx,cx			; busy wait counter
  1222                              <1> 
  1223                              <1> .wait_ready:
  1224 00001853 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1225 00001854 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1226 00001856 7507                <1> 	jnz	.fdc_ready
  1227 00001858 E2F9                <1> 	loop	.wait_ready
  1228 0000185A B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1229 0000185C F9                  <1> 	stc				; indicate error
  1230 0000185D EB19                <1> 	jmp	.exit
  1231                              <1> 
  1232                              <1> .fdc_ready:
  1233 0000185F 2470                <1> 	and	al,fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  1234                              <1> ;	test	al,~fdc_stat_busy	; controller finished sending result?
  1235 00001861 A810                <1> 	test	al, fdc_stat_busy	; controller finished sending result? This was wrong when stat_busy = 0 then done
  1236                              <1> 	; stat_busy will be 0 when all results have been returned
  1237 00001863 7411                <1> 	je	.done
  1238 00001865 3C50                <1> 	cmp	al,fdc_stat_dir|fdc_stat_busy
  1239 00001867 7512                <1> 	jne	.failure		; invalid FDC status, indicate FDC failure
  1240 00001869 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes? 
  1241 0000186C 730D                <1> 	jnb	.failure		; controller error if so
  1242 0000186E 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1243 0000186F EC                  <1> 	in	al,dx
  1244 00001870 8807                <1> 	mov	byte [bx],al
  1245 00001872 43                  <1> 	inc	bx
  1246 00001873 4A                  <1> 	dec	dx			; DX = fdc_status_reg = fdc_data_reg - 1
  1247 00001874 EBDB                <1> 	jmp	.next_byte
  1248                              <1> 
  1249                              <1> .done:
  1250 00001876 30E4                <1> 	xor	ah,ah			; operation successful
  1251                              <1> 
  1252                              <1> .exit:
  1253 00001878 5A                  <1> 	pop	dx
  1254 00001879 59                  <1> 	pop	cx
  1255 0000187A C3                  <1> 	ret
  1256                              <1> 
  1257                              <1> .failure:
  1258 0000187B B420                <1> 	mov	ah,fdc_e_failure
  1259 0000187D F9                  <1> 	stc
  1260 0000187E EBF8                <1> 	jmp	.exit
  1261                              <1> 
  1262                              <1> ;=========================================================================
  1263                              <1> ; fdc_read - Read byte from FDC
  1264                              <1> ; Input:
  1265                              <1> ;	none
  1266                              <1> ; Output:
  1267                              <1> ;	CF clear if successful
  1268                              <1> ;		AL = byte read from FDC
  1269                              <1> ;		AH - unchanged
  1270                              <1> ;	CF set on error
  1271                              <1> ;		AH = 20h - controller failure
  1272                              <1> ;		AH = 80h - timeout / device not ready
  1273                              <1> ;-------------------------------------------------------------------------
  1274                              <1> fdc_read:
  1275 00001880 51                  <1> 	push	cx
  1276 00001881 52                  <1> 	push	dx
  1277 00001882 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1278 00001885 31C9                <1>         xor     cx,cx			; busy wait counter
  1279                              <1> 
  1280                              <1> .wait_ready:
  1281 00001887 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1282 00001888 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1283 0000188A 7507                <1> 	jnz	.fdc_ready
  1284 0000188C E2F9                <1> 	loop	.wait_ready
  1285 0000188E B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1286 00001890 F9                  <1> 	stc				; indicate error
  1287 00001891 EB08                <1> 	jmp	.exit
  1288                              <1> 
  1289                              <1> .fdc_ready:
  1290 00001893 EC                  <1> 	in	al,dx
  1291 00001894 A840                <1> 	test	al,fdc_stat_dir		; FDC is ready to send a byte? 
  1292 00001896 7406                <1> 	jz	.failure		; jump if not ready
  1293                              <1> ;	jmp	short $+2		; I/O delay
  1294                              <1> ;	jmp	short $+2
  1295 00001898 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1296 00001899 EC                  <1> 	in	al,dx			; read the byte
  1297 0000189A F8                  <1> 	clc				; no error
  1298                              <1> 
  1299                              <1> .exit:
  1300 0000189B 5A                  <1> 	pop	dx
  1301 0000189C 59                  <1> 	pop	cx
  1302 0000189D C3                  <1> 	ret
  1303                              <1> 
  1304                              <1> .failure:
  1305 0000189E B420                <1> 	mov	ah,fdc_e_failure
  1306 000018A0 F9                  <1> 	stc
  1307 000018A1 EBF8                <1> 	jmp	.exit
  1308                              <1> 
  1309                              <1> ;=========================================================================
  1310                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  1311                              <1> ; Input:
  1312                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  1313                              <1> ; Output:
  1314                              <1> ;	AH = error code
  1315                              <1> ;-------------------------------------------------------------------------
  1316                              <1> fdc_get_error:
  1317 000018A3 8B1E4200            <1> 	mov	bx,word [fdc_ctrl_status]
  1318 000018A7 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1 (Actually ST0 D7 & D6 = 0 Normal Termination)
  1319 000018AA B400                <1> 	mov	ah,fdc_e_success
  1320 000018AC 7433                <1> 	jz	.exit			; jump if successful completion
  1321 000018AE F6C340              <1> 	test	bl,40h			; abnormal termination? Equipment Check = 1
  1322 000018B1 B420                <1> 	mov	ah,fdc_e_failure
  1323 000018B3 742C                <1> 	jz	.exit
  1324 000018B5 F6C701              <1> 	test	bh,1			; address mark not found?
  1325 000018B8 B402                <1> 	mov	ah,fdc_e_address
  1326 000018BA 7525                <1> 	jnz	.exit
  1327 000018BC F6C702              <1> 	test	bh,2			; BH=ST1 disk write protected?
  1328 000018BF B403                <1> 	mov	ah,fdc_e_wprotect
  1329 000018C1 751E                <1> 	jnz	.exit
  1330 000018C3 F6C704              <1> 	test	bh,4			; sector not found?
  1331 000018C6 B404                <1> 	mov	ah,fdc_e_notfound
  1332 000018C8 7517                <1> 	jnz	.exit
  1333 000018CA F6C710              <1> 	test	bh,10H			; DMA overrun?
  1334 000018CD B408                <1> 	mov	ah,fdc_e_dma
  1335 000018CF 7510                <1> 	jnz	.exit
  1336 000018D1 F6C720              <1> 	test	bh,20H			; CRC error?
  1337 000018D4 B410                <1> 	mov	ah,fdc_e_crc
  1338 000018D6 7509                <1> 	jnz	.exit
  1339 000018D8 F6C780              <1> 	test	bh,80h			; access after last sector? End of Track
  1340 000018DB B404                <1> 	mov	ah,fdc_e_notfound
  1341 000018DD 7502                <1> 	jnz	.exit
  1342 000018DF B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  1343                              <1> 
  1344                              <1> .exit:
  1345 000018E1 C3                  <1> 	ret
  1346                              <1> 
  1347                              <1> ;=========================================================================
  1348                              <1> ; fdc_reset - Reset FDC
  1349                              <1> ; Input:
  1350                              <1> ;	none
  1351                              <1> ; Output:
  1352                              <1> ;	Resets FDC flags in BIOS area
  1353                              <1> ;	AX,CX,DX - trashed 
  1354                              <1> ;-------------------------------------------------------------------------
  1355                              <1> fdc_reset:
  1356 000018E2 FA                  <1> 	cli
  1357 000018E3 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1358 000018E8 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
  1359 000018ED A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
  1360 000018F0 24BF                <1> 	and	al,0BFh			; clear bit 6 - reset,  note set_fdc_dor rotates right 4 bits 40h=04h!
  1361 000018F2 50                  <1> 	push	ax			; set_fdc_dor trashes AX, save it
  1362 000018F3 E8FE00              <1> 	call	set_fdc_dor
  1363 000018F6 58                  <1> 	pop	ax
  1364 000018F7 B90300              <1> 	mov	cx,3
  1365 000018FA E815F9              <1> 	call	delay_15us		; 30-45 us delay
  1366 000018FD 0C40                <1> 	or	al,40h			; set bit 6 - no reset,  note set_fdc_dor rotates right 4 bits 40h=04h!
  1367 000018FF E8F200              <1> 	call	set_fdc_dor             ; Note set_fdc_dor now clears DMAIRQ bit
  1368 00001902 FB                  <1> 	sti
  1369                              <1> ;	call	fdc_wait_irq		; wait for IRQ
  1370 00001903 E8C301              <1>     call    chk_stat_results    ; Check for busy flag to be clear or timeout, getting D0 which show RQM, DIO and CB high
  1371                              <1> 
  1372 00001906 7207                <1> 	jc	.exit
  1373 00001908 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1374 0000190D 30E4                <1> 	xor	ah,ah			; no errors
  1375                              <1> .exit:
  1376 0000190F C3                  <1> 	ret
  1377                              <1> 
  1378                              <1> ;=========================================================================
  1379                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  1380                              <1> ; Input:
  1381                              <1> ;	[BP+int_13_dl] = drive number
  1382                              <1> ; Output:
  1383                              <1> ;	CF clear if successful
  1384                              <1> ;		AH = 00h
  1385                              <1> ;	CF set on error
  1386                              <1> ;		AH = 20h - invalid drive type
  1387                              <1> ;-------------------------------------------------------------------------
  1388                              <1> fdc_detect_media:
  1389 00001910 52                  <1> 	push	dx
  1390 00001911 51                  <1> 	push	cx
  1391                              <1> 
  1392 00001912 B420                <1> 	mov	ah,fdc_e_failure	; in case the get_drive_type fails
  1393 00001914 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; restore DL in case it was trashed
  1394 00001917 E84901              <1> 	call	get_drive_type		; get drive type to AL
  1395 0000191A 7271                <1> 	jc	.exit			; drive doesn't exist or invalid type
  1396                              <1> 
  1397 0000191C 3C03                <1> 	cmp	al,type_720
  1398 0000191E 7410                <1> 	je	.set_720
  1399 00001920 3C02                <1> 	cmp	al,type_1200
  1400 00001922 7415                <1> 	je	.detect_1200
  1401 00001924 3C04                <1> 	cmp	al,type_1440
  1402 00001926 7427                <1> 	je	.detect_1440
  1403 00001928 3C06                <1> 	cmp	al,type_2880
  1404 0000192A 743D                <1> 	je	.detect_2880
  1405                              <1> 
  1406 0000192C B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  1407 0000192E EB02                <1> 	jmp	.set_rate
  1408                              <1> 
  1409                              <1> .set_720:
  1410 00001930 B097                <1> 	mov	al,fdc_m_720
  1411                              <1> 
  1412                              <1> .set_rate:
  1413 00001932 50                  <1> 	push	ax
  1414 00001933 E8A500              <1> 	call	fdc_set_rate		; transfer rate in AL
  1415 00001936 58                  <1> 	pop	ax
  1416 00001937 EB4D                <1> 	jmp	.exit_set_media
  1417                              <1> 
  1418                              <1> .detect_1200:
  1419 00001939 B000                <1> 	mov	al,0			; try 500 Kbps
  1420 0000193B E85600              <1> 	call	fdc_read_id
  1421 0000193E B015                <1> 	mov	al,fdc_m_1200in1200
  1422 00001940 7344                <1> 	jnc	.exit_set_media		; jump if successful
  1423 00001942 B040                <1> 	mov	al,40h			; try 300 Kbps
  1424 00001944 E84D00              <1> 	call	fdc_read_id
  1425 00001947 B074                <1> 	mov	al,fdc_m_360in1200
  1426 00001949 733B                <1> 	jnc	.exit_set_media		; jump if successful
  1427 0000194B B002                <1> 	mov	al,fdc_m_try_1200in1200
  1428 0000194D EB37                <1> 	jmp	.exit_set_media
  1429                              <1> 
  1430                              <1> .detect_1440:
  1431 0000194F B0D3                <1> 	mov	al, 0xD3		; Detect 1.44MB Media Type
  1432 00001951 E680                <1> 	out	post_reg,al
  1433                              <1> 
  1434 00001953 B000                <1> 	mov	al,0			; try 500 Kbps
  1435 00001955 E83C00              <1> 	call	fdc_read_id
  1436 00001958 B017                <1> 	mov	al,fdc_m_1440
  1437 0000195A 732A                <1> 	jnc	.exit_set_media		; jump if successful
  1438 0000195C B080                <1> 	mov	al,80h			; try 250 Kbps
  1439 0000195E E83300              <1> 	call	fdc_read_id
  1440 00001961 B097                <1> 	mov	al,fdc_m_720
  1441 00001963 7321                <1> 	jnc	.exit_set_media		; jump if successful
  1442 00001965 B007                <1> 	mov	al,fdc_m_try_1440
  1443 00001967 EB1D                <1> 	jmp	.exit_set_media
  1444                              <1> 
  1445                              <1> .detect_2880:
  1446 00001969 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  1447 0000196B E82600              <1> 	call	fdc_read_id
  1448 0000196E B0D7                <1> 	mov	al,fdc_m_2880
  1449 00001970 7314                <1> 	jnc	.exit_set_media		; jump if successful
  1450 00001972 B000                <1> 	mov	al,0			; try 500 Kbps
  1451 00001974 E81D00              <1> 	call	fdc_read_id
  1452 00001977 B017                <1> 	mov	al,fdc_m_1440
  1453 00001979 730B                <1> 	jnc	.exit_set_media		; jump if successful
  1454 0000197B B080                <1> 	mov	al,80h			; try 250 Kbps
  1455 0000197D E81400              <1> 	call	fdc_read_id
  1456 00001980 B097                <1> 	mov	al,fdc_m_720
  1457 00001982 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  1458 00001984 B0C7                <1> 	mov	al,fdc_m_try_2880
  1459                              <1> 
  1460                              <1> .exit_set_media:
  1461 00001986 E680                <1>  	out	post_reg,al       ; Log Media State to POST should be 0x17 for 1.44MB HD
  1462 00001988 E88200              <1> 	call	set_media_state		; set media state
  1463 0000198B 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1464                              <1> .exit:
  1465 0000198D 88264100            <1> 	mov	byte [fdc_last_error],ah
  1466 00001991 59                  <1> 	pop	cx
  1467 00001992 5A                  <1> 	pop	dx
  1468 00001993 C3                  <1> 	ret
  1469                              <1> 
  1470                              <1> ;=========================================================================
  1471                              <1> ; fdc_read_id - Read ID
  1472                              <1> ; Input:
  1473                              <1> ;	[BP+int_13_dl] = drive number
  1474                              <1> ; Output:
  1475                              <1> ;	CF clear if successful
  1476                              <1> ;		AH = 0 - successful completion
  1477                              <1> ;		AL = ID (bits 7-6)
  1478                              <1> ;	CF set on error
  1479                              <1> ;		AH = error code
  1480                              <1> ;	AX,CX - trashed
  1481                              <1> ;-------------------------------------------------------------------------
  1482                              <1> fdc_read_id:
  1483 00001994 53                  <1> 	push	bx
  1484 00001995 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  1485 0000199A E83E00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1486 0000199D 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  1487 000019A0 E851FC              <1> 	call	fdc_recalibrate		; recalibrate
  1488 000019A3 7305                <1> 	jnc	.do_read_id
  1489 000019A5 E84CFC              <1> 	call	fdc_recalibrate		; second attempt
  1490 000019A8 722E                <1> 	jc	.error
  1491                              <1> 
  1492                              <1> .do_read_id:
  1493 000019AA B90300              <1> 	mov	cx,3			; 3 attempts
  1494                              <1> 
  1495                              <1> .read_id_loop:
  1496 000019AD 51                  <1> 	push	cx
  1497 000019AE B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  1498                              <1> ; FIXME - does drive number in DL gets to here?
  1499                              <1> ;	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  1500 000019B0 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; read id - byte 1 (head = 0 / drive)
  1501 000019B3 B102                <1> 	mov	cl,2			; 2 byte commands
  1502 000019B5 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  1503 000019BA E81AFE              <1> 	call	fdc_send_cmd
  1504 000019BD 7218                <1> 	jc	.error_cmd
  1505                              <1> ;	call	fdc_wait_irq		; wait for IRQ6
  1506 000019BF E80701              <1>     call    chk_stat_results    ; Wait for Sense Interrupt Status to return in results phases
  1507                              <1> 
  1508 000019C2 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  1509 000019C4 B107                <1> 	mov	cl,7
  1510 000019C6 E880FE              <1> 	call	fdc_get_result		; read result bytes
  1511 000019C9 720C                <1> 	jc	.error_cmd
  1512 000019CB E8D5FE              <1> 	call	fdc_get_error		; get error code
  1513 000019CE 59                  <1> 	pop	cx
  1514 000019CF 08E4                <1> 	or	ah,ah
  1515 000019D1 7406                <1> 	jz	.exit			; if no errors
  1516 000019D3 E2D8                <1> 	loop	.read_id_loop		; retry
  1517 000019D5 EB01                <1> 	jmp	.error
  1518                              <1> 
  1519                              <1> .error_cmd:
  1520 000019D7 59                  <1> 	pop	cx
  1521                              <1> 
  1522                              <1> .error:
  1523 000019D8 F9                  <1> 	stc
  1524                              <1> 
  1525                              <1> .exit:
  1526 000019D9 5B                  <1> 	pop	bx
  1527 000019DA C3                  <1> 	ret
  1528                              <1> 
  1529                              <1> ;=========================================================================
  1530                              <1> ; fdc_set_rate - Set transfer rate
  1531                              <1> ; Input:
  1532                              <1> ;	AL = transfer rate (bits 7 and 6)
  1533                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  1534                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  1535                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  1536                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  1537                              <1> ; Output:
  1538                              <1> ;	none
  1539                              <1> ;-------------------------------------------------------------------------
  1540                              <1> fdc_set_rate:
  1541 000019DB 50                  <1> 	push	ax
  1542 000019DC 24C0                <1> 	and	al,fdc_m_rate_bits	; get the data rate bits only
  1543 000019DE 80268B003F          <1> 	and	byte [fdc_last_rate],~fdc_m_rate_bits ; clear rate bits
  1544 000019E3 08068B00            <1> 	or	byte [fdc_last_rate],al	; set new rate bits
  1545 000019E7 D0C0                <1> 	rol	al,1
  1546 000019E9 D0C0                <1> 	rol	al,1
  1547 000019EB BAF703              <1> 	mov	dx,fdc_ccr_reg		; get control configuration register address
  1548 000019EE EE                  <1> 	out	dx,al
  1549 000019EF 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1550 000019F2 58                  <1> 	pop	ax
  1551 000019F3 C3                  <1> 	ret
  1552                              <1> 
  1553                              <1> ;=========================================================================
  1554                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  1555                              <1> ; Input:
  1556                              <1> ;	none
  1557                              <1> ; Output:
  1558                              <1> ;	CF clear if interrupt had occurred
  1559                              <1> ;		AH = 00h - successful completion
  1560                              <1> ;	CF set if no interrupt
  1561                              <1> ;		AH = 80h - timeout
  1562                              <1> ;	BX = fdc_calib_state
  1563                              <1> ;	AL - trashed
  1564                              <1> ;-------------------------------------------------------------------------
  1565                              <1> ; fdc_wait_irq:
  1566                              <1> 	; push	cx
  1567                              <1> 	; sti
  1568                              <1> 	; clc
  1569                              <1> 	; mov	ax,9001h
  1570                              <1> 	; int	15h			; call OS hook
  1571                              <1> 	; jc	.timeout
  1572                              <1> 	; mov	bx,fdc_calib_state	; contains IRQ flag
  1573                              <1> 	; xor	cx,cx
  1574                              <1> 
  1575                              <1> ; %ifdef AT_DELAY
  1576                              <1> 
  1577                              <1> ; .zero_loop:
  1578                              <1> 	; test	byte [bx],fdc_irq_flag	; test IRQ flag
  1579                              <1> 	; jnz	.exit			; exit loop if interrupt had occurred
  1580                              <1> 	; in	al,ppi_pb_reg
  1581                              <1> 	; test	al,refresh_flag
  1582                              <1> 	; jz	.zero_loop		; wait 15.09 us
  1583                              <1> 	; loop	.one_loop		; DEC CX; JNZ .one_loop
  1584                              <1> 	; jmp	.timeout
  1585                              <1> 
  1586                              <1> ; .one_loop:
  1587                              <1> 	; test	byte [bx],fdc_irq_flag	; test IRQ flag
  1588                              <1> 	; jnz	.exit			; exit loop if interrupt had occurred
  1589                              <1> 	; in	al,ppi_pb_reg
  1590                              <1> 	; test	al,refresh_flag
  1591                              <1> 	; jnz	.one_loop		; wait 15.09 us
  1592                              <1> 	; loop	.zero_loop		; DEC CX; JNZ .zero_loop
  1593                              <1> 
  1594                              <1> ; %else ; AT_DELAY
  1595                              <1> 
  1596                              <1> ; .1:
  1597                              <1> 	; ; wait 38.13 us (Intel 8088 CPU running on 4.77 MHz)
  1598                              <1> 	; mov	al,10
  1599                              <1> ; .2:
  1600                              <1> 	; test	byte [bx],fdc_irq_flag	; test IRQ flag
  1601                              <1> 	; jnz	.exit			; exit loop if interrupt had occurred
  1602                              <1> 	; dec	al
  1603                              <1> 	; jnz	.2
  1604                              <1> 	; loop	.1
  1605                              <1> 
  1606                              <1> ; %endif ; AT_DELAY
  1607                              <1> 
  1608                              <1> ; .timeout:
  1609                              <1> 	; mov	ah,fdc_e_timeout	; timeout
  1610                              <1> 	; mov	al, 0xDD		; IRQ timeout
  1611                              <1> 	; out	post_reg,al
  1612                              <1> 	; mov	al,fdc_e_timeout	; timeout 80
  1613                              <1> 	; out	post_reg,al
  1614                              <1> 	; stc
  1615                              <1> 	; pop	cx
  1616                              <1> 	; ret
  1617                              <1> 
  1618                              <1> ; .exit:
  1619                              <1> 	; mov	al, 0xDA		; IRQ Exit
  1620                              <1> 	; out	post_reg,al
  1621                              <1> 	; and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  1622                              <1> 	; xor	ah,ah			; AH = 0, CF = 0 - no error
  1623                              <1> 	; pop	cx
  1624                              <1> 	; ret
  1625                              <1> 
  1626                              <1> ;=========================================================================
  1627                              <1> ; set_fdc_dor - set FDC Digital Output Register - DOR
  1628                              <1> ; Input:
  1629                              <1> ;	AL = new motor state
  1630                              <1> ; Output:
  1631                              <1> ;	AL, DX trashed
  1632                              <1> ;-------------------------------------------------------------------------
  1633                              <1> set_fdc_dor:
  1634 000019F4 D0C8                <1> 	ror	al,1
  1635 000019F6 D0C8                <1> 	ror	al,1
  1636 000019F8 D0C8                <1> 	ror	al,1
  1637 000019FA D0C8                <1> 	ror	al,1
  1638                              <1> ;	or	al,08h			; DMA+IRQ enabled, now DMA Disabled for BBPC
  1639 000019FC 2477                <1>     and     al,77h                  ; Clear Mode Bit 7 and Bit 3 DMA+IRQ on WD37C65C
  1640 000019FE BAF203              <1> 	mov	dx,fdc_dor_reg		; get digital output register address
  1641 00001A01 EE                  <1> 	out	dx,al			; send the state to FDC
  1642 00001A02 C3                  <1> 	ret
  1643                              <1> 
  1644                              <1> ;=========================================================================
  1645                              <1> ; get_media_state - Get drive's media state from the data area
  1646                              <1> ; Input:
  1647                              <1> ;	[BP+int_13_dl] = drive number
  1648                              <1> ; Output:
  1649                              <1> ;	BL = drive's media state
  1650                              <1> ;	BH = 0 (destroyed)
  1651                              <1> ;-------------------------------------------------------------------------
  1652                              <1> get_media_state:
  1653 00001A03 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1654 00001A06 B700                <1> 	mov	bh,0			; BX = drive number
  1655 00001A08 8A9F9000            <1> 	mov	bl,byte [fdc_media_state+bx]
  1656 00001A0C C3                  <1> 	ret
  1657                              <1> 
  1658                              <1> ;=========================================================================
  1659                              <1> ; set_media_state - Store drive's media state in the data area
  1660                              <1> ; Input:
  1661                              <1> ;	AL = media state
  1662                              <1> ;	[BP+int_13_dl] = drive number
  1663                              <1> ; Output:
  1664                              <1> ;	none
  1665                              <1> ;-------------------------------------------------------------------------
  1666                              <1> set_media_state:
  1667 00001A0D 53                  <1> 	push	bx
  1668 00001A0E 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1669 00001A11 B700                <1> 	mov	bh,0			; BX = drive number
  1670 00001A13 88879000            <1> 	mov	byte [fdc_media_state+bx],al
  1671 00001A17 5B                  <1> 	pop	bx
  1672 00001A18 C3                  <1> 	ret
  1673                              <1> 
  1674                              <1> ;=========================================================================
  1675                              <1> ; check_cylinder - Compare specified cylinder with value in the BIOS data area
  1676                              <1> ; Input:
  1677                              <1> ;	CH = current cylinder
  1678                              <1> ;	[BP+int_13_dl] = drive number
  1679                              <1> ; Output:
  1680                              <1> ;	ZF = 1 - cylinder matches
  1681                              <1> ;-------------------------------------------------------------------------
  1682                              <1> check_cylinder:
  1683 00001A19 53                  <1> 	push	bx
  1684 00001A1A 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1685 00001A1D B700                <1> 	mov	bh,0			; BX = drive number
  1686 00001A1F 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch
  1687 00001A23 5B                  <1> 	pop	bx
  1688 00001A24 C3                  <1> 	ret
  1689                              <1> 
  1690                              <1> ;=========================================================================
  1691                              <1> ; set_cylinder - Store drive's current cylinder into the BIOS data area
  1692                              <1> ; Input:
  1693                              <1> ;	CH = current cylinder
  1694                              <1> ;	[BP+int_13_dl] = drive number
  1695                              <1> ; Output:
  1696                              <1> ;	none
  1697                              <1> ;-------------------------------------------------------------------------
  1698                              <1> set_cylinder:
  1699 00001A25 53                  <1> 	push	bx
  1700 00001A26 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1701 00001A29 B700                <1> 	mov	bh,0			; BX = drive number
  1702 00001A2B 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch
  1703 00001A2F 5B                  <1> 	pop	bx
  1704 00001A30 C3                  <1> 	ret
  1705                              <1> 
  1706                              <1> ;=========================================================================
  1707                              <1> ; check_drive_calibrated - Check if the drive calibrated bit is set
  1708                              <1> ;			   in the BIOS data area
  1709                              <1> ; Input:
  1710                              <1> ;	[BP+int_13_dl] = drive number
  1711                              <1> ; Output:
  1712                              <1> ;	CF = 1 - bit set (drive calibrated)
  1713                              <1> ;-------------------------------------------------------------------------
  1714                              <1> check_drive_calibrated:
  1715 00001A31 51                  <1> 	push	cx
  1716 00001A32 8A2E3E00            <1> 	mov	ch,byte [fdc_calib_state] ; calibration state for primary FDC
  1717 00001A36 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1718 00001A39 FEC1                <1> 	inc	cl
  1719 00001A3B D2ED                <1> 	shr	ch,cl			; set CF if drive is calibrated
  1720 00001A3D 59                  <1> 	pop	cx
  1721 00001A3E C3                  <1> 	ret
  1722                              <1> 
  1723                              <1> ;=========================================================================
  1724                              <1> ; set_drive_calibrated - Set drive calibrated bit in the BIOS data area
  1725                              <1> ; Input:
  1726                              <1> ;	[BP+int_13_dl] = drive number
  1727                              <1> ; Output:
  1728                              <1> ;	none
  1729                              <1> ;-------------------------------------------------------------------------
  1730                              <1> set_drive_calibrated:
  1731 00001A3F 51                  <1> 	push	cx
  1732 00001A40 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1733 00001A43 B501                <1> 	mov	ch,1			; bit 0 set
  1734 00001A45 D2E5                <1> 	shl	ch,cl			; move it into the right position
  1735 00001A47 082E3E00            <1> 	or	byte [fdc_calib_state],ch ; set the bit for the primary FDC
  1736 00001A4B 59                  <1> 	pop	cx
  1737 00001A4C C3                  <1> 	ret
  1738                              <1> 
  1739                              <1> ;=========================================================================
  1740                              <1> ; detect_floppy - Detect floppy configuration
  1741                              <1> ;                 set equipment bits accordingly
  1742                              <1> ; Input:
  1743                              <1> ;	none
  1744                              <1> ; Ouput:
  1745                              <1> ;	AL = NVRAM floppy configuration byte
  1746                              <1> ;-------------------------------------------------------------------------
  1747                              <1> detect_floppy:
  1748                              <1> %ifdef BIOS_SETUP
  1749 00001A4D E876F3              <1> 	call	get_floppy
  1750                              <1> %else ; BIOS_SETUP
  1751                              <1> 	mov	al,DEFAULT_FLOPPIES	
  1752                              <1> %endif ; BIOS_SETUP
  1753 00001A50 3C00                <1> 	cmp	al,00h			; No floppy drives?
  1754 00001A52 740E                <1> 	je	.exit
  1755 00001A54 800E100001          <1> 	or	byte [equipment_list],equip_floppies
  1756 00001A59 A80F                <1> 	test	al,0Fh			; Second floppy drive installed?
  1757 00001A5B 7405                <1> 	jz	.exit
  1758 00001A5D 800E100040          <1> 	or	byte [equipment_list],equip_floppy2
  1759                              <1> .exit:
  1760 00001A62 C3                  <1> 	ret
  1761                              <1> 
  1762                              <1> ;=========================================================================
  1763                              <1> ; get_drive_type - Read drive type from NVRAM or Flash ROM configuration
  1764                              <1> ; Input:
  1765                              <1> ;	DL = drive number (0 or 1)
  1766                              <1> ; Output:
  1767                              <1> ;	CF clear if successful
  1768                              <1> ;		AL = drive type
  1769                              <1> ;	CF set on error (invalid drive type)
  1770                              <1> ;=========================================================================
  1771                              <1> 
  1772                              <1> get_drive_type:
  1773                              <1> %ifdef BIOS_SETUP
  1774 00001A63 E860F3              <1> 	call	get_floppy
  1775                              <1> %else ; BIOS_SETUP
  1776                              <1> 	mov	al,DEFAULT_FLOPPIES
  1777                              <1> %endif ; BIOS_SETUP
  1778 00001A66 08D2                <1> 	or	dl,dl			; drive 0?
  1779 00001A68 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  1780 00001A6A D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  1781 00001A6C D0E8                <1> 	shr	al,1
  1782 00001A6E D0E8                <1> 	shr	al,1
  1783 00001A70 D0E8                <1> 	shr	al,1
  1784                              <1> .drive_1:
  1785 00001A72 240F                <1> 	and	al,0Fh			; mask drive bits
  1786 00001A74 3C00                <1> 	cmp	al,type_none
  1787 00001A76 740A                <1> 	je	.error
  1788 00001A78 3C05                <1> 	cmp	al,5			; invalid value
  1789 00001A7A 7406                <1> 	je	.error
  1790 00001A7C 3C06                <1> 	cmp	al,type_2880
  1791 00001A7E 7702                <1> 	ja	.error
  1792 00001A80 F8                  <1> 	clc
  1793 00001A81 C3                  <1> 	ret
  1794                              <1> 
  1795                              <1> .error:
  1796 00001A82 F9                  <1> 	stc
  1797 00001A83 C3                  <1> 	ret
  1798                              <1> 
  1799                              <1> ;=========================================================================
  1800                              <1> ; print_floppy - Print floppy configuration
  1801                              <1> ; Input:
  1802                              <1> ;	AL = NVRAM floppy configuration byte
  1803                              <1> ; Ouput:
  1804                              <1> ;	none
  1805                              <1> ;-------------------------------------------------------------------------
  1806                              <1> print_floppy:
  1807 00001A84 50                  <1> 	push	ax
  1808 00001A85 56                  <1> 	push	si
  1809 00001A86 BE[1402]            <1> 	mov	si,msg_floppy
  1810 00001A89 E8240E              <1> 	call	print
  1811 00001A8C D0C8                <1> 	ror	al,1
  1812 00001A8E D0C8                <1> 	ror	al,1
  1813 00001A90 D0C8                <1> 	ror	al,1
  1814 00001A92 D0C8                <1> 	ror	al,1
  1815 00001A94 89C6                <1> 	mov	si,ax
  1816 00001A96 83E607              <1> 	and	si,0007h
  1817 00001A99 D1E6                <1> 	shl	si,1
  1818 00001A9B 2E8BB4[0E08]        <1>     cs	mov	si,word [tbl_floppy+si]
  1819 00001AA0 E80D0E              <1> 	call	print
  1820 00001AA3 BE[3A02]            <1> 	mov	si,msg_floppy_2
  1821 00001AA6 E8070E              <1> 	call	print
  1822 00001AA9 D0C8                <1> 	ror	al,1
  1823 00001AAB D0C8                <1> 	ror	al,1
  1824 00001AAD D0C8                <1> 	ror	al,1
  1825 00001AAF D0C8                <1> 	ror	al,1
  1826 00001AB1 89C6                <1> 	mov	si,ax
  1827 00001AB3 83E607              <1> 	and	si,0007h
  1828 00001AB6 D1E6                <1> 	shl	si,1
  1829 00001AB8 2E8BB4[0E08]        <1>     cs	mov	si,word [tbl_floppy+si]
  1830 00001ABD E8F00D              <1> 	call	print
  1831 00001AC0 BE[8B00]            <1> 	mov	si,msg_crlf
  1832 00001AC3 E8EA0D              <1> 	call	print
  1833 00001AC6 5E                  <1> 	pop	si
  1834 00001AC7 58                  <1> 	pop	ax
  1835 00001AC8 C3                  <1> 	ret
  1836                              <1> ;=========================================================================
  1837                              <1> ; CHK_STAT_RESULTS based on _2 from PC-Jr BIOS with mods for Xi-8088 for handling interrupt
  1838                              <1> ; process without IRQ6 being enabled and DMA disabled
  1839                              <1> ; THIS ROUTINE WAITS FOR BUSY FLAG TO BE ZERO BIT 4 OF STATUS
  1840                              <1> ; THIS MEANS EXECUTION MODE HAS FINISHED AND NOW IN RESULTS MODE
  1841                              <1> ; NOTE THAT WHEN REPLACING INTERRUPTS THAT RQM and DIO checks do not include FDC Busy
  1842                              <1> ; THE INTERRUPT IS WAITED FOR, THE INTERRUPT STATUS SENSED,
  1843                              <1> ; AND THE RESULT RETURNED TO THE CALLER
  1844                              <1> ; NONE
  1845                              <1> ; CY = 0 SUCCESS
  1846                              <1> ; CY = 1 FAILURE -- ERROR IS IN DISKETTE-STATUS
  1847                              <1> ; (AX) DESTROYED
  1848                              <1> ; INPUT
  1849                              <1> ; OUTPUT
  1850                              <1> ;-------------------------------------------------------------------------
  1851                              <1> 
  1852                              <1> 
  1853                              <1>  chk_stat_results:
  1854 00001AC9 53                  <1> 		  push	  bx                     ; SAVE REGISTERS
  1855 00001ACA 52                  <1> 		  push    dx
  1856 00001ACB 31DB                <1> 		  xor	  bx, bx                 ; NUMBER OF STATUS POLLS TO ISSUE BEFORE TIMEOUT
  1857 00001ACD BAF403              <1>           mov	  dx,fdc_status_reg
  1858                              <1>  
  1859                              <1>  .check_status:				  
  1860 00001AD0 EC                  <1> 		  in	  al,dx		
  1861 00001AD1 A820                <1> 		  test	  al, fdc_exec_mode
  1862 00001AD3 7409                <1> 		  jz	  .exec_clear            ; Execution Mode flag clear so return 
  1863                              <1> 
  1864                              <1>  .dec_counter:				  
  1865 00001AD5 4B                  <1> 		  dec	  bx                     ; DEC LOOP COUNTER
  1866 00001AD6 75F8                <1> 		  jnz	  short	.check_status    ; DO ANOTHER LOOP
  1867 00001AD8 800E410080          <1> 		  or	  byte [fdc_last_error], fdc_e_timeout ; Add the timeout bit to FDC Error 
  1868                              <1>  .seterror:					  
  1869 00001ADD F9                  <1> 		  stc                            ; RETURN ERROR INDICATION FOR CALLER
  1870                              <1>  
  1871                              <1>  .exec_clear:					  
  1872 00001ADE 5A                  <1> 		  pop	  dx					  
  1873 00001ADF 5B                  <1> 		  pop	  bx                     ; RESTORE REGISTERS
  1874 00001AE0 C3                  <1> 		  ret
  1875                              <1> 
  1876                              <1> 
  1877                              <1> 
  1878                              <1> ;=========================================================================
  1879                              <1> ; CHK_STAT_2 from PC-Jr BIOS with mods for Xi-8088 for handling interrupt
  1880                              <1> ; process without IRQ6 being enabled and DMA disabled
  1881                              <1> ; THIS ROUTINE HANDLES THE INTERRUPT RECEIVED AFTER
  1882                              <1> ; A RECALIBRATE, SEEK, OR RESET TO THE ADAPTER
  1883                              <1> ; THE INTERRUPT IS WAITED FOR, THE INTERRUPT STATUS SENSED,
  1884                              <1> ; AND THE RESULT RETURNED TO THE CALLER
  1885                              <1> ; NONE
  1886                              <1> ; CY = 0 SUCCESS
  1887                              <1> ; CY = 1 FAILURE -- ERROR IS IN DISKETTE-STATUS
  1888                              <1> ; (AX) DESTROYED
  1889                              <1> ; INPUT
  1890                              <1> ; OUTPUT
  1891                              <1> ;-------------------------------------------------------------------------
  1892                              <1> 
  1893                              <1> 
  1894                              <1>  chk_stat_2:
  1895 00001AE1 53                  <1> 		  push	  bx                     ; SAVE REGISTERS
  1896 00001AE2 31DB                <1> 		  xor	  bx, bx                 ; NUMBER OF SENSE INTERRUPTS TO ISSUE
  1897                              <1> 
  1898                              <1>  j33_2:				  
  1899 00001AE4 B008                <1> 		  mov	  al, 08h                ; SENSE INTERUPT STATUS
  1900 00001AE6 E83AFD              <1> 		  call	  fdc_write              ; ISSUE SENSE INTERUPT STATUS
  1901 00001AE9 E85DFD              <1> 		  call	  fdc_get_result
  1902 00001AEC 7210                <1> 		  jc	  short	j35              ; NEC TIME OUT, FLAGS SET IN RESULTS
  1903 00001AEE A04200              <1> 		  mov	  al, [fdc_ctrl_status]  ; GET STATUS ST0
  1904 00001AF1 A820                <1> 		  test	  al, 20h                ; IS SEEK OR RECAL OPERATION DONE ST0 Seek End D5 0x20
  1905 00001AF3 750B                <1> 		  jnz	  short	j35_1            ; JUMP IF EXECUTION OF SEEK OR RECAL DONE
  1906                              <1>  j33_3:				  
  1907 00001AF5 4B                  <1> 		  dec	  bx                     ; DEC LOOP COUNTER
  1908 00001AF6 75EC                <1> 		  jnz	  short	j33_2            ; DO ANOTHER LOOP
  1909 00001AF8 800E410080          <1> 		  or	  byte [fdc_last_error], fdc_e_timeout ; Add the time out bit to FDC Error 
  1910                              <1>  j34:					  
  1911 00001AFD F9                  <1> 		  stc                            ; RETURN ERROR INDICATION FOR CALLER
  1912                              <1>  j35:					  
  1913                              <1> 					  
  1914 00001AFE 5B                  <1> 		  pop	  bx                     ; RESTORE REGISTERS
  1915 00001AFF C3                  <1> 		  ret
  1916                              <1>  j35_1:				                 ; SEEK END HAS OCCURED, CHECK FOR NORMAL TERMINATION
  1917 00001B00 24C0                <1> 		  and	  al, 0C0h               ; MASK NORMAL TERMINATION BITS ST0 D7 & D6 dont have constants yet!
  1918 00001B02 74FA                <1> 		  jz	  short j35              ; JUMP IF NORMAL TERMINATION
  1919 00001B04 800E410040          <1> 		  or	  byte [fdc_last_error], fdc_e_seek ;  Add the seek error bit to FDC Error
  1920 00001B09 EBF2                <1> 		  jmp	  short	j34
  1921                              <1>  
  1922                              <1>     ; fdc_last_error	equ	41h	; DISKETTE-STATUS byte - status of last diskette operation
  1923                              <1>     ; fdc_ctrl_status	equ	42h	; NEC-STATUS byte[7] - FDC status bytes
  1924                              <1> 
  1925                              <1>     ; FDC status register bits
  1926                              <1>     ; fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
  1927                              <1>     ; fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
  1928                              <1>     ; fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
  1929                              <1>     ; fdc_stat_busy	equ	10h		; 1 = FDC is busy
  1930                              <1> 
  1931                              <1> ;=========================================================================
  1932                              <1> ; BOUND_SETUP
  1933                              <1> ; THIS ROUTINE SETS UP BUFFER ADDRESSING FOR READ/WRITE/VERIFY
  1934                              <1> ; OPERATIONS
  1935                              <1> ; INPUT
  1936                              <1> ;   ES HAS ORIGINAL BUFFER SEGMENT VALUE
  1937                              <1> ;   BP POINTS AT BASE OF SAVED PARMETERS ON STACK
  1938                              <1> ;   ES HAS SEGMENT WHICH WILL ALLOW 64K ACCESS THE
  1939                              <1> ;   COMBINATION ES:DI AND DS:SI POINT TO THE BUFFER THIS
  1940                              <1> ;   CALCULATED ADDRESS WILL ALWAYS ACCESS 64K OF MEMORY
  1941                              <1> ;   BX DESTOYED (or you could say adjusted for new ES value!)
  1942                              <1> ; OUTPUT
  1943                              <1> ;-------------------------------------------------------------------------
  1944                              <1> 
  1945                              <1> bound_setup:
  1946 00001B0B 51                  <1> 		  push	  cx                 ; SAVE REGISTERS
  1947 00001B0C 8B5E0C              <1> 		  mov	  bx, [bp+int_13_bx] ; GET OFFSET OF BUFFER FROM STACK
  1948 00001B0F 53                  <1> 		  push	  bx                 ; SAVE OFFSET TEMPORARILY
  1949 00001B10 B104                <1> 		  mov	  cl, 4              ; SHIFT COUNT
  1950 00001B12 D3EB                <1> 		  shr	  bx, cl             ; SHIFT OFFSET FOR NEW SEGMENT VALUE
  1951 00001B14 8CC1                <1> 		  mov	  cx, es             ; PUT ES IN REGISTER SUITABLE FOR ADDING TO
  1952 00001B16 01D9                <1> 		  add	  cx, bx             ; GET NEW VALUE FOR ES
  1953 00001B18 8EC1                <1> 		  mov	  es, cx             ; UPDATE THE ES REGISTER
  1954 00001B1A 5B                  <1> 		  pop	  bx                 ; RECOVER ORIGINAL OFFSET
  1955 00001B1B 83E30F              <1> 		  and	  bx, 0Fh            ; NEW OFFSET
  1956 00001B1E 89DE                <1> 		  mov	  si, bx             ; DS:SI POINT AT BUFFER
  1957 00001B20 89DF                <1> 		  mov	  di, bx             ; ES:DI POINT AT BUFFER
  1958 00001B22 59                  <1> 		  pop	  cx                 ; 
  1959 00001B23 C3                  <1> 		  ret                        ;
  1960                              <1> ;=========================================================================
  1961                              <1> ; THIS SUBROUTINE SETS DS TO POINT TO THE BIOS DATA AREA
  1962                              <1> ; INPUT NONE , OUTPUT DS IS SET
  1963                              <1> ;-------------------------------------------------------------------------
  1964                              <1> 
  1965                              <1> dss:
  1966 00001B24 50                  <1> 		  push	  ax
  1967 00001B25 B84000              <1> 		  mov	  ax, 40h ; BIOS Data aread {0x0040:0000] or 0x00400
  1968 00001B28 8ED8                <1> 		  mov	  ds, ax
  1969 00001B2A 58                  <1> 		  pop	  ax
  1970 00001B2B C3                  <1> 		  ret
  1971                              <1> 
  1972                              <1> ;=========================================================================
  1973                              <1> ; NUM_TRANS
  1974                              <1> ; THIS ROUTINE CALCULATES THE NUMBER OF SECTORS THAT
  1975                              <1> ; WERE ACTUALLY TRANSFERRED TO/FROM THE DISKETTE
  1976                              <1> ; INPUT
  1977                              <1> ;    (CH) = CYLINDER OF OPERATION
  1978                              <1> ;    (CL) = START SECTOR OF OPERATION
  1979                              <1> ; OUTPUT
  1980                              <1> ;    (AL) = NUMBER ACTUALLY TRANSFERRED
  1981                              <1> ; NO OTHER REGISTERS MODIFIED
  1982                              <1> ;-------------------------------------------------------------------------
  1983                              <1> 
  1984                              <1> num_trans:
  1985 00001B2C 1E                  <1>           push    ds
  1986 00001B2D 56                  <1> 		  push    si
  1987 00001B2E 3EA04500            <1> 		  mov	  al, ds:fdc_ctrl_status+3  ; GET CYLINDER ENDED UP ON
  1988 00001B32 3A460B              <1> 		  cmp	  al, [bp+int_13_ch]        ; SAME CYLINDER/TRACK COUNT AS WE STARTED? NOTE PCJR BP Offsets are different from XI BIOS
  1989 00001B35 3EA04700            <1> 		  mov	  al, ds:fdc_ctrl_status+5  ; GET ENDING SECTOR
  1990 00001B39 7409                <1> 		  jz	  short	j45                 ; IF ON SAME CYL, THEN NO ADJUST
  1991                              <1> 		  ;mov	  bl, 8                     ; Get EOT Tracks per sector, byte 4 in parameter table in ah
  1992                              <1> 		  ;call	  get_parm???               ; The PC Jr doubles the parameter and if bit 1 is set sends to the FDC
  1993                              <1> 		                                    ; We just need sectors per track from the INT 1E Disk Parameter table
  1994 00001B3B C5367800            <1> 		  lds	  si,[1Eh*4]		        ; DS:SI -> INT 1Eh Disk Parameter Table Vector now in DS and si
  1995 00001B3F 8A6404              <1> 		  mov	  ah,byte [si+4]		    ; Get sectors per track
  1996 00001B42 88E0                <1> 		  mov	  al, ah                    ; Into al
  1997                              <1> j45:
  1998 00001B44 FEC0                <1> 		  inc	  al                        ; USE EOT+l FOR CALCULATION
  1999 00001B46 2A460A              <1> 		  sub	  al, [bp+int_13_cl]        ; SUBTRACT START SECTOR FROM END SECTOR
  2000                              <1> 		  ;mov	  [bp+0Eh], al              ; Check what this is??? Is used as temporary variable on stack, value is in AL anyway
  2001 00001B49 5E                  <1> 		  pop     si
  2002 00001B4A 1F                  <1> 		  pop     ds
  2003 00001B4B C3                  <1> 		  ret
  2004                              <1> 
  2005                              <1> ; ------------------------------------------------------
  2006                              <1> ; rw_opn
  2007                              <1> ;	 this routine performs read/write/verify operation
  2008                              <1> ;    Based on PC-Jr BIOS with all steps already taken
  2009                              <1> ;    care of removed and simplified.
  2010                              <1> ; Note jnn_m: labels match PC Jr BIOS for cross reference
  2011                              <1> ; ------------------------------------------------------
  2012                              <1> rw_opn:
  2013                              <1> 
  2014                              <1> ;********* BBPC This is where we need to start Non DMA code in BBPC - uses CX for address to jump to handle FDC data *****************
  2015                              <1> ;----- initialize cx for jump	after last parameter is	passed to nec
  2016 00001B4C 06                  <1> 		  push	  es					  ; Need to save this as seems to break checksum check and perhaps DOS
  2017 00001B4D 8A460F              <1> 		  mov	  al, [bp+int_13_ah]	  ; retreive command parameter
  2018 00001B50 A801                <1> 		  test	  al, 1		              ; is this and	odd numbered function write=3, read=2, verify=4
  2019 00001B52 7405                <1> 		  jz	  short	j16_1	          ; jump if not odd numbered
  2020 00001B54 B9[B61B]            <1> 		  mov	  cx, write_loop
  2021 00001B57 EB0C                <1> 		  jmp	  short	j16_3
  2022                              <1> j16_1:
  2023 00001B59 3C02                <1> 		  cmp	  al, 2		              ; is this a read?
  2024 00001B5B 7505                <1> 		  jnz	  short	j16_2	          ; jump if verify
  2025 00001B5D B9[911B]            <1> 		  mov	  cx, read_loop
  2026 00001B60 EB03                <1> 		  jmp	  short	j16_3
  2027                              <1> j16_2:
  2028 00001B62 B9[711B]            <1> 		  mov	  cx, verify_loop
  2029                              <1> j16_3:		  
  2030 00001B65 BAF403              <1>           mov     dx, fdc_status_reg ; Load IO Port for FDC Status port (0x03F4)
  2031 00001B68 FC                  <1> 		  cld
  2032                              <1> 
  2033                              <1> 		  ; call	  disable	  ; disable all	interrupts
  2034 00001B69 FA                  <1> 		  cli                 ; For now we don't need to worry about watch dog timer IRQ6 or Timer 0
  2035 00001B6A E89EFF              <1>           call    bound_setup ; This will adjust es:bx to give a 64K page, was called by disable
  2036 00001B6D 06                  <1> 		  push	  es          ; es:bx will have modified values for 64K range in bx
  2037 00001B6E 1F                  <1> 		  pop	  ds		  ; initialize ds for write
  2038 00001B6F FFE1                <1> 		  jmp	  cx		  ; jump to appropriate	r/w/v loop
  2039                              <1> 
  2040                              <1> ;----------------------------------------------------------------
  2041                              <1> ;***note***
  2042                              <1> ;	   data	is transferred using polling algorithms. these loops
  2043                              <1> ;	   transfer a data byte	at a time while	polling	FDC for
  2044                              <1> ;	   next	data byte and completion status
  2045                              <1> ;----------------------------------------------------------------
  2046                              <1> verify_loop:
  2047                              <1>           ; cx was used for address to jmp to so use ch as fdc_exec_mode and cl as fdc_stat_ready
  2048                              <1> 		  ; register/register tests are 3 clocks, register immediate are 5 clocks!
  2049 00001B71 B98020              <1> 		  mov	  cx, fdc_exec_mode * 256 + fdc_stat_ready
  2050                              <1> 		                             ; 0x80 less than 80 then will read status as not ready, Equal will be exec_mode=0
  2051 00001B74 BB[7C1B]            <1> 		  mov	  bx, j22_2          ; jmp to register is a few clock cycles faster
  2052                              <1> verify_loop1:
  2053 00001B77 EC                  <1> 		  in	  al, dx	         ; read master status register
  2054 00001B78 84E8                <1> 		  test	  al, ch		     ; has FDC entered execution phase yet?
  2055 00001B7A 74FB                <1> 		  jz	  short	verify_loop1 ; no, continue sampling
  2056                              <1> j22_2:
  2057 00001B7C 84C8                <1> 		  test	  al, cl			 ; fdc_stat_ready is data ready? (RQM)
  2058 00001B7E 7507                <1> 		  jnz	  short	j22_4	     ; jump if data transfer is ready
  2059 00001B80 EC                  <1> 		  in	  al, dx	         ; read status	port
  2060 00001B81 84E8                <1> 		  test	  al, ch			 ; are we done? In results mode if = 0
  2061 00001B83 75F7                <1> 		  jnz	  short	j22_2	     ; jump if more transfers = 1
  2062 00001B85 EB48                <1> 		  jmp	  short	op_end	     ; transfer done
  2063                              <1> j22_4:
  2064 00001B87 42                  <1> 		  inc	  dx		         ; point at FDC data register (0x03F5)
  2065 00001B88 EC                  <1> 		  in	  al, dx	         ; read data
  2066 00001B89 4A                  <1> 		  dec	  dx		         ; point at FDC status register (0x03F4)
  2067 00001B8A EC                  <1> 		  in	  al, dx	         ; read status	port
  2068 00001B8B 84E8                <1> 		  test	  al, ch  ; are we done? In results mode if = 0
  2069 00001B8D 75ED                <1> 		  jnz	  short	j22_2	     ; continue
  2070 00001B8F EB3E                <1> 		  jmp	  short	op_end	     ; we are done
  2071                              <1> ;------ read operation
  2072                              <1> read_loop:
  2073                              <1>           ; cx was used for address to jmp to so use ch as fdc_exec_mode and cl as fdc_stat_ready
  2074                              <1> 		  ; register/register tests are 3 clocks, register immediate are 5 clocks!
  2075 00001B91 B98020              <1> 		  mov	  cx, fdc_exec_mode * 256 + fdc_stat_ready
  2076                              <1> 		                             ; 0x80 less than 80 then will read status as not ready, Equal will be exec_mode=0
  2077 00001B94 BB[A91B]            <1> 		  mov	  bx, read_loop2     ; jmp to register is a few clock cycles faster
  2078                              <1> read_loop1:
  2079 00001B97 EC                  <1> 		  in	  al, dx	         ; read master status register
  2080 00001B98 84E8                <1> 		  test	  al, ch             ; fdc_exec_mode has FDC entered execution phase yet?
  2081 00001B9A 74FB                <1> 		  jz	  short	read_loop1   ; has not started execution phase yet check again
  2082 00001B9C EB01                <1> 		  jmp     short exec_start   ; Don't re-read status when exec mode starts otherwise we miss firstbyte
  2083                              <1> j22_5:
  2084 00001B9E EC                  <1> 		  in	  al, dx	         ; read status port
  2085                              <1> exec_start:
  2086 00001B9F 84C8                <1> 		  test	  al, cl             ; fdc_stat_ready is data ready? (RQM)
  2087 00001BA1 74FB                <1> 		  jz	  short j22_5 	     ; re-test status if not ready
  2088                              <1> first_read:                          ; For first read we won't check completion of exec mode		  
  2089 00001BA3 42                  <1> 		  inc	  dx		         ; point at FDC data register (0x03F5)
  2090 00001BA4 EC                  <1> 		  in	  al, dx	         ; read data from FDC
  2091 00001BA5 AA                  <1> 		  stosb			             ; transfer data to memory using ES:DI (set in bound_setup)
  2092 00001BA6 4A                  <1> 		  dec	  dx		         ; point at FDC status register (0x03F4)
  2093 00001BA7 00CD                <1> 		  add	 ch, cl				 ; Add the flags together in ch for TEST using Sign flag on D7
  2094                              <1> 
  2095                              <1> read_loop2:                          ; Second byte onwards check 
  2096 00001BA9 EC                  <1> 		  in	  al, dx	         ; read status port
  2097 00001BAA 84E8                <1> 		  test	  al, ch             ; Test with A0 Ready + Exec Mode if zero then finished reading requested sectors
  2098 00001BAC 7421                <1> 		  jz	  short	op_end       ; Ready=0 AND Exec_Mode=0 so results mode
  2099 00001BAE 79F9                <1> 		  jns	  short read_loop2   ; Jump Not Sign as if D7 (ready) is 1 then SF=1, SF=0 re-test status if not ready
  2100                              <1> 
  2101 00001BB0 42                  <1> 		  inc	  dx		         ; point at FDC data register (0x03F5)
  2102 00001BB1 EC                  <1> 		  in	  al, dx	         ; read data from FDC
  2103 00001BB2 AA                  <1> 		  stosb			             ; transfer data to memory using ES:DI (set in bound_setup)
  2104 00001BB3 4A                  <1> 		  dec	  dx		         ; point at FDC status register (0x03F4)
  2105 00001BB4 FFE3                <1> 		  jmp	  bx                 ; bx=read_loop2 continue with read operation
  2106                              <1> 
  2107                              <1> 
  2108                              <1> 
  2109                              <1> ;------ write	and format operation
  2110                              <1> write_loop:
  2111                              <1>           ; cx was used for address to jmp to so use ch as fdc_exec_mode and cl as fdc_stat_ready
  2112                              <1> 		  ; register/register tests are 3 clocks, register immediate are 5 clocks!
  2113 00001BB6 B520                <1> 		  mov	  ch, fdc_exec_mode
  2114 00001BB8 B1A0                <1> 		  mov	  cl, fdc_exec_mode + fdc_stat_ready
  2115                              <1> 		                             ; 0x80 less than 80 then will read status as not ready, Equal will be exec_mode=0
  2116 00001BBA BB[C21B]            <1> 		  mov	  bx, j22_7          ; jmp to register is a few clock cycles faster
  2117                              <1> 
  2118                              <1> write_loop1:
  2119 00001BBD EC                  <1> 		  in	  al, dx	         ; read master status register
  2120 00001BBE 84E8                <1> 		  test	  al, ch             ; fdc_exec_mode has FDC entered execution phase yet?
  2121 00001BC0 74FB                <1> 		  jz	  short	write_loop1  ; no, continue looping
  2122                              <1> j22_7:
  2123 00001BC2 EC                  <1> 		  in	  al, dx	         ; read status port
  2124 00001BC3 84C8                <1> 		  test	  al, cl	         ; is the FDC still in execution phase or ready sign not set if not ready?
  2125 00001BC5 7408                <1> 		  jz	  short	op_end	     ; jump if execution phase is done
  2126 00001BC7 79F9                <1> 		  jns	  short	j22_7	     ; Jump Not Sign as if D7 (ready) is 1 then SF=1, SF=0 re-test status if not ready
  2127 00001BC9 42                  <1> 		  inc	  dx		         ; point at data register
  2128 00001BCA AC                  <1> 		  lodsb			             ; transfer byte to FDC from memory using DS:SI (set in bound_setup)
  2129 00001BCB EE                  <1> 		  out	  dx, al	         ; write the byte on the diskette
  2130 00001BCC 4A                  <1> 		  dec	  dx		         ; point at the status register (0x03F4)
  2131 00001BCD FFE3                <1> 		  jmp	  bx	             ; continue with write (or format??)
  2132                              <1> ;------ transfer process is over
  2133                              <1> op_end:
  2134 00001BCF E852FF              <1> 		  call	  dss
  2135                              <1> 		  ;call	  enable
  2136 00001BD2 07                  <1> 		  pop	  es			     ; We have finished with ES now
  2137 00001BD3 FB                  <1> 		  sti
  2138                              <1> j17:
  2139 00001BD4 7241                <1> 		  jb	  short	j20_rw_err
  2140 00001BD6 E870FC              <1> 		  call	  fdc_get_result
  2141 00001BD9 723C                <1> 		  jb	  short	j20_rw_err
  2142                              <1> ;------ check	the results returned by	the controller
  2143 00001BDB FC                  <1> 		  cld
  2144 00001BDC BE4200              <1> 		  mov	  si, fdc_ctrl_status ; Point to FDC Status bytes set by results
  2145 00001BDF AC                  <1> 		  lodsb                       ; Load Status ST0
  2146 00001BE0 24C0                <1> 		  and	  al, 0C0h            ; Test for Normal Termination D7=0 & D6=0
  2147 00001BE2 745A                <1> 		  jz	  short	j22
  2148 00001BE4 3C40                <1> 		  cmp	  al, 40h             ; D6=1 Indicates command not completed sucessfully
  2149 00001BE6 7525                <1> 		  jnz	  short	j18_rw_nec_fail
  2150                              <1> ;----------------------------------------------------------------
  2151                              <1> ;***note***
  2152                              <1> ;	  the current system configuration has no DMA. in order	to
  2153                              <1> ;	  stop the FDC an eot must be passed to	force the FDC to halt.
  2154                              <1> ;	  therefore, the status	returned by the	FDC will always	show
  2155                              <1> ;	  an eot error.	If this	is the only error returned and the
  2156                              <1> ;	  number of sectors transferred	equals the number sectors
  2157                              <1> ;	  requested in this interrupt call then	the operatlon has
  2158                              <1> ;	  completed successfully. If an	eot error is returned and the
  2159                              <1> ;	  requested number of sectors is not the number	of sectors
  2160                              <1> ;	  transferred then the error is	legitimate. When the eot error
  2161                              <1> ;	  is invalid the status	bytes returned are updated to
  2162                              <1> ;	  reflect the status of	the operation as if DMA had been present
  2163                              <1> ;	  Not EOT is represented by End of Cylinder D7 in ST1
  2164                              <1> ;----------------------------------------------------------------
  2165                              <1> 
  2166 00001BE8 AC                  <1> 		  lodsb			             ; get Status ST1
  2167 00001BE9 3C80                <1> 		  cmp	  al, 80h            ; D7 End of Cylinder - is this the only error?
  2168 00001BEB 742C                <1> 		  jz	  short	j21_1	     ; normal termination,	no error
  2169 00001BED D0E0                <1> 		  shl	  al, 1		         ; not eot error, bypass error bits
  2170 00001BEF D0E0                <1> 		  shl	  al, 1
  2171 00001BF1 D0E0                <1> 		  shl	  al, 1		         ; test for crc error D5
  2172 00001BF3 B410                <1> 		  mov	  ah, fdc_e_crc
  2173 00001BF5 7218                <1> 		  jb	  short	j19_rw_fail  ; rw_fail
  2174 00001BF7 D0E0                <1> 		  shl	  al, 1		         ; test for DMA overrun D4
  2175 00001BF9 B408                <1> 		  mov	  ah, fdc_e_dma
  2176 00001BFB 7212                <1> 		  jb	  short	j19_rw_fail  ; rw_fail
  2177 00001BFD D0E0                <1> 		  shl	  al, 1
  2178 00001BFF D0E0                <1> 		  shl	  al, 1		         ; test for record not found D2
  2179 00001C01 B404                <1> 		  mov	  ah, fdc_e_notfound
  2180 00001C03 720A                <1> 		  jb	  short	j19_rw_fail  ; rw_fail
  2181 00001C05 D0E0                <1> 		  shl	  al, 1
  2182 00001C07 D0E0                <1> 		  shl	  al, 1		         ; test missing address mark D0
  2183 00001C09 B402                <1> 		  mov	  ah, fdc_e_address
  2184 00001C0B 7202                <1> 		  jb	  short	j19_rw_fail  ; rw_fail
  2185                              <1> ;------ FDC must have failed
  2186                              <1> j18_rw_nec_fail:
  2187 00001C0D B420                <1> 		  mov	  ah, fdc_e_failure  ; rw-nec-fail
  2188                              <1> j19_rw_fail:
  2189                              <1> 
  2190 00001C0F 3E08264100          <1> 		  or	  [ds:fdc_last_error], ah ; Set error bits in FDC error status
  2191 00001C14 E815FF              <1> 		  call	  num_trans	         ; how many were really transferred
  2192                              <1> j20_rw_err:
  2193 00001C17 F9                  <1>           stc                        ; Need to indicate error, ah has error No.
  2194 00001C18 C3                  <1> 		  ret			             ; return to caller
  2195                              <1> ;------ operation was	successful
  2196                              <1> j21_1:
  2197 00001C19 8A5E0A              <1> 		  mov	  bl, [bp+int_13_cl]	     ; get number of sectors pass from stack  - int_13_cl PC Jr has different offsets to BP!
  2198 00001C1C E80DFF              <1> 		  call	  num_trans	         ; how many got moved, al contains number of sectors
  2199 00001C1F 38C3                <1> 		  cmp	  bl, al             ; number requested == number of actually transferred ?
  2200 00001C21 740E                <1> 		  jz	  short	j21_2	     ; transfer successful
  2201                              <1> ;------ operation attempted to access data past eot. this is a real error
  2202                              <1> 
  2203 00001C23 3E800E410004        <1> 		  or	  byte [ds:fdc_last_error], fdc_e_notfound ; record	not found
  2204 00001C29 3EC606430080        <1> 		  mov	  byte [ds:fdc_ctrl_status+1], fdc_e_timeout ; ST1 gets correct value
  2205 00001C2F F9                  <1> 		  stc
  2206 00001C30 C3                  <1> 		  ret
  2207                              <1> j21_2:
  2208 00001C31 30E4                <1> 		  xor	  ah, ah	         ; clear ah for FDC_status update (was ax but al has sector count in it)
  2209 00001C33 31F6                <1> 		  xor	  si, si             ; index to FDC status array
  2210 00001C35 886442              <1> 		  mov	  [si+fdc_ctrl_status], ah ; zero out byte, ST0
  2211 00001C38 46                  <1> 		  inc	  si		         ; point index at second byte
  2212 00001C39 886442              <1> 		  mov	  [si+fdc_ctrl_status], ah ; zero out byte, ST1
  2213 00001C3C EB03                <1> 		  jmp	  short	j21_3_opn_ok
  2214                              <1> j22:
  2215 00001C3E E8EBFE              <1> 		  call	  num_trans
  2216                              <1> j21_3_opn_ok:
  2217 00001C41 30E4                <1> 		  xor	  ah, ah	  ; no errors
  2218 00001C43 C3                  <1> 		  ret
   275                                  %ifdef AT_KEYBOARD
   276                                  %include	"at_kbc.inc"		; keyboard controller functions
     1                              <1> ;=========================================================================
     2                              <1> ; at_kbc.inc - AT style keyboard controller support
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25                              <1> ;=========================================================================
    26                              <1> ; Keyboard controller defines - ports, commands, and flags
    27                              <1> ;-------------------------------------------------------------------------
    28                              <1> kbc_data_reg	equ	60h
    29                              <1> ; keyboard controller return codes
    30                              <1> kbc_ret_test	equ	0AAh	; keyboard controller test passed
    31                              <1> ; keyboard controller status register and its bits
    32                              <1> kbc_status_reg	equ	64h
    33                              <1> kbc_stat_obf	equ	01h	; output buffer full flag
    34                              <1> kbc_stat_ibf	equ	02h	; input buffer full flag
    35                              <1> kbc_stat_aobf	equ	20h	; auxiliary output buffer full flag
    36                              <1> kbc_stat_tout	equ	40h	; receive/transmit timeout
    37                              <1> kbc_stat_perr	equ	80h	; parity error
    38                              <1> ; keyboard contoller command register and commands
    39                              <1> kbc_command_reg	equ	64h
    40                              <1> kbc_cmd_rd_ctr	equ	20h	; read controller configuration byte command
    41                              <1> kbc_cmd_wr_ctr	equ	60h	; write controller configruation byte command
    42                              <1> kbc_cmd_aux_dis	equ	0A7h	; disable auxiliary interface command
    43                              <1> kbc_cmd_aux_ena	equ	0A8h	; enable auxiliary interface command
    44                              <1> kbc_cmd_aux_tst	equ	0A9h	; test auxiliary interface command
    45                              <1> kbc_cmd_test	equ	0AAh	; keyboard controller self-test command
    46                              <1> kbc_cmd_kbd_tst	equ	0ABh	; test keyboard interface command
    47                              <1> kbc_cmd_kbd_dis	equ	0ADh	; disable keyboard interface command
    48                              <1> kbc_cmd_kbd_ena	equ	0AEh	; enable keyboard interface command
    49                              <1> kbc_cmd_rd_in	equ	0C0h	; read keyboard input port
    50                              <1> kbc_cmd_aux_snd	equ	0D4h	; send command byte to auxiliary device command
    51                              <1> ; keyboard controller control register bits
    52                              <1> kbc_ctr_kbd_int	equ	01h	; enable keyboard OBF interrupt
    53                              <1> kbc_ctr_aux_int	equ	02h	; enable auxiliary OBF interrupt
    54                              <1> kbc_ctr_no_lock	equ	08h	; ignore keyboard inhibit (keyboard lock)
    55                              <1> kbc_ctr_kbd_dis	equ	10h	; disable keyboard interface
    56                              <1> kbc_ctr_aux_dis equ	20h	; disable auxiliary interface
    57                              <1> kbc_ctr_xlat	equ	40h	; enable keyboard scancode translation
    58                              <1> ; keyboard controller input port bits
    59                              <1> kbc_in_display	equ	40h	; input port bit 6: 0 = MDA, 1 = CGA
    60                              <1> ; keyboard controller response timeout in 60us units
    61                              <1> kbc_ctr_timeout	equ     20000	; 1.2 seconds
    62                              <1> ; keyboard and auxiliary device commands
    63                              <1> aux_cmd_scale11	equ	0E6h	; auxiliary device set 1:1 scaling factor
    64                              <1> aux_cmd_scale21	equ	0E7h	; auxiliary device set 2:1 scaling factor
    65                              <1> aux_cmd_resol	equ	0E8h	; auxiliary device set resolution
    66                              <1> aux_cmd_status	equ	0E9h	; auxiliary device get status
    67                              <1> kbd_cmd_leds	equ	0EDh	; keyboard set LEDs
    68                              <1> dev_cmd_dev_id	equ	0F2h	; read device ID
    69                              <1> dev_cmd_rate	equ	0F3h	; keyboard set typematic rate/delay
    70                              <1> 				; auxiliary device set sample rate
    71                              <1> dev_cmd_enable	equ	0F4h	; device enable
    72                              <1> dev_cmd_disable	equ	0F5h	; device disable
    73                              <1> dev_cmd_reset	equ	0FFh	; reset and self-test
    74                              <1> ; keyboard and auxiliary device responses
    75                              <1> dev_rsp_bat_ok	equ	0AAh	; basic assurance test is OK
    76                              <1> dev_rsp_ack	equ	0FAh	; acknowledge
    77                              <1> dev_rsp_error	equ	0FCh	; error (basic assurance test failed)
    78                              <1> dev_rsp_resend	equ	0FEh	; resend (invalid command or argument)
    79                              <1> 
    80                              <1> ;=========================================================================
    81                              <1> ; kbc_kb_send - send command to keyboard, wait for acknowledge
    82                              <1> ; Input:
    83                              <1> ;	AL = command
    84                              <1> ; Output:
    85                              <1> ;	none
    86                              <1> ;-------------------------------------------------------------------------
    87                              <1> kbc_kb_send:
    88 00001C44 50                  <1> 	push	ax
    89 00001C45 51                  <1> 	push	cx
    90 00001C46 88C4                <1> 	mov	ah,al			; save command to AH
    91 00001C48 B90300              <1> 	mov	cx,3			; try 3 times
    92                              <1> 
    93                              <1> .retry:
    94 00001C4B 51                  <1> 	push	cx
    95 00001C4C FA                  <1> 	cli
    96                              <1> ; clear the Error, Acknowledge received, and resend received flags
    97 00001C4D 802697004F          <1> 	and	byte [kbd_flags_4],4Fh
    98 00001C52 31C9                <1> 	xor	cx,cx
    99                              <1> 
   100                              <1> .2:					; wait for KBC to empty input buffer
   101 00001C54 E464                <1> 	in	al,kbc_status_reg
   102 00001C56 A802                <1> 	test	al,kbc_stat_ibf
   103 00001C58 E0FA                <1> 	loopnz	.2
   104                              <1> 
   105 00001C5A 88E0                <1> 	mov	al,ah
   106 00001C5C E660                <1> 	out	kbc_data_reg,al		; send command to the keyboard
   107 00001C5E FB                  <1> 	sti
   108 00001C5F 31C9                <1> 	xor	cx,cx
   109                              <1> .wait_for_ack:				; wait for acknowledge (set by IRQ1 ISR)
   110 00001C61 F606970010          <1> 	test	byte [kbd_flags_4], 10h	; acknowledge bit set?
   111 00001C66 E1F9                <1> 	loopz	.wait_for_ack
   112 00001C68 59                  <1> 	pop	cx
   113 00001C69 7507                <1> 	jnz	.exit
   114 00001C6B E2DE                <1> 	loop	.retry			; try again
   115                              <1> ; if the operation failed after 3 retries, set the error bit and quit
   116 00001C6D 800E970080          <1> 	or	byte [kbd_flags_4], 80h
   117                              <1> .exit:
   118 00001C72 59                  <1> 	pop	cx
   119 00001C73 58                  <1> 	pop	ax
   120 00001C74 C3                  <1> 	ret
   121                              <1> 
   122                              <1> ;=========================================================================
   123                              <1> ; kbc_send_cmd - send command + argument to keyboard controller
   124                              <1> ; Input:
   125                              <1> ;	AL - command byte
   126                              <1> ;	AH = argument
   127                              <1> ; Output:
   128                              <1> ;	CF == 0 - no error
   129                              <1> ;	CF == 1 - timeout
   130                              <1> ;-------------------------------------------------------------------------
   131                              <1> kbc_send_cmd:
   132 00001C75 E80A00              <1> 	call	kbc_write_command
   133 00001C78 7207                <1> 	jc	.exit
   134 00001C7A 86C4                <1> 	xchg	al,ah
   135 00001C7C E80B00              <1> 	call	kbc_write_data
   136 00001C7F 86C4                <1> 	xchg	al,ah
   137                              <1> .exit:
   138 00001C81 C3                  <1> 	ret
   139                              <1> 
   140                              <1> ;=========================================================================
   141                              <1> ; kbc_write_command - send command byte to keyboard controller
   142                              <1> ; Input:
   143                              <1> ;	AL - command byte
   144                              <1> ; Output:
   145                              <1> ;	CF == 0 - no error
   146                              <1> ;	CF == 1 - timeout
   147                              <1> ;-------------------------------------------------------------------------
   148                              <1> kbc_write_command:
   149 00001C82 E80D00              <1> 	call	kbc_wait_write
   150 00001C85 7202                <1> 	jc	.timeout		; CF == 1 - timeout
   151 00001C87 E664                <1> 	out	kbc_command_reg,al	; write command
   152                              <1> 
   153                              <1> .timeout:
   154 00001C89 C3                  <1> 	ret
   155                              <1> 
   156                              <1> ;=========================================================================
   157                              <1> ; kbc_write_data - write byte to keyboard controller data register (0x60)
   158                              <1> ; Input:
   159                              <1> ;	AL - command byte
   160                              <1> ; Output:
   161                              <1> ;	CF == 0 - no error
   162                              <1> ;	CF == 1 - timeout
   163                              <1> ;-------------------------------------------------------------------------
   164                              <1> kbc_write_data:
   165 00001C8A E80500              <1> 	call	kbc_wait_write
   166 00001C8D 7202                <1> 	jc	.timeout		; CF == 1 - timeout
   167 00001C8F E660                <1> 	out	kbc_data_reg,al		; write data register
   168                              <1> 
   169                              <1> .timeout:
   170 00001C91 C3                  <1> 	ret
   171                              <1> 
   172                              <1> ;=========================================================================
   173                              <1> ; kbc_wait_write - wait for keyboard controller input buffer to be empty
   174                              <1> ; Input:
   175                              <1> ;	none
   176                              <1> ; Output:
   177                              <1> ;	CF == 0 - no error, input buffer is empty
   178                              <1> ;	CF == 1 - timeout
   179                              <1> ;-------------------------------------------------------------------------
   180                              <1> kbc_wait_write:
   181 00001C92 50                  <1> 	push	ax
   182 00001C93 51                  <1> 	push	cx
   183 00001C94 B9204E              <1> 	mov	cx,kbc_ctr_timeout
   184                              <1> 					; wait for KBC to empty input buffer
   185                              <1> .wait:
   186 00001C97 E464                <1> 	in	al,kbc_status_reg
   187 00001C99 A802                <1> 	test	al,kbc_stat_ibf
   188 00001C9B 740B                <1> 	jz	.exit			; note: test instruction sets CF=0
   189 00001C9D 51                  <1> 	push	cx
   190 00001C9E B90400              <1> 	mov	cx,4
   191 00001CA1 E86EF5              <1> 	call	delay_15us		; 45-60us I/O delay
   192 00001CA4 59                  <1> 	pop	cx
   193 00001CA5 E2F0                <1> 	loop	.wait
   194 00001CA7 F9                  <1> 	stc				; CF=1 - timeout
   195                              <1> .exit:
   196 00001CA8 59                  <1> 	pop	cx
   197 00001CA9 58                  <1> 	pop	ax
   198 00001CAA C3                  <1> 	ret
   199                              <1> 
   200                              <1> ;=========================================================================
   201                              <1> ; kbc_data_read - wait for data in keyboard controller output buffer
   202                              <1> ;                 and read it
   203                              <1> ; Input:
   204                              <1> ;	none
   205                              <1> ; Output:
   206                              <1> ;	AL = data from the keyboard controller
   207                              <1> ;	AH = keyboard controller status register
   208                              <1> ;	CF == 0 - no error, data is available
   209                              <1> ;	CF == 1 - KBC timeout
   210                              <1> ;-------------------------------------------------------------------------
   211                              <1> kbc_data_read:
   212 00001CAB 51                  <1> 	push	cx
   213 00001CAC B9204E              <1> 	mov	cx,kbc_ctr_timeout
   214                              <1> 					; wait for data
   215                              <1> .wait:
   216 00001CAF E464                <1> 	in	al,kbc_status_reg
   217 00001CB1 88C4                <1> 	mov	ah,al
   218 00001CB3 F6C401              <1> 	test	ah,kbc_stat_obf
   219 00001CB6 750D                <1> 	jnz	.read_data		; note: test instruction sets CF=0
   220 00001CB8 51                  <1> 	push	cx
   221 00001CB9 B90400              <1> 	mov	cx,4
   222 00001CBC E853F5              <1> 	call	delay_15us		; 45-60us I/O delay
   223 00001CBF 59                  <1> 	pop	cx
   224 00001CC0 E2ED                <1> 	loop	.wait
   225 00001CC2 F9                  <1> 	stc				; CF=1 - timeout
   226 00001CC3 EB07                <1> 	jmp	.exit
   227                              <1> .read_data:
   228 00001CC5 E460                <1> 	in	al,kbc_data_reg
   229                              <1> 					; check for receive/transmit timeout
   230                              <1> 					; and parity errors
   231 00001CC7 F6C4C0              <1> 	test	ah,kbc_stat_tout | kbc_stat_perr
   232 00001CCA 75E3                <1> 	jnz	.wait			; note: test instruction sets CF=0
   233                              <1> .exit:
   234 00001CCC 59                  <1> 	pop	cx
   235 00001CCD C3                  <1> 	ret
   236                              <1> 
   237                              <1> %ifdef PS2_MOUSE
   238                              <1> ;=========================================================================
   239                              <1> ; kbc_aux_read - read data from auxiliary device
   240                              <1> ; Input:
   241                              <1> ;	none
   242                              <1> ; Output:
   243                              <1> ;	AL = data
   244                              <1> ;	AH = keyboard controller status register
   245                              <1> ;	CF == 0 - no error
   246                              <1> ;	CF == 1 - timeout
   247                              <1> ;-------------------------------------------------------------------------
   248                              <1> kbc_aux_read:
   249 00001CCE E8DAFF              <1> 	call	kbc_data_read
   250 00001CD1 7206                <1> 	jc	.exit			; CF==1 - timeout
   251 00001CD3 F6C420              <1> 	test	ah,kbc_stat_aobf	; data from auxiliary device?
   252 00001CD6 7501                <1> 	jnz	.exit			; note: test instruction sets CF=0
   253 00001CD8 F9                  <1> 	stc				; no auxiliary data, set CF=1
   254                              <1> .exit:
   255 00001CD9 C3                  <1> 	ret
   256                              <1> 
   257                              <1> ;=========================================================================
   258                              <1> ; kbc_aux_send - send command to auxiliary device, wait for acknowledge
   259                              <1> ; Input:
   260                              <1> ;	AL = command
   261                              <1> ; Output:
   262                              <1> ;	AH - status:
   263                              <1> ;		00h - success
   264                              <1> ;		03h - interface error (timeout)
   265                              <1> ;		04h - resend requested
   266                              <1> ;	CF == 0 - no error
   267                              <1> ;	CF == 1 - error
   268                              <1> ;-------------------------------------------------------------------------
   269                              <1> kbc_aux_send:
   270 00001CDA 51                  <1> 	push	cx
   271 00001CDB 88C4                <1> 	mov	ah,al			; store command to AH
   272 00001CDD B0D4                <1> 	mov	al,kbc_cmd_aux_snd	; write byte to auxiliary device
   273 00001CDF E893FF              <1> 	call	kbc_send_cmd
   274 00001CE2 7214                <1> 	jc	.timeout		; kbc_send_cmd timed out
   275 00001CE4 E8E7FF              <1> 	call	kbc_aux_read		; read acknowledge from device
   276 00001CE7 720F                <1> 	jc	.timeout		; no reply - timeout
   277 00001CE9 3CFA                <1> 	cmp	al,dev_rsp_ack
   278 00001CEB 7406                <1> 	je	.ok
   279 00001CED 3CFE                <1> 	cmp	al,dev_rsp_resend
   280 00001CEF 740B                <1> 	je	.resend
   281                              <1> ; Optimization: any other responses result in timeout/interface error
   282                              <1> ;	cmp	al,dev_rsp_error
   283                              <1> ;	je	.timeout		; treat as timeout/interface error
   284 00001CF1 EB05                <1> 	jmp	.timeout
   285                              <1> 
   286                              <1> .ok:
   287 00001CF3 B000                <1> 	mov	al,00h			; success - ACK received
   288 00001CF5 F8                  <1> 	clc
   289 00001CF6 EB07                <1> 	jmp	.exit
   290                              <1> 
   291                              <1> .timeout:
   292 00001CF8 B003                <1> 	mov	al,03h			; interface error
   293 00001CFA EB02                <1> 	jmp	.error
   294                              <1> 
   295                              <1> .resend:
   296 00001CFC B004                <1> 	mov	al,04h			; resend
   297                              <1> 
   298                              <1> .error:
   299 00001CFE F9                  <1> 	stc
   300                              <1> 
   301                              <1> .exit:
   302 00001CFF 86E0                <1> 	xchg	ah,al			; status to AH, original command to AL
   303 00001D01 59                  <1> 	pop	cx
   304 00001D02 C3                  <1> 	ret
   305                              <1> 
   306                              <1> ;=========================================================================
   307                              <1> ; kbc_aux_enable - enable auxiliary device
   308                              <1> ; Input:
   309                              <1> ;	none
   310                              <1> ; Output:
   311                              <1> ;	CF = 0 - no error
   312                              <1> ;	CF = 1 - KBC timeout
   313                              <1> ;-------------------------------------------------------------------------
   314                              <1> kbc_aux_enable:
   315 00001D03 50                  <1> 	push	ax
   316 00001D04 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
   317 00001D06 B44F                <1> 	mov	ah,01001111b
   318                              <1> ;		   |||||||`-- 1 == enable OBF interrupt for keyboard (IRQ1)
   319                              <1> ;                  ||||||`-- 1 == enable OBF interrupt for aux port (IRQ12)
   320                              <1> ;		   |||||`-- 1 == POST complete
   321                              <1> ;                  ||||`-- 1 == disable the keyboard inhibit
   322                              <1> ;                  |||`-- 0 == enable keyboard interface
   323                              <1> ;		   ||`-- 0 == enable mouse interface
   324                              <1> ;		   |`-- 1 == enable scancode translation
   325                              <1> ;		   `-- 0 == reserved, must be 0
   326 00001D08 E86AFF              <1> 	call	kbc_send_cmd
   327 00001D0B 58                  <1> 	pop	ax
   328 00001D0C C3                  <1> 	ret
   329                              <1> 
   330                              <1> ;=========================================================================
   331                              <1> ; kbc_aux_disable - disable auxiliary device
   332                              <1> ; Input:
   333                              <1> ;	none
   334                              <1> ; Output:
   335                              <1> ;	CF = 0 - no error
   336                              <1> ;	CF = 1 - KBC timeout
   337                              <1> ;-------------------------------------------------------------------------
   338                              <1> kbc_aux_disable:
   339 00001D0D 50                  <1> 	push	ax
   340 00001D0E B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
   341 00001D10 B46D                <1> 	mov	ah,01101101b
   342                              <1> ;		   |||||||`-- 1 == enable OBF interrupt for keyboard (IRQ1)
   343                              <1> ;                  ||||||`-- 0 == disable OBF interrupt for aux port (IRQ12)
   344                              <1> ;		   |||||`-- 1 == POST complete
   345                              <1> ;                  ||||`-- 1 == disable the keyboard inhibit
   346                              <1> ;                  |||`-- 0 == enable keyboard interface
   347                              <1> ;		   ||`-- 1 == disable mouse interface
   348                              <1> ;		   |`-- 1 == enable scancode translation
   349                              <1> ;		   `-- 0 == reserved, must be 0
   350 00001D12 E860FF              <1> 	call	kbc_send_cmd
   351 00001D15 58                  <1> 	pop	ax
   352 00001D16 C3                  <1> 	ret
   353                              <1> 
   354                              <1> %endif ; PS2_MOUSE
   355                              <1> 
   356                              <1> ;=========================================================================
   357                              <1> ; kbc_flush - flush all input data from i8042 buffer
   358                              <1> ; Input:
   359                              <1> ;	none
   360                              <1> ; Output:
   361                              <1> ;	CF = 0 - flushed successfully
   362                              <1> ;	CF = 1 - can't flush after 20 retries, probably no hardware
   363                              <1> ;-------------------------------------------------------------------------
   364                              <1> kbc_flush:
   365 00001D17 50                  <1> 	push	ax
   366 00001D18 51                  <1> 	push	cx
   367 00001D19 B91400              <1> 	mov	cx,20			; maximal KBC buffer size
   368                              <1> .flush_next_byte:
   369 00001D1C E464                <1> 	in	al,kbc_status_reg
   370 00001D1E A801                <1> 	test	al,kbc_stat_obf
   371 00001D20 740F                <1> 	jz	.flushed
   372 00001D22 51                  <1> 	push	cx
   373 00001D23 B90400              <1> 	mov	cx,4
   374 00001D26 E8E9F4              <1> 	call	delay_15us		; 45-60us I/O delay
   375 00001D29 59                  <1> 	pop	cx
   376 00001D2A E460                <1> 	in	al,kbc_data_reg
   377 00001D2C E2EE                <1> 	loop	.flush_next_byte
   378 00001D2E F9                  <1> 	stc				; unable to flush KBC
   379 00001D2F EB01                <1> 	jmp	.exit
   380                              <1> .flushed:
   381 00001D31 F8                  <1> 	clc
   382                              <1> .exit:
   383 00001D32 59                  <1> 	pop	cx
   384 00001D33 58                  <1> 	pop	ax
   385 00001D34 C3                  <1> 	ret
   386                              <1> 
   387                              <1> ;=========================================================================
   388                              <1> ; kbc_init - Initialize keyboard controller
   389                              <1> ;-------------------------------------------------------------------------
   390                              <1> kbc_init:
   391 00001D35 50                  <1> 	push	ax
   392 00001D36 51                  <1> 	push	cx
   393 00001D37 52                  <1> 	push	dx
   394                              <1> 
   395                              <1> ;-------------------------------------------------------------------------
   396                              <1> ; Flush the data from keyboard controller output buffer
   397                              <1> 
   398 00001D38 E8DCFF              <1> 	call	kbc_flush
   399 00001D3B 7303E9F500          <1> 	jc	kbc_flush_fail
   400                              <1> 
   401                              <1> ;-------------------------------------------------------------------------
   402                              <1> ; Disable keyboard and mouse interfaces so that they don't interfere with tests
   403                              <1> ; No error handling here. The controller and the keyboard are tested later
   404                              <1> 
   405 00001D40 B470                <1> 	mov	ah,01110000b
   406                              <1> ;		   |||||||`-- 0 == disable OBF interrupt for keyboard (IRQ1)
   407                              <1> ;		   ||||||`-- 0 == disable OBF interrupt for aux port (IRQ12)
   408                              <1> ;		   |||||`-- 0 == power on / POST in progress
   409                              <1> ;		   ||||`-- 0 == reserved, must be 0
   410                              <1> ;		   |||`-- 1 == disable keyboard interface
   411                              <1> ;		   ||`-- 1 == disable auxiliary interface
   412                              <1> ;		   |`-- 1 == enable scan code translation to IBM PC scan codes
   413                              <1> ;		   `-- 0 == reserved, must be 0
   414                              <1> 
   415 00001D42 B060                <1> 	mov	al,kbc_cmd_wr_ctr	; write controller configuration byte
   416 00001D44 E82EFF              <1> 	call	kbc_send_cmd
   417                              <1> 
   418                              <1> ;-------------------------------------------------------------------------
   419                              <1> ; Run keyboard controller self-test
   420                              <1> 
   421 00001D47 B662                <1> 	mov	dh,e_kbc_test_fail
   422 00001D49 B201                <1> 	mov	dl,e_kbd_tout_fail
   423 00001D4B B0AA                <1> 	mov	al,kbc_cmd_test		; send KBC self test command
   424 00001D4D E832FF              <1> 	call 	kbc_write_command
   425 00001D50 720D                <1> 	jc	.kbc_test_error
   426                              <1> 
   427 00001D52 B202                <1> 	mov	dl,e_kbd_resp_fail
   428 00001D54 E854FF              <1> 	call	kbc_data_read		; wait and read the response
   429 00001D57 7206                <1> 	jc	.kbc_test_error
   430 00001D59 B262                <1> 	mov	dl,e_kbc_test_fail
   431 00001D5B 3C55                <1> 	cmp	al,55h			; check for success
   432 00001D5D 7403                <1> 	je	.kbc_test_ok
   433                              <1> 
   434                              <1> .kbc_test_error:
   435 00001D5F E8E100              <1> 	call	kbd_key_fail		; show the error on the POST display
   436                              <1> 
   437                              <1> .kbc_test_ok:
   438                              <1> 
   439                              <1> ;-------------------------------------------------------------------------
   440                              <1> ; Run keyboard interface test
   441                              <1> 
   442 00001D62 B663                <1> 	mov	dh,e_kbc_int_fail
   443 00001D64 B201                <1> 	mov	dl,e_kbd_tout_fail
   444 00001D66 B0AB                <1> 	mov	al,kbc_cmd_kbd_tst	; send test keyboard interface command
   445 00001D68 E817FF              <1> 	call	kbc_write_command
   446 00001D6B 720D                <1> 	jc	.keyboard_interface_error
   447                              <1> 
   448 00001D6D B202                <1> 	mov	dl,e_kbd_resp_fail
   449 00001D6F E839FF              <1> 	call	kbc_data_read		; wait and read test result
   450 00001D72 7206                <1> 	jc	.keyboard_interface_error
   451 00001D74 B207                <1> 	mov	dl,e_kbd_int_fail
   452 00001D76 3C00                <1> 	cmp	al,0			; check for success
   453 00001D78 7403                <1> 	je	.keyboard_interface_ok
   454                              <1> 
   455                              <1> .keyboard_interface_error:
   456 00001D7A E8C600              <1> 	call	kbd_key_fail		; show the error on the POST display
   457                              <1> 
   458                              <1> .keyboard_interface_ok:
   459                              <1> 
   460                              <1> ;-------------------------------------------------------------------------
   461                              <1> ; Read display type and set equipment bits accordingly
   462                              <1> ; No error handling here. In the worst case the display settings will be wrong
   463                              <1> 
   464 00001D7D B0C0                <1> 	mov	al,kbc_cmd_rd_in	; send read input port command
   465 00001D7F E800FF              <1> 	call	kbc_write_command
   466                              <1> 
   467 00001D82 E826FF              <1> 	call	kbc_data_read		; wait and read input port value
   468 00001D85 A840                <1> 	test	al,kbc_in_display
   469 00001D87 7507                <1> 	jnz	.get_disp_color		; input port bit 6 set => CGA display
   470 00001D89 830E100030          <1> 	or	word [equipment_list],equip_mono
   471 00001D8E EB05                <1> 	jmp	.get_disp_done
   472                              <1> .get_disp_color:
   473 00001D90 830E100020          <1> 	or	word [equipment_list],equip_color_80
   474                              <1> .get_disp_done:
   475                              <1> 
   476                              <1> ;-------------------------------------------------------------------------
   477                              <1> ; Enable keyboard interface
   478                              <1> 
   479 00001D95 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; send enable keyboard interface cmd
   480 00001D97 E8E8FE              <1> 	call	kbc_write_command
   481 00001D9A 7303E99D00          <1> 	jc	kbc_cmd_fail
   482                              <1> 
   483                              <1> ;-------------------------------------------------------------------------
   484                              <1> ; Check that BAT (Basic Assurance Test) is OK:
   485                              <1> 
   486                              <1> ; Someone at IBM thought that it is a really clever idea that the keyboard
   487                              <1> ; would send a BAT (Basic Assurance Test) OK code (0AAh) after the power on
   488                              <1> ; And yet, not all keyboards do, at least not always...
   489                              <1> ; Also keyboards do not reset themself on the system reset/reboot...
   490                              <1> ; Also some keyboard controllers (VIA VT82C42 particularly)
   491                              <1> ; seem to fake BAT OK code on the power on...
   492                              <1> 
   493                              <1> ; check for BAT code in the buffer, and if it is not there -
   494                              <1> ; issue a keyboard reset command
   495                              <1> 
   496 00001D9F E809FF              <1> 	call	kbc_data_read		; check for BAT code in the buffer
   497 00001DA2 7204                <1> 	jc	.keyboard_reset		; timeout - reset the keyboard
   498 00001DA4 3CAA                <1> 	cmp	al,dev_rsp_bat_ok
   499 00001DA6 7428                <1> 	je	.keyboard_bat_ok	; all good, do not reset the keyboard
   500                              <1> 
   501                              <1> .keyboard_reset:
   502 00001DA8 B670                <1> 	mov	dh,e_kbd_bat_fail	; major error number
   503 00001DAA B201                <1> 	mov	dl,e_kbd_tout_fail	; minor error number
   504 00001DAC B0FF                <1> 	mov	al,dev_cmd_reset
   505 00001DAE E8D9FE              <1> 	call	kbc_write_data		; send reset command to the keyboard
   506 00001DB1 721A                <1> 	jc	.keyboard_reset_error
   507                              <1> 
   508 00001DB3 B202                <1> 	mov	dl,e_kbd_resp_fail	; minor error number
   509 00001DB5 E8F3FE              <1> 	call	kbc_data_read		; wait for ACK
   510 00001DB8 7213                <1> 	jc	.keyboard_reset_error
   511 00001DBA B203                <1> 	mov	dl,e_kbd_nack_fail	; minor error number
   512 00001DBC 3CFA                <1> 	cmp	al,dev_rsp_ack
   513 00001DBE 750D                <1> 	jne	.keyboard_reset_error
   514                              <1> 
   515 00001DC0 B204                <1> 	mov	dl,e_kbd_rsp2_fail	; minor error number
   516 00001DC2 E8E6FE              <1> 	call	kbc_data_read
   517 00001DC5 7206                <1> 	jc	.keyboard_reset_error
   518 00001DC7 B205                <1> 	mov	dl,e_kbd_nbat_fail	; minor error number
   519 00001DC9 3CAA                <1> 	cmp	al,dev_rsp_bat_ok
   520 00001DCB 7403                <1> 	je	.keyboard_bat_ok	; BAT received, continue
   521                              <1> 
   522                              <1> .keyboard_reset_error:
   523 00001DCD E87300              <1> 	call	kbd_key_fail		; show the error on the POST display
   524                              <1> 
   525                              <1> .keyboard_bat_ok:
   526                              <1> 
   527                              <1> ;-------------------------------------------------------------------------
   528                              <1> ; Disable keyboard
   529                              <1> 
   530 00001DD0 B671                <1> 	mov	dh,e_kbd_dis_fail	; major error number
   531 00001DD2 B201                <1> 	mov	dl,e_kbd_tout_fail	; minor error number
   532 00001DD4 B0F5                <1> 	mov	al,dev_cmd_disable
   533 00001DD6 E8B1FE              <1> 	call	kbc_write_data		; send keyboard disable command
   534 00001DD9 720D                <1> 	jc	.keyboard_disable_error
   535                              <1> 
   536 00001DDB B202                <1> 	mov	dl,e_kbd_resp_fail	; minor error number
   537 00001DDD E8CBFE              <1> 	call	kbc_data_read		; wait for ACK
   538 00001DE0 7206                <1> 	jc	.keyboard_disable_error
   539 00001DE2 B203                <1> 	mov	dl,e_kbd_nack_fail	; minor error number
   540 00001DE4 3CFA                <1> 	cmp	al,dev_rsp_ack
   541 00001DE6 7403                <1> 	je	.keyboard_disable_ok	; ACK received, continue
   542                              <1> 
   543                              <1> .keyboard_disable_error:
   544 00001DE8 E85800              <1> 	call	kbd_key_fail		; show the error on the POST display
   545                              <1> 
   546                              <1> .keyboard_disable_ok:
   547                              <1> 
   548                              <1> %ifdef PS2_MOUSE
   549                              <1> ;-------------------------------------------------------------------------
   550                              <1> ; Enable auxiliary port and check for PS/2 mouse presence
   551                              <1> 
   552 00001DEB B0A8                <1> 	mov	al,kbc_cmd_aux_ena	; send enable auxiliary interface cmd
   553 00001DED E892FE              <1> 	call	kbc_write_command
   554                              <1> 
   555 00001DF0 B0FF                <1> 	mov	al,dev_cmd_reset
   556 00001DF2 E8E5FE              <1> 	call	kbc_aux_send
   557 00001DF5 80FC00              <1> 	cmp	ah,00h			; was the command sent successfully?
   558 00001DF8 7513                <1> 	jne	.no_mouse
   559                              <1> 
   560 00001DFA E8D1FE              <1> 	call	kbc_aux_read
   561 00001DFD 720E                <1> 	jc	.no_mouse
   562 00001DFF 3CAA                <1> 	cmp	al,dev_rsp_bat_ok	; Basic Assurance Test successful?
   563 00001E01 750A                <1> 	jne	.no_mouse
   564 00001E03 E8C8FE              <1> 	call	kbc_aux_read		; read and throw away Mouse ID
   565 00001E06 7205                <1> 	jc	.no_mouse
   566                              <1> ; mouse reset was successful, update equipment word accordingly
   567 00001E08 830E100004          <1> 	or      word [equipment_list],equip_mouse
   568                              <1> .no_mouse:
   569                              <1> %endif ; PS2_MOUSE
   570                              <1> 
   571                              <1> ;-------------------------------------------------------------------------
   572                              <1> ; Set keyboard controller configuration:
   573                              <1> ; Enable keyboard interface; Disable auxiliary interface; Set POST complete
   574                              <1> 
   575 00001E0D B060                <1> 	mov	al,kbc_cmd_wr_ctr	; send "write keyboard controller" cmd
   576 00001E0F B465                <1> 	mov	ah,01100101b
   577                              <1> ;		   |||||||`-- 1 == enable OBF interrupt for keyboard (IRQ1)
   578                              <1> ;		   ||||||`-- 0 == disable OBF interrupt for aux port (IRQ12)
   579                              <1> ;		   |||||`-- 1 == POST complete
   580                              <1> ;		   ||||`-- 0 == reserved, must be 0
   581                              <1> ;		   |||`-- 0 == enable keyboard interface
   582                              <1> ;		   ||`-- 1 == disable auxiliary interface
   583                              <1> ;		   |`-- 1 == enable scan code translation to IBM PC scan codes
   584                              <1> ;		   `-- 0 == reserved, must be 0
   585 00001E11 E861FE              <1> 	call	kbc_send_cmd
   586 00001E14 7226                <1> 	jc	kbc_cmd_fail
   587                              <1> 
   588                              <1> ;-------------------------------------------------------------------------
   589                              <1> ; Enable keyboard
   590                              <1> 
   591 00001E16 B672                <1> 	mov	dh,e_kbd_ena_fail	; major error number
   592 00001E18 B201                <1> 	mov	dl,e_kbd_tout_fail	; minor error number
   593 00001E1A B0F4                <1> 	mov	al,dev_cmd_enable
   594 00001E1C E86BFE              <1> 	call	kbc_write_data		; send keyboard enable command
   595 00001E1F 720D                <1> 	jc	.keyboard_enable_error
   596                              <1> 
   597 00001E21 B202                <1> 	mov	dl,e_kbd_resp_fail	; minor error number
   598 00001E23 E885FE              <1> 	call	kbc_data_read		; wait for ACK
   599 00001E26 7206                <1> 	jc	.keyboard_enable_error
   600 00001E28 B203                <1> 	mov	dl,e_kbd_nack_fail	; minor error number
   601 00001E2A 3CFA                <1> 	cmp	al,dev_rsp_ack
   602 00001E2C 7403                <1> 	je	.keyboard_enable_ok	; ACK received, continue
   603                              <1> 
   604                              <1> .keyboard_enable_error:
   605 00001E2E E81200              <1> 	call	kbd_key_fail		; show the error on the POST display
   606                              <1> 
   607                              <1> .keyboard_enable_ok:
   608                              <1> ;-------------------------------------------------------------------------
   609                              <1> 
   610 00001E31 5A                  <1> 	pop	dx
   611 00001E32 59                  <1> 	pop	cx
   612 00001E33 58                  <1> 	pop	ax
   613 00001E34 C3                  <1> 	ret
   614                              <1> 
   615                              <1> kbc_flush_fail:
   616 00001E35 B060                <1> 	mov	al,e_kbc_flsh_fail
   617 00001E37 E680                <1> 	out	post_reg,al
   618                              <1> .1:
   619 00001E39 F4                  <1> 	hlt
   620 00001E3A EBFD                <1> 	jmp	.1
   621                              <1> 
   622                              <1> kbc_cmd_fail:
   623 00001E3C B061                <1> 	mov	al,e_kbc_cmd_fail
   624 00001E3E E680                <1> 	out	post_reg,al
   625                              <1> .1:
   626 00001E40 F4                  <1> 	hlt
   627 00001E41 EBFD                <1> 	jmp	.1
   628                              <1> 
   629                              <1> ;=========================================================================
   630                              <1> ; kbd_key_fail - show keyboard initializaiton error on the POST display
   631                              <1> ; Input:
   632                              <1> ;	DH = major error number
   633                              <1> ;	DL = minor error number
   634                              <1> ;	AL = data or status code (DEBUG mode only)
   635                              <1> ; Output:
   636                              <1> ;	none
   637                              <1> ;-------------------------------------------------------------------------
   638                              <1> kbd_key_fail:
   639 00001E43 B90500              <1> 	mov	cx,5			; repeat 5 times
   640 00001E46 88C4                <1> 	mov	ah,al			; save AL in AH
   641                              <1> .1:
   642 00001E48 51                  <1> 	push	cx
   643 00001E49 88F0                <1> 	mov	al,dh			; show DH first (major error number)
   644 00001E4B E680                <1> 	out	post_reg,al
   645 00001E4D B90080              <1> 	mov	cx,8000h		; wait approximately 0.5 seconds
   646 00001E50 E8BFF3              <1> 	call	delay_15us
   647 00001E53 88D0                <1> 	mov	al,dl			; show DL next (minor error number)
   648 00001E55 E680                <1> 	out	post_reg,al
   649 00001E57 B90080              <1> 	mov	cx,8000h		; wait approximately 0.5 seconds
   650 00001E5A E8B5F3              <1> 	call	delay_15us
   651 00001E5D 88E0                <1> 	mov	al,ah			; show saved value of AL (data/status)
   652 00001E5F E680                <1> 	out	post_reg,al
   653 00001E61 B90080              <1> 	mov	cx,8000h		; wait approximately 0.5 seconds
   654 00001E64 E8ABF3              <1> 	call	delay_15us
   655 00001E67 59                  <1> 	pop	cx
   656 00001E68 E2DE                <1> 	loop	.1
   657 00001E6A C3                  <1> 	ret
   277                                  %endif ; AT_KEYBOARD
   278                                  %include	"scancode.inc"		; keyboard scancodes translation func.
     1                              <1> ;=========================================================================
     2                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
     3                              <1> ;		 and related INT 16h functions:
     4                              <1> ;	INT 16h - BIOS Keyboard Services
     5                              <1> ;		- function AH=00h
     6                              <1> ;		- function AH=01h
     7                              <1> ;		- function AH=10h
     8                              <1> ;		- function AH=11h
     9                              <1> ;-------------------------------------------------------------------------
    10                              <1> ;
    11                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    12                              <1> ;
    13                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    14                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    15                              <1> ;
    16                              <1> ; This program is free software: you can redistribute it and/or modify
    17                              <1> ; it under the terms of the GNU General Public License as published by
    18                              <1> ; the Free Software Foundation, either version 3 of the License, or
    19                              <1> ; (at your option) any later version.
    20                              <1> ;
    21                              <1> ; This program is distributed in the hope that it will be useful,
    22                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    23                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    24                              <1> ; GNU General Public License for more details.
    25                              <1> ;
    26                              <1> ; You should have received a copy of the GNU General Public License
    27                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    28                              <1> ;
    29                              <1> ;=========================================================================
    30                              <1> 
    31                              <1> ;=========================================================================
    32                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
    33                              <1> ;                   BIOS scan code translation table
    34                              <1> ; Note 1: Table starts with scancode == 1
    35                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
    36                              <1> ;	00 - no flags
    37                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
    38                              <1> ;	     x in this case equals digit value
    39                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
    40                              <1> ;	40 - there is an extended key, so check for 0E0h flag
    41                              <1> ;	8x - F11, F12 BIOS scan codes
    42                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
    43                              <1> ;-------------------------------------------------------------------------
    44                              <1> 
    45                              <1> scan_xlat_table:
    46                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
    47 00001E6B 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
    48 00001E73 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
    49 00001E7B 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
    50 00001E83 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
    51 00001E8B 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
    52 00001E93 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
    53 00001E9B 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
    54 00001EA3 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
    55 00001EAB 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
    56 00001EB3 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
    57 00001EBB 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
    58 00001EC3 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
    59 00001ECB 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
    60 00001ED3 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
    61 00001EDB 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
    62 00001EE3 7120511011100010    <1> 	dw	2071h,	1051h,	1011h,	1000h	; q	Q	10h
    63                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
    64 00001EEB 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
    65 00001EF3 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
    66 00001EFB 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
    67 00001F03 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
    68 00001F0B 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
    69 00001F13 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
    70 00001F1B 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
    71 00001F23 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
    72 00001F2B 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
    73 00001F33 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
    74 00001F3B 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
    75 00001F43 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
    76 00001F4B 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
    77 00001F53 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
    78 00001F5B 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
    79 00001F63 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
    80                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
    81 00001F6B 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
    82 00001F73 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
    83 00001F7B 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
    84 00001F83 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
    85 00001F8B 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
    86 00001F93 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
    87 00001F9B 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
    88 00001FA3 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
    89 00001FAB 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
    90 00001FB3 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
    91 00001FBB 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
    92 00001FC3 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
    93 00001FCB 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
    94 00001FD3 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
    95 00001FDB 7620562F162F002F    <1> 	dw	2076h,	2F56h,	2F16h,	2F00h	; v	V	2Fh
    96 00001FE3 6220423002300030    <1> 	dw	2062h,	3042h,	3002h,	3000h	; b	B	30h
    97                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
    98 00001FEB 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
    99 00001FF3 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
   100 00001FFB 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
   101 00002003 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
   102 0000200B 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
   103 00002013 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
   104 0000201B 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
   105 00002023 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
   106 0000202B 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
   107 00002033 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
   108 0000203B 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
   109 00002043 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
   110 0000204B 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
   111 00002053 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
   112 0000205B 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
   113 00002063 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
   114                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   115 0000206B 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
   116 00002073 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
   117 0000207B 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
   118 00002083 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
   119 0000208B 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
   120 00002093 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
   121 0000209B 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
   122 000020A3 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
   123 000020AB 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
   124 000020B3 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
   125 000020BB 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
   126 000020C3 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
   127 000020CB 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
   128 000020D3 2B002B4E0090F04E    <1> 	dw	002Bh,	4E2Bh,	9000h,	4EF0h	; Gray +	4Eh
   129 000020DB 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
   130 000020E3 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
   131                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
   132 000020EB 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
   133 000020F3 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
   134 000020FB 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
   135 00002103 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
   136 0000210B 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
   137 00002113 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
   138 0000211B 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
   139 00002123 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
   140                              <1> .end:
   141                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
   142                              <1> 
   143                              <1> ;=========================================================================
   144                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
   145                              <1> ; Input:
   146                              <1> ;	AL - scan code
   147                              <1> ; Output:
   148                              <1> ;	AX - ASCII character / scan code pair
   149                              <1> ;-------------------------------------------------------------------------
   150                              <1> scan_xlat:
   151 0000212B 53                  <1> 	push	bx
   152 0000212C FEC8                <1> 	dec	al
   153 0000212E 3C58                <1> 	cmp	al,scan_xlat_table_size
   154 00002130 7205                <1> 	jb	.1
   155 00002132 31C0                <1> 	xor	ax,ax
   156 00002134 E9AB00              <1> 	jmp	.exit
   157                              <1> 
   158                              <1> .1:
   159 00002137 B700                <1> 	mov	bh,00h				; calculate offset of the key
   160 00002139 88C3                <1> 	mov	bl,al				; in scan_xlat_table
   161 0000213B D1E3                <1> 	shl	bx,1				; BX = AL * 8
   162 0000213D D1E3                <1> 	shl	bx,1
   163 0000213F D1E3                <1> 	shl	bx,1
   164                              <1> 
   165 00002141 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
   166 00002146 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
   167 00002148 2E8B87[711E]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
   168                              <1> 	; check for numeric Keypad keys
   169 0000214D 2EF687[6C1E]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
   170 00002153 7474                <1> 	jz	.check_extended
   171 00002155 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   172 0000215A 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
   173                              <1> 						; and so it is not a keypad key
   174                              <1> 
   175 0000215C 2E8A87[6C1E]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
   176 00002161 240F                <1> 	and	al,0Fh				; get the numeric value
   177 00002163 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
   178 00002167 D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
   179 00002169 A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
   180                              <1> 
   181 0000216C 31C0                <1> 	xor	ax,ax				; return nothing
   182 0000216E EB72                <1> 	jmp	.exit
   183                              <1> 
   184                              <1> .check_ctrl:
   185 00002170 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
   186 00002175 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
   187 00002177 2E8B87[6F1E]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
   188 0000217C EB4B                <1> 	jmp	.check_extended
   189                              <1> 
   190                              <1> .check_locks:
   191 0000217E 2EF687[6C1E]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
   192 00002184 741D                <1> 	jz	.check_shift			; not affected by Locks
   193                              <1> 
   194 00002186 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
   195 00002188 7309                <1> 	jae	.check_num_lock			; above or equal 47h
   196                              <1> 
   197 0000218A F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
   198 0000218F 7412                <1> 	jz	.check_shift			; Caps Lock is not active
   199 00002191 EB07                <1> 	jmp	.lock_active
   200                              <1> 
   201                              <1> .check_num_lock:
   202 00002193 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
   203 00002198 7409                <1> 	jz	.check_shift			; Num Lock is not active
   204                              <1> .lock_active:
   205                              <1> 	; are any of Shift keys active?
   206 0000219A F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   207 0000219F 7409                <1> 	jz	.shift				; Lock active, Shift inactive
   208 000021A1 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
   209                              <1> 
   210                              <1> .check_shift:
   211                              <1> 	; are any of Shift keys active?
   212 000021A3 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   213 000021A8 7407                <1> 	jz	.no_shift
   214                              <1> .shift:
   215 000021AA 2E8B87[6D1E]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
   216 000021AF EB18                <1> 	jmp	.check_extended
   217                              <1> 
   218                              <1> .no_shift:
   219 000021B1 88C4                <1> 	mov	ah,al				; Move scan code to AH
   220 000021B3 FEC4                <1> 	inc	ah
   221 000021B5 2E8A87[6B1E]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
   222 000021BA 2EF687[6C1E]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
   223 000021C0 7407                <1> 	jz	.check_extended			; not F11 or F12
   224 000021C2 2E8AA7[6C1E]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
   225 000021C7 EB19                <1> 	jmp	.exit
   226                              <1> 
   227                              <1> .check_extended:
   228 000021C9 2EF687[6C1E]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
   229 000021CF 7411                <1> 	jz	.exit				; no extended key
   230 000021D1 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   231 000021D6 740A                <1> 	jz	.exit				; ... not a 0E0h
   232 000021D8 3C00                <1> 	cmp	al,00h
   233 000021DA 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
   234 000021DC B0E0                <1> 	mov	al,0E0h				; indicate extended key
   235 000021DE EB02                <1> 	jmp	.exit
   236                              <1> 
   237                              <1> .ascii_code:
   238 000021E0 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
   239                              <1> 						; key with valid ASCII code
   240                              <1> 						; (Keypad Enter, *, and /)
   241                              <1> 
   242                              <1> .exit:
   243 000021E2 5B                  <1> 	pop	bx
   244 000021E3 C3                  <1> 	ret
   245                              <1> 
   246                              <1> ;=========================================================================
   247                              <1> ; int_16_fn00 - get keystroke
   248                              <1> ; Input:
   249                              <1> ;	AH = 00h
   250                              <1> ; Output:
   251                              <1> ;	AH = BIOS scan code
   252                              <1> ;	AL = ASCII character
   253                              <1> ; Notes:
   254                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   255                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   256                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   257                              <1> ;	- Use function AH=10h for extended keystrokes handling
   258                              <1> ;-------------------------------------------------------------------------
   259                              <1> int_16_fn00:
   260 000021E4 FB                  <1> 	sti
   261                              <1> .1:
   262 000021E5 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   263 000021E9 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   264 000021ED 74F6                <1> 	jz	.1			; wait or keystroke
   265 000021EF 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   266 000021F1 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   267                              <1> 					;   location
   268 000021F4 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   269 000021F8 7504                <1> 	jne	.2
   270 000021FA 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   271                              <1> .2:
   272 000021FE 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   273 00002202 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   274                              <1> 					;   extended key?
   275 00002204 7504                <1> 	jne	.3			; not a convertible key
   276 00002206 B000                <1> 	mov	al,00h			; convert to a standard key
   277 00002208 EB2C                <1> 	jmp	.exit
   278                              <1> .3:
   279 0000220A 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   280 0000220C 74D7                <1> 	je	.1			; an ignored extended key, get next key
   281 0000220E 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   282                              <1> 					;   (scancode above 84h)
   283 00002211 77D2                <1> 	ja	.1			; an ignored extended key, get next key
   284 00002213 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   285 00002216 751E                <1> 	jne	.exit
   286 00002218 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   287 0000221A 7504                <1> 	jne	.4
   288 0000221C B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   289 0000221E EB16                <1> 	jmp	.exit
   290                              <1> .4:
   291 00002220 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   292 00002222 7504                <1> 	jne	.5
   293 00002224 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   294 00002226 EB0E                <1> 	jmp	.exit
   295                              <1> .5:
   296 00002228 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   297 0000222A 7504                <1> 	jne	.6
   298 0000222C B435                <1> 	mov	ah,35h			; standard / scancode
   299 0000222E EB06                <1> 	jmp	.exit
   300                              <1> .6:
   301 00002230 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   302 00002232 7502                <1> 	jne	.exit
   303 00002234 B437                <1> 	mov	ah,37h			; standard * scancode
   304                              <1> .exit:
   305 00002236 E93236              <1> 	jmp	int_16_exit
   306                              <1> 
   307                              <1> ;=========================================================================
   308                              <1> ; int_16_fn01 - check for keystroke
   309                              <1> ; Input:
   310                              <1> ;	AH = 01h
   311                              <1> ; Output:
   312                              <1> ;	ZF = 1 - no keystroke available
   313                              <1> ;	ZF = 0 = keystroke is available and put in AX
   314                              <1> ;		AH = BIOS scan code
   315                              <1> ;		AL = ASCII character
   316                              <1> ; Notes:
   317                              <1> ;	- Does not remove keystroke from keyboard buffer
   318                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   319                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   320                              <1> ;	- Use function AH=11h for extended keystrokes handling
   321                              <1> ;-------------------------------------------------------------------------
   322                              <1> int_16_fn01:
   323 00002239 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   324 0000223D 8B07                <1> 	mov	ax,word [bx]
   325 0000223F 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   326 00002243 7436                <1> 	jz	.exit			; no keystroke, exit
   327 00002245 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   328                              <1> 					;   extended key?
   329 00002247 7504                <1> 	jne	.1			; not a convertible key
   330 00002249 B000                <1> 	mov	al,00h			; convert to a standard key
   331 0000224B EB2C                <1> 	jmp	.clear_zf
   332                              <1> .1:
   333 0000224D 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   334 0000224F 742D                <1> 	je	.discard_key		; an ignored extended key, discard
   335 00002251 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   336                              <1> 					;   (scancode above 84h)
   337 00002254 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
   338 00002256 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   339 00002259 751E                <1> 	jne	.clear_zf
   340 0000225B 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   341 0000225D 7504                <1> 	jne	.2
   342 0000225F B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   343 00002261 EB16                <1> 	jmp	.clear_zf
   344                              <1> .2:
   345 00002263 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   346 00002265 7504                <1> 	jne	.3
   347 00002267 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   348 00002269 EB0E                <1> 	jmp	.clear_zf
   349                              <1> .3:
   350 0000226B 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   351 0000226D 7504                <1> 	jne	.4
   352 0000226F B435                <1> 	mov	ah,35h			; standard / scancode
   353 00002271 EB06                <1> 	jmp	.clear_zf
   354                              <1> .4:
   355 00002273 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   356 00002275 7502                <1> 	jne	.clear_zf
   357 00002277 B437                <1> 	mov	ah,37h			; standard * scancode
   358                              <1> 
   359                              <1> .clear_zf:
   360 00002279 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   361                              <1> .exit:
   362 0000227B E9F035              <1> 	jmp	int_16_exitf
   363                              <1> 
   364                              <1> .discard_key:
   365 0000227E 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   366                              <1> 					;   location
   367 00002281 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   368 00002285 7504                <1> 	jne	.5
   369 00002287 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   370                              <1> .5:
   371 0000228B 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   372 0000228F EBA8                <1> 	jmp	int_16_fn01		; check for the next key
   373                              <1> 	
   374                              <1> 
   375                              <1> ;=========================================================================
   376                              <1> ; int_16_fn10 - get extended keystroke
   377                              <1> ; Input:
   378                              <1> ;	AH = 10h
   379                              <1> ; Output:
   380                              <1> ;	AH = BIOS scan code
   381                              <1> ;	AL = ASCII character
   382                              <1> ; Note:
   383                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   384                              <1> ;-------------------------------------------------------------------------
   385                              <1> int_16_fn10:
   386 00002291 FB                  <1> 	sti
   387                              <1> .1:
   388 00002292 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   389 00002296 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   390 0000229A 74F6                <1> 	jz	.1			; wait or keystroke
   391 0000229C 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   392 0000229E 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   393                              <1> 					;   location
   394 000022A1 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   395 000022A5 7504                <1> 	jne	.2
   396 000022A7 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   397                              <1> .2:
   398 000022AB 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   399 000022AF 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   400 000022B1 7507                <1> 	jne	.exit			; not an extended key
   401 000022B3 80FC00              <1> 	cmp	ah,00h			; is it Alt + 240 (F0 00)?
   402 000022B6 7402                <1> 	je	.exit			; yes it is Alt + 240, return ASCII
   403 000022B8 B000                <1> 	mov	al,00h			; set ASCII character to zero
   404                              <1> 
   405                              <1> .exit:
   406 000022BA E9AE35              <1> 	jmp	int_16_exit
   407                              <1> 
   408                              <1> ;=========================================================================
   409                              <1> ; int_16_fn11 - check for extended keystroke
   410                              <1> ; Input:
   411                              <1> ;	AH = 01h
   412                              <1> ; Output:
   413                              <1> ;	ZF = 1 - no keystroke available
   414                              <1> ;	ZF = 0 = keystroke is available and put in AX
   415                              <1> ;		AH = BIOS scan code
   416                              <1> ;		AL = ASCII character
   417                              <1> ; Note:
   418                              <1> ;	- Does not remove keystroke from keyboard buffer
   419                              <1> ;-------------------------------------------------------------------------
   420                              <1> int_16_fn11:
   421 000022BD 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   422 000022C1 8B07                <1> 	mov	ax,word [bx]
   423 000022C3 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   424 000022C7 7408                <1> 	jz	.exit			; no keystroke, exit
   425 000022C9 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   426 000022CB 7502                <1> 	jne	.clear_zf		; not a extended key
   427 000022CD B000                <1> 	mov	al,00h			; set scancode to zero
   428                              <1> .clear_zf:
   429 000022CF 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   430                              <1> .exit:
   431 000022D1 E99A35              <1> 	jmp	int_16_exitf
   279                                  %include	"serial1.inc"		; serial port services & detection
     1                              <1> ;========================================================================
     2                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
     3                              <1> ;       INT 14h, function AH=01h
     4                              <1> ;	INT 14h, function AH=02h
     5                              <1> ;	detect_serial
     6                              <1> ;	serial port related definitions and tables
     7                              <1> ;	- see serial2.inc for other INT 14h functions
     8                              <1> ;-------------------------------------------------------------------------
     9                              <1> ;
    10                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    11                              <1> ;
    12                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                              <1> ;
    15                              <1> ; This program is free software: you can redistribute it and/or modify
    16                              <1> ; it under the terms of the GNU General Public License as published by
    17                              <1> ; the Free Software Foundation, either version 3 of the License, or
    18                              <1> ; (at your option) any later version.
    19                              <1> ;
    20                              <1> ; This program is distributed in the hope that it will be useful,
    21                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                              <1> ; GNU General Public License for more details.
    24                              <1> ;
    25                              <1> ; You should have received a copy of the GNU General Public License
    26                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                              <1> ;
    28                              <1> ;=========================================================================
    29                              <1> 
    30                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
    31                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
    32                              <1> 
    33                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
    34                              <1> 
    35                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
    36                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
    37                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
    38                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
    39                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
    40                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
    41                              <1> 
    42                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
    43                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
    44                              <1> uart_mcr_rts	equ	2		; MCR - request to send (RTS)
    45                              <1> 
    46                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
    47                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
    48                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
    49                              <1> 
    50                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
    51                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
    52                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
    53                              <1> 
    54                              <1> uart_err_timeout equ	80h		; timeout error
    55                              <1> 
    56                              <1> num_serial	equ	4		; number of serial ports
    57                              <1> 
    58                              <1> ;=========================================================================
    59                              <1> ; int_14_fn01 - Send character
    60                              <1> ; Input:
    61                              <1> ;	AH = 01h - function 01h - send character
    62                              <1> ;	AL = character to send
    63                              <1> ;	DX = serial port number (0-3)
    64                              <1> ; Output:
    65                              <1> ;	AH = line status (see int_14_fn00 for complete description)
    66                              <1> ;-------------------------------------------------------------------------
    67                              <1> int_14_fn01:
    68 000022D4 50                  <1> 	push	ax
    69 000022D5 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; set DTR and RTS in MCR:
    70                              <1> 					; ready to communicate, request to send
    71 000022D7 B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR:
    72                              <1> 					; ready to communicate, clear to send
    73 000022D9 B320                <1> 	mov	bl,uart_lsr_thre	; and for THRE in LSR:
    74                              <1> 					; UART is ready to accept new character
    75 000022DB E82200              <1> 	call	uart_wait_status
    76 000022DE 59                  <1> 	pop	cx
    77 000022DF 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
    78 000022E1 88C8                <1> 	mov	al,cl
    79 000022E3 EE                  <1> 	out	dx,al			; sent the character
    80 000022E4 E97F34              <1> 	jmp	int_14_exit
    81                              <1> 
    82                              <1> int_14_timeout:
    83 000022E7 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
    84 000022E9 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
    85 000022EC E97734              <1> 	jmp	int_14_exit
    86                              <1> 
    87                              <1> ;=========================================================================
    88                              <1> ; int_14_fn02 - Receive character
    89                              <1> ; Input:
    90                              <1> ;	AH = 02h - function 02h - receive character
    91                              <1> ;	DX = serial port number (0-3)
    92                              <1> ; Output:
    93                              <1> ;	AL = character received
    94                              <1> ;	AH = line status (see int_14_fn00 for complete description)
    95                              <1> ;-------------------------------------------------------------------------
    96                              <1> int_14_fn02:
    97 000022EF 50                  <1> 	push	ax
    98 000022F0 B001                <1> 	mov	al,uart_mcr_dtr		; set DTR in MCR:
    99                              <1> 					; ready to communicate
   100 000022F2 B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR:
   101                              <1> 					; ready to communicate
   102 000022F4 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR:
   103                              <1> 					; UART has received a character
   104 000022F6 E80700              <1> 	call	uart_wait_status
   105 000022F9 59                  <1> 	pop	cx
   106 000022FA 75EB                <1> 	jnz	int_14_timeout
   107 000022FC EC                  <1> 	in	al,dx			; receive the character
   108 000022FD E96634              <1> 	jmp	int_14_exit
   109                              <1> 
   110                              <1> ;=========================================================================
   111                              <1> ; uart_wait_status - wait for modem and line status
   112                              <1> ; Input:
   113                              <1> ;	AL = value to write to MCR (Modem Control Register)
   114                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
   115                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
   116                              <1> ;	DX = UART base address
   117                              <1> ;	SI = address of the timeout value (in seconds)
   118                              <1> ; Output:
   119                              <1> ;	AH = line status
   120                              <1> ;	ZF = 0 - timeout
   121                              <1> ;	CX,BX - destroyed
   122                              <1> ;-------------------------------------------------------------------------
   123                              <1> uart_wait_status:
   124 00002300 52                  <1> 	push	dx
   125 00002301 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
   126 00002304 EE                  <1> 	out	dx,al			; output MCR value
   127 00002305 42                  <1> 	inc	dx
   128 00002306 42                  <1> 	inc	dx			; DX = UART MSR address
   129                              <1> 					; OPTIMIZATION:
   130                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
   131 00002307 E80A00              <1> 	call	wait_for_port		; wait for MSR status
   132 0000230A 7506                <1> 	jnz	.wait_exit
   133 0000230C 4A                  <1> 	dec	dx			; DX = UART LSR address
   134                              <1> 					; OPTIMIZATION:
   135                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
   136 0000230D 88DF                <1> 	mov	bh,bl			; BH = LSR mask
   137 0000230F E80200              <1> 	call	wait_for_port		; wait for LSR status
   138                              <1> .wait_exit:
   139 00002312 5A                  <1> 	pop	dx
   140 00002313 C3                  <1> 	ret
   141                              <1> 
   142                              <1> ;=========================================================================
   143                              <1> ; wait_for_port - wait for set bits in a register
   144                              <1> ;
   145                              <1> ; Input:
   146                              <1> ;	BH = mask to wait for (bits that need to be 1)
   147                              <1> ;	DX = register address
   148                              <1> ;	SI = address of the timeout value (in seconds)
   149                              <1> ; Output:
   150                              <1> ;	AH = last port reading
   151                              <1> ;	ZF clear on timeout
   152                              <1> ;	ZF set on success
   153                              <1> ;	AL - trashed
   154                              <1> ;	CX - trashed
   155                              <1> ;-------------------------------------------------------------------------
   156                              <1> wait_for_port:
   157                              <1> 
   158 00002314 53                  <1> 	push	bx
   159 00002315 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
   160                              <1> 
   161                              <1> .loop_outer:
   162 00002317 B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
   163                              <1> 
   164                              <1> .loop_inner:
   165 0000231A EC                  <1> 	in	al,dx			; read the register
   166 0000231B 88C4                <1> 	mov	ah,al			; save register in AH
   167 0000231D 20F8                <1> 	and	al,bh
   168 0000231F 38F8                <1> 	cmp	al,bh			; required bits are set?
   169 00002321 7414                <1> 	je	.exit
   170                              <1> 
   171                              <1> %ifdef AT_DELAY
   172                              <1> 
   173                              <1> .zero_loop:
   174 00002323 E461                <1> 	in	al,ppi_pb_reg
   175 00002325 A810                <1> 	test	al,refresh_flag
   176 00002327 74FA                <1> 	jz	.zero_loop		; wait 15.09 us
   177                              <1> 
   178                              <1> .one_loop:
   179 00002329 E461                <1> 	in	al,ppi_pb_reg
   180 0000232B A810                <1> 	test	al,refresh_flag
   181 0000232D 75FA                <1> 	jnz	.one_loop		; wait 15.09 us
   182                              <1> 
   183                              <1> %else ; AT_DELAY
   184                              <1> 
   185                              <1> 	; wait 30.17 us (Intel 8088 CPU running on 4.77 MHz)
   186                              <1>         mov     al,8
   187                              <1> .delay_loop:
   188                              <1>         dec     al
   189                              <1>         jnz     .delay_loop
   190                              <1> 
   191                              <1> %endif ; AT_DELAY
   192                              <1> 
   193 0000232F E2E9                <1> 	loop	.loop_inner
   194                              <1> 
   195 00002331 FECB                <1> 	dec	bl
   196 00002333 75E2                <1> 	jnz	.loop_outer
   197 00002335 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
   198                              <1> 
   199                              <1> .exit:
   200 00002337 5B                  <1> 	pop	bx
   201 00002338 C3                  <1> 	ret
   202                              <1> 
   203                              <1> ;=========================================================================
   204                              <1> ; detect_serial - detect and print serial ports
   205                              <1> ; Input:
   206                              <1> ;	none
   207                              <1> ; Output:
   208                              <1> ;	none (updates BIOS data area)
   209                              <1> ;-------------------------------------------------------------------------
   210                              <1> detect_serial:
   211 00002339 50                  <1> 	push	ax
   212 0000233A 53                  <1> 	push	bx
   213 0000233B 52                  <1> 	push	dx
   214 0000233C 56                  <1> 	push	si
   215 0000233D B024                <1> 	mov	al,e_serial_scan
   216 0000233F E680                <1> 	out	post_reg,al
   217                              <1> 
   218 00002341 BE[BB02]            <1> 	mov	si,msg_serial
   219 00002344 E86905              <1> 	call	print
   220 00002347 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
   221 0000234A 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
   222 0000234E 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
   223 00002352 31DB                <1> 	xor	bx,bx			; BX = 0
   224                              <1> .detect_loop:
   225 00002354 BE[D802]            <1> 	mov	si,msg_serial_com
   226 00002357 E85605              <1> 	call	print
   227 0000235A 88D8                <1> 	mov	al,bl
   228 0000235C D0E8                <1> 	shr	al,1
   229 0000235E FEC0                <1> 	inc	al			; AL = COM port number (1..4)
   230 00002360 E8AB05              <1> 	call	print_digit
   231 00002363 BE[9300]            <1> 	mov	si,msg_colon
   232 00002366 E84705              <1> 	call	print
   233 00002369 2E8B97[BB23]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
   234 0000236E EC                  <1> 	in	al,dx
   235 0000236F B00F                <1> 	mov	al,0Fh
   236 00002371 EE                  <1> 	out	dx,al			; enable interrupts
   237 00002372 B000                <1> 	mov	al,00h
   238 00002374 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
   239 00002376 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   240 00002377 3C0F                <1> 	cmp	al,0Fh
   241 00002379 751C                <1> 	jne	.no_port		; no port at this address
   242 0000237B B000                <1> 	mov	al,00h
   243 0000237D EE                  <1> 	out	dx,al			; disable interrupts
   244 0000237E B0FF                <1> 	mov	al,0FFh
   245 00002380 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   246 00002382 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   247 00002383 3C00                <1> 	cmp	al,00h
   248 00002385 7510                <1> 	jne	.no_port		; no port at this address
   249 00002387 4A                  <1> 	dec	dx			; DX = UART base address
   250                              <1> 					; OPTIMIZATION:
   251                              <1> 					; uart_base = uart_ier_reg - 1
   252 00002388 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
   253                              <1> 					; data area
   254 0000238A 810610000002        <1> 	add	word [equipment_list],0200h ; increment number of serial ports
   255 00002390 89D0                <1> 	mov	ax,dx
   256 00002392 E83605              <1> 	call	print_hex
   257 00002395 EB0A                <1> 	jmp	.next
   258                              <1> 
   259                              <1> .no_port:
   260 00002397 C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
   261 0000239B BE[8E00]            <1> 	mov	si,msg_none
   262 0000239E E80F05              <1> 	call	print
   263                              <1> 	
   264                              <1> .next:
   265 000023A1 43                  <1> 	inc	bx
   266 000023A2 43                  <1> 	inc	bx
   267 000023A3 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
   268 000023A6 7408                <1> 	je	.done
   269 000023A8 BE[9600]            <1> 	mov	si,msg_semicolon
   270 000023AB E80205              <1> 	call	print
   271 000023AE EBA4                <1> 	jmp	.detect_loop
   272                              <1> 
   273                              <1> .done:
   274 000023B0 BE[8B00]            <1> 	mov	si,msg_crlf
   275 000023B3 E8FA04              <1> 	call	print
   276                              <1> 
   277 000023B6 5E                  <1> 	pop	si
   278 000023B7 5A                  <1> 	pop	dx
   279 000023B8 5B                  <1> 	pop	bx
   280 000023B9 58                  <1> 	pop	ax
   281 000023BA C3                  <1> 	ret
   282                              <1> 
   283                              <1> ;-------------------------------------------------------------------------
   284                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
   285 000023BB F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
   286 000023BF E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
   287                              <1> 
   288                              <1> ;-------------------------------------------------------------------------
   289                              <1> ; UART divisor values table
   290 000023C3 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
   291 000023C5 0003                <1> 		dw	uart_osc/16/150		; 150 bps
   292 000023C7 8001                <1> 		dw	uart_osc/16/300		; 300 bps
   293 000023C9 C000                <1> 		dw	uart_osc/16/600		; 600 bps
   294 000023CB 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
   295 000023CD 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
   296 000023CF 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
   297 000023D1 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
   298 000023D3 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
   299 000023D5 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
   300 000023D7 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
   301 000023D9 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
   302                              <1> num_divisors	equ ($-uart_divisors)/2
   280                                  %include	"printer1.inc"		; parallel printer services & detection
     1                              <1> ;========================================================================
     2                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
     3                              <1> ;	INT 17h, function AH=01h 
     4                              <1> ;	detect_parallel
     5                              <1> ;	- see printer2.inc for other INT 17h functions
     6                              <1> ;-------------------------------------------------------------------------
     7                              <1> ;
     8                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     9                              <1> ;
    10                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    11                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    12                              <1> ;
    13                              <1> ; This program is free software: you can redistribute it and/or modify
    14                              <1> ; it under the terms of the GNU General Public License as published by
    15                              <1> ; the Free Software Foundation, either version 3 of the License, or
    16                              <1> ; (at your option) any later version.
    17                              <1> ;
    18                              <1> ; This program is distributed in the hope that it will be useful,
    19                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                              <1> ; GNU General Public License for more details.
    22                              <1> ;
    23                              <1> ; You should have received a copy of the GNU General Public License
    24                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    25                              <1> ;
    26                              <1> ;=========================================================================
    27                              <1> 
    28                              <1> num_parallel	equ	3		; number of parallel ports
    29                              <1> 
    30                              <1> prn_data_reg	equ	0		; printer data register (out)
    31                              <1> 
    32                              <1> prn_stat_reg	equ	1		; printer status register (in)
    33                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
    34                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
    35                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
    36                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
    37                              <1> 
    38                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
    39                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
    40                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
    41                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
    42                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
    43                              <1> 
    44                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
    45                              <1> 
    46                              <1> ;=========================================================================
    47                              <1> ; int_17_fn01 - Initialize printer port
    48                              <1> ; Input:
    49                              <1> ;	AH = 1 - function 01h - initialize printer port
    50                              <1> ;	DX = printer port number (0-2)
    51                              <1> ; Output:
    52                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
    53                              <1> ;-------------------------------------------------------------------------
    54                              <1> int_17_fn01:
    55 000023DB 42                  <1> 	inc	dx
    56 000023DC 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
    57                              <1> 					; OPTIMIZATION:
    58                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
    59 000023DD B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
    60 000023DF EE                  <1> 	out	dx,al
    61 000023E0 51                  <1> 	push	cx
    62 000023E1 B9B509              <1> 	mov	cx,prn_init_delay
    63 000023E4 E82BEE              <1> 	call	delay_15us
    64 000023E7 59                  <1> 	pop	cx
    65 000023E8 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
    66 000023EA EE                  <1> 	out	dx,al			; deactivate init bit
    67 000023EB 4A                  <1> 	dec	dx			; OPTIMIZATION:
    68                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
    69 000023EC E94C3C              <1> 	jmp	int_17_status		; exit returning status
    70                              <1> 
    71                              <1> ;=========================================================================
    72                              <1> ; detect_parallel - detect and print parallel ports
    73                              <1> ; Input:
    74                              <1> ;	none
    75                              <1> ; Output:
    76                              <1> ;	none (updates BIOS data area)
    77                              <1> ; Notes:
    78                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
    79                              <1> ;	  enumeration is used:
    80                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
    81                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
    82                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
    83                              <1> ;-------------------------------------------------------------------------
    84                              <1> detect_parallel:
    85 000023EF 50                  <1> 	push	ax
    86 000023F0 53                  <1> 	push	bx
    87 000023F1 52                  <1> 	push	dx
    88 000023F2 56                  <1> 	push	si
    89 000023F3 B025                <1> 	mov	al,e_parallel_scan
    90 000023F5 E680                <1> 	out	post_reg,al
    91                              <1> 
    92 000023F7 BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
    93 000023FA 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
    94 000023FE 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
    95 00002402 31DB                <1> 	xor	bx,bx			; BX = 0
    96 00002404 31FF                <1> 	xor	di,di			; DI = 0
    97                              <1> .detect_loop:
    98 00002406 2E8B95[7F24]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
    99 0000240B B05A                <1> 	mov	al,05Ah			; just some test value
   100 0000240D EE                  <1> 	out	dx,al			; write it to the printer data register
   101 0000240E B0FF                <1> 	mov	al,0FFh
   102 00002410 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   103 00002412 EC                  <1> 	in	al,dx
   104 00002413 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
   105 00002415 750B                <1> 	jne	.no_port		; no port at this address
   106 00002417 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
   107                              <1> 					; data area
   108 0000241A 810610000040        <1> 	add	word [equipment_list],4000h ; increment number of printer ports
   109 00002420 EB09                <1> 	jmp	.next
   110                              <1> 
   111                              <1> .no_port:
   112 00002422 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
   113 00002427 09FF                <1> 	or	di,di			; no printer port at 3BCh?
   114 00002429 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
   115                              <1> .next:
   116 0000242B 43                  <1> 	inc	bx
   117 0000242C 43                  <1> 	inc	bx
   118                              <1> 
   119                              <1> .next_skip_3BC:
   120 0000242D 47                  <1> 	inc	di
   121 0000242E 47                  <1> 	inc	di
   122 0000242F 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
   123 00002432 7402                <1> 	je	.print			; done with detection, print findings
   124 00002434 EBD0                <1> 	jmp	.detect_loop
   125                              <1> 
   126                              <1> .print:
   127 00002436 BE[DC02]            <1> 	mov	si,msg_parallel
   128 00002439 E87404              <1> 	call	print
   129 0000243C 31DB                <1> 	xor	bx,bx
   130                              <1> 
   131                              <1> .print_loop:
   132 0000243E BE[F902]            <1> 	mov	si,msg_parallel_lpt
   133 00002441 E86C04              <1> 	call	print
   134 00002444 88D8                <1> 	mov	al,bl
   135 00002446 D0E8                <1> 	shr	al,1
   136 00002448 FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
   137 0000244A E8C104              <1> 	call	print_digit
   138 0000244D BE[9300]            <1> 	mov	si,msg_colon
   139 00002450 E85D04              <1> 	call	print
   140 00002453 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
   141 00002456 09C0                <1> 	or	ax,ax			; parallel interface installed?
   142 00002458 7405                <1> 	jz	.print_no_port
   143 0000245A E86E04              <1> 	call	print_hex
   144 0000245D EB06                <1> 	jmp	.print_next
   145                              <1> 
   146                              <1> .print_no_port:
   147 0000245F BE[8E00]            <1> 	mov	si,msg_none
   148 00002462 E84B04              <1> 	call	print
   149                              <1> 
   150                              <1> .print_next:
   151 00002465 43                  <1> 	inc	bx
   152 00002466 43                  <1> 	inc	bx
   153 00002467 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
   154 0000246A 7408                <1> 	je	.done
   155 0000246C BE[9600]            <1> 	mov	si,msg_semicolon
   156 0000246F E83E04              <1> 	call	print
   157 00002472 EBCA                <1> 	jmp	.print_loop
   158                              <1> 
   159                              <1> .done:
   160 00002474 BE[8B00]            <1> 	mov	si,msg_crlf
   161 00002477 E83604              <1> 	call	print
   162                              <1> 
   163 0000247A 5E                  <1> 	pop	si
   164 0000247B 5A                  <1> 	pop	dx
   165 0000247C 5B                  <1> 	pop	bx
   166 0000247D 58                  <1> 	pop	ax
   167 0000247E C3                  <1> 	ret
   168                              <1> 
   169                              <1> ;-------------------------------------------------------------------------
   170                              <1> ; parallel port base addresses - used for port detection
   171 0000247F BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
   281                                  %ifdef PS2_MOUSE
   282                                  %ifndef SECOND_PIC
   283                                  %error "PS2_MOUSE depends on SECOND_PIC. Please fix config.inc."
   284                                  %endif ; SECOND_PIC
   285                                  %include	"ps2aux.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; ps2aux.inc - PS/2 mouse support functions:
     3                              <1> ;	INT 15h, function AH=0C2h
     4                              <1> ;	INT 74h - IRQ12 interrupt handler
     5                              <1> ;-------------------------------------------------------------------------
     6                              <1> ;
     7                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     8                              <1> ;
     9                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    10                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    11                              <1> ;
    12                              <1> ; This program is free software: you can redistribute it and/or modify
    13                              <1> ; it under the terms of the GNU General Public License as published by
    14                              <1> ; the Free Software Foundation, either version 3 of the License, or
    15                              <1> ; (at your option) any later version.
    16                              <1> ;
    17                              <1> ; This program is distributed in the hope that it will be useful,
    18                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    19                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    20                              <1> ; GNU General Public License for more details.
    21                              <1> ;
    22                              <1> ; You should have received a copy of the GNU General Public License
    23                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    24                              <1> ;
    25                              <1> ;=========================================================================
    26                              <1> 
    27                              <1> ;-------------------------------------------------------------------------
    28                              <1> ; offsets for registers on stack
    29                              <1> int_15_fnC2_bp	equ	0
    30                              <1> int_15_fnC2_ds	equ	int_15_fnC2_bp+2
    31                              <1> int_15_fnC2_dl	equ	int_15_fnC2_ds+2
    32                              <1> int_15_fnC2_dh	equ	int_15_fnC2_dl+1
    33                              <1> int_15_fnC2_cl	equ	int_15_fnC2_dh+1
    34                              <1> int_15_fnC2_ch	equ	int_15_fnC2_cl+1
    35                              <1> int_15_fnC2_bl	equ	int_15_fnC2_ch+1
    36                              <1> int_15_fnC2_bh	equ	int_15_fnC2_bl+1
    37                              <1> int_15_fnC2_al	equ	int_15_fnC2_bh+1
    38                              <1> int_15_fnC2_ah	equ	int_15_fnC2_al+1
    39                              <1> int_15_fnC2_ip	equ	int_15_fnC2_ah+1
    40                              <1> int_15_fnC2_cs	equ	int_15_fnC2_ip+2
    41                              <1> int_15_fnC2_flags equ	int_15_fnC2_cs+2
    42                              <1> 
    43                              <1> ;=========================================================================
    44                              <1> ; int_15_fnC2 - mouse functions
    45                              <1> ; Input:
    46                              <1> ;	AH = 0C2h - mouse functions
    47                              <1> ;	AL - function:
    48                              <1> ;		00h - enable / disable PS/2 mouse
    49                              <1> ;		01h - reset PS/2 mouse
    50                              <1> ;		02h - set sample rate
    51                              <1> ;		03h - set resolution
    52                              <1> ;		04h - read device type
    53                              <1> ;		05h - initialize PS/2 mouse
    54                              <1> ;		06h - set scaling or get status
    55                              <1> ;		07h - set PS/2 mouse driver address
    56                              <1> ; Output:
    57                              <1> ;	AH - exit status:
    58                              <1> ;		00h - no error
    59                              <1> ;		01h - invalid function call
    60                              <1> ;		02h - invalid input value
    61                              <1> ;		03h - interface error
    62                              <1> ;		04h - request for resend received from 8042
    63                              <1> ;		05h - no driver installed (function 0C207h has not been called)
    64                              <1> ;               Extended status codes as ah would get returned as C2 which confuses POST Logging!
    65                              <1> ;		06h - Reset Time out
    66                              <1> ;		07h - Sample Rate Error
    67                              <1> ;		08h - Enable/Disable Error
    68                              <1> ;		09h - Read Device Type error
    69                              <1> ;		0Ah - Initialize error
    70                              <1> ;		0Bh - Get status/scaling error
    71                              <1> ;	CF = 1 - function is not supported, CF = 0 function is supported
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> int_15_fnC2:
    74 00002485 50                  <1> 	push	ax
    75 00002486 53                  <1> 	push	bx
    76 00002487 51                  <1> 	push	cx
    77 00002488 52                  <1> 	push	dx
    78 00002489 1E                  <1> 	push	ds
    79 0000248A 55                  <1> 	push	bp
    80 0000248B 89E5                <1> 	mov	bp,sp			; establish stack addressing
    81 0000248D BB4000              <1> 	mov	bx,biosdseg
    82 00002490 8EDB                <1> 	mov	ds,bx
    83 00002492 8B1E0E00            <1> 	mov	bx,word [ebda_segment]
    84 00002496 8EDB                <1> 	mov	ds,bx			; load EBDA segment to DS
    85 00002498 3C08                <1> 	cmp	al,.num_func
    86 0000249A 7330                <1> 	jae	int_15_fnC2_err1	; return error 1 - invalid function
    87 0000249C E86EF8              <1> 	call	kbc_aux_disable		; disable auxiliary device
    88 0000249F 88C3                <1> 	mov	bl,al			; set to index into dispatch table
    89 000024A1 B700                <1> 	mov	bh,0
    90 000024A3 D1E3                <1> 	shl	bx,1			; address words
    91 000024A5 88E0                <1>         mov     al,ah                   ; Copy C2 for POST port debug info
    92 000024A7 E680                <1>        	out	post_reg,al
    93 000024A9 88D8                <1>         mov     al,bl                   ; Send Function to POST port
    94 000024AB D0E8                <1>         shr     al,1                    ; Undo x 2 on BX!
    95 000024AD E680                <1>        	out	post_reg,al
    96                              <1> 
    97 000024AF 2EFFA7[B424]        <1>     cs	jmp	near [.dispatch+bx]
    98                              <1> 
    99                              <1> .dispatch:
   100 000024B4 [F124]              <1> 	dw	int_15_fnC200
   101 000024B6 [1125]              <1> 	dw	int_15_fnC201
   102 000024B8 [3625]              <1> 	dw	int_15_fnC202
   103 000024BA [6325]              <1> 	dw	int_15_fnC203
   104 000024BC [8B25]              <1> 	dw	int_15_fnC204
   105 000024BE [A725]              <1> 	dw	int_15_fnC205
   106 000024C0 [F125]              <1> 	dw	int_15_fnC206
   107 000024C2 [4626]              <1> 	dw	int_15_fnC207
   108                              <1> .num_func	equ ($-.dispatch)/2
   109                              <1> 
   110                              <1> int_15_fnC2_ok:
   111 000024C4 B400                <1> 	mov	ah,00h			; no error
   112 000024C6 806610FE            <1> 	and	byte [bp+int_15_fnC2_flags],~1 ; clear CF
   113 000024CA EB14                <1> 	jmp	int_15_fnC2_exit
   114                              <1> 
   115                              <1> int_15_fnC2_err1:
   116 000024CC B401                <1> 	mov	ah,01h			; invalid function call
   117 000024CE EB0C                <1> 	jmp	int_15_fnC2_err
   118                              <1> 
   119                              <1> int_15_fnC2_err2:
   120 000024D0 B402                <1> 	mov	ah,02h			; invalid input value
   121 000024D2 EB08                <1> 	jmp	int_15_fnC2_err
   122                              <1> 
   123                              <1> int_15_fnC2_err3:
   124 000024D4 B403                <1> 	mov	ah,03h			; interface error
   125 000024D6 EB04                <1> 	jmp	int_15_fnC2_err
   126                              <1> 
   127                              <1> int_15_fnC2_err5:
   128 000024D8 B405                <1> 	mov	ah,05h			; no driver installed
   129 000024DA EB00                <1> 	jmp	int_15_fnC2_err
   130                              <1> 
   131                              <1> int_15_fnC2_err:
   132 000024DC 804E1001            <1> 	or	byte [bp+int_15_fnC2_flags],1 ; set CF
   133                              <1> 
   134                              <1> int_15_fnC2_exit:
   135 000024E0 88660B              <1> 	mov	byte [bp+int_15_fnC2_ah],ah ; save return status
   136 000024E3 88E0                <1>         mov     al,ah                   ; Output return code to POST Port
   137 000024E5 E680                <1>     	out	post_reg,al
   138 000024E7 E819F8              <1> 	call	kbc_aux_enable		; enable auxiliary device
   139 000024EA 5D                  <1> 	pop	bp
   140 000024EB 1F                  <1> 	pop	ds
   141 000024EC 5A                  <1> 	pop	dx
   142 000024ED 59                  <1> 	pop	cx
   143 000024EE 5B                  <1> 	pop	bx
   144 000024EF 58                  <1> 	pop	ax
   145 000024F0 CF                  <1> 	iret
   146                              <1> 
   147                              <1> ;=========================================================================
   148                              <1> ; int_15_fnC200 - enable / disable PS/2 mouse
   149                              <1> ; Input:
   150                              <1> ;	AX = 0C200h
   151                              <1> ;	BH - sub-function:
   152                              <1> ;		00h - disable
   153                              <1> ;		01h - enable
   154                              <1> ;-------------------------------------------------------------------------
   155                              <1> int_15_fnC200:
   156 000024F1 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
   157 000024F4 80FF01              <1> 	cmp	bh,01h
   158 000024F7 77D3                <1> 	ja	int_15_fnC2_err1	; invalid sub-function
   159                              <1> 
   160                              <1> ; seems to be confusing MS Mouse driver when get error from enable/disable!
   161                              <1> 	;test	byte [mouse_flags_2],80h ; driver installed?
   162                              <1> 	;jz	int_15_fnC2_err5	; no driver installed
   163                              <1> 
   164 000024F9 88F8                <1>         mov     al, bh
   165 000024FB E680                <1>     	out	post_reg,al
   166                              <1>         
   167 000024FD 80FF00              <1> 	cmp	bh,00h
   168 00002500 7404                <1> 	je	.disable
   169                              <1> 
   170 00002502 B0F4                <1> 	mov	al,dev_cmd_enable	; device enable command
   171 00002504 EB02                <1> 	jmp	.send_it
   172                              <1> .disable:
   173 00002506 B0F5                <1> 	mov	al,dev_cmd_disable	; device disable command
   174                              <1> 
   175                              <1> .send_it:
   176 00002508 E8CFF7              <1> 	call	kbc_aux_send
   177 0000250B B408                <1>         mov     ah, 08h                 ; Enable/Disable Error So we don't confuse with C2!
   178 0000250D 72CD                <1> 	jc	int_15_fnC2_err		; error
   179 0000250F EBB3                <1> 	jmp	int_15_fnC2_ok
   180                              <1> 
   181                              <1> ;=========================================================================
   182                              <1> ; int_15_fnC201 - reset PS/2 mouse
   183                              <1> ; Input:
   184                              <1> ;	AX = 0C201h
   185                              <1> ; Output:
   186                              <1> ;	BL - Basic Assurance Test (BAT) completion status
   187                              <1> ;	     0AAh - BAT successful
   188                              <1> ;	     0FCh - BAT error
   189                              <1> ;	BH = device ID
   190                              <1> ;-------------------------------------------------------------------------
   191                              <1> int_15_fnC201:
   192 00002511 B90A00              <1> 	mov	cx,10			; try the reset 10 times
   193                              <1> .1:
   194 00002514 B0FF                <1> 	mov	al,dev_cmd_reset	; reset auxiliary device, set defaults
   195 00002516 E8C1F7              <1> 	call	kbc_aux_send
   196 00002519 7309                <1> 	jnc	.2			; no error - continue
   197 0000251B 80FC03              <1> 	cmp	ah,03h			; timeout error?
   198 0000251E E1F4                <1> 	loopz	.1			; try again
   199 00002520 B406                <1>         mov     ah, 06h                ; Reset Timeout - So we don't confuse with C2!
   200                              <1> 
   201 00002522 EBB8                <1> 	jmp	int_15_fnC2_err		; error
   202                              <1> .2:
   203 00002524 E8A7F7              <1> 	call	kbc_aux_read
   204 00002527 72AB                <1> 	jc	int_15_fnC2_err3	; interface error
   205 00002529 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
   206 0000252C E89FF7              <1> 	call	kbc_aux_read
   207 0000252F 72A3                <1> 	jc	int_15_fnC2_err3	; interface error
   208 00002531 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
   209 00002534 EB8E                <1> 	jmp	int_15_fnC2_ok
   210                              <1> 
   211                              <1> ;=========================================================================
   212                              <1> ; int_15_fnC202 - set sample rate
   213                              <1> ; Input:
   214                              <1> ;	AX = 0C202h
   215                              <1> ;	BH - sample rate:
   216                              <1> ;		00h - 10 samples per second
   217                              <1> ;		01h - 20 samples per second
   218                              <1> ;		02h - 40 samples per second
   219                              <1> ;		03h - 60 samples per second
   220                              <1> ;		04h - 80 samples per second
   221                              <1> ;		05h - 100 samples per second
   222                              <1> ;		06h - 200 samples per second
   223                              <1> ;-------------------------------------------------------------------------
   224                              <1> int_15_fnC202:
   225 00002536 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
   226 00002539 88F8                <1>         mov     al, bh
   227 0000253B E680                <1>     	out	post_reg,al             ; Output to POST Sample Rate 
   228                              <1>         
   229 0000253D 80FF06              <1> 	cmp	bh,06h
   230 00002540 778E                <1> 	ja	int_15_fnC2_err2	; invalid input value
   231 00002542 88FB                <1> 	mov	bl,bh
   232 00002544 B700                <1> 	mov	bh,00h			; rate index in BX
   233                              <1> 
   234 00002546 B0F3                <1> 	mov	al,dev_cmd_rate		; set sample rate
   235 00002548 E88FF7              <1> 	call	kbc_aux_send
   236 0000254B B407                <1>         mov     ah, 07h                 ; Sample Rate - So we don't confuse with C2!
   237                              <1>     
   238 0000254D 728D                <1> 	jc	int_15_fnC2_err		; error
   239                              <1> 
   240 0000254F 2E8A87[5C25]        <1>     cs	mov	al,byte [.rate_table+bx]
   241 00002554 E883F7              <1> 	call	kbc_aux_send
   242 00002557 7283                <1> 	jc	int_15_fnC2_err		; error
   243 00002559 E968FF              <1> 	jmp	int_15_fnC2_ok
   244                              <1> 
   245 0000255C 0A14283C5064C8      <1> .rate_table	db	10, 20, 40, 60, 80, 100, 200
   246                              <1> 	
   247                              <1> ;=========================================================================
   248                              <1> ; int_15_fnC203 - set resolution
   249                              <1> ; Input:
   250                              <1> ;	AX = 0C203h
   251                              <1> ;	BH - resolution value:
   252                              <1> ;		00h - 1 count per millimeter
   253                              <1> ;		01h - 2 counts per millimeter
   254                              <1> ;		02h - 4 counts per millimeter
   255                              <1> ;		03h - 8 counts per millimeter
   256                              <1> ;-------------------------------------------------------------------------
   257                              <1> int_15_fnC203:
   258 00002563 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
   259 00002566 88F8                <1>         mov     al, bh
   260 00002568 E680                <1>     	out	post_reg,al             ; Output to POST Resolution 
   261                              <1> 
   262 0000256A 80FF03              <1> 	cmp	bh,03h
   263 0000256D 7603E95EFF          <1> 	ja	int_15_fnC2_err2	; invalid input value
   264                              <1> 
   265 00002572 B0E8                <1> 	mov	al,aux_cmd_resol	; set resolution
   266 00002574 E863F7              <1> 	call	kbc_aux_send
   267 00002577 B408                <1>         mov     ah, 08h                 ; Set Resolution - So we don't confuse with C2!
   268 00002579 7303E95EFF          <1> 	jc	int_15_fnC2_err		; error
   269                              <1> 
   270 0000257E 88F8                <1> 	mov	al,bh
   271                              <1>         
   272 00002580 E857F7              <1> 	call	kbc_aux_send
   273 00002583 7303E954FF          <1> 	jc	int_15_fnC2_err		; error
   274 00002588 E939FF              <1> 	jmp	int_15_fnC2_ok
   275                              <1> 
   276                              <1> ;=========================================================================
   277                              <1> ; int_15_fnC204 - read device type
   278                              <1> ; Input:
   279                              <1> ;	AX = 0C204h
   280                              <1> ; Output:
   281                              <1> ;	BH = device type
   282                              <1> ;-------------------------------------------------------------------------
   283                              <1> int_15_fnC204:
   284 0000258B B0F2                <1> 	mov	al,dev_cmd_dev_id	; read device type
   285 0000258D E84AF7              <1> 	call	kbc_aux_send
   286 00002590 B409                <1>         mov     ah, 09h                 ; Read Device Type - So we don't confuse with C2!
   287 00002592 7303E945FF          <1> 	jc	int_15_fnC2_err		; error
   288 00002597 E834F7              <1> 	call	kbc_aux_read
   289 0000259A 7303E935FF          <1> 	jc	int_15_fnC2_err3
   290 0000259F 884609              <1> 	mov	byte [bp+int_15_fnC2_bh],al
   291 000025A2 E680                <1>     	out	post_reg,al             ; Output to POST Device Type
   292 000025A4 E91DFF              <1> 	jmp	int_15_fnC2_ok
   293                              <1> 
   294                              <1> ;=========================================================================
   295                              <1> ; int_15_fnC205 - initialize PS/2 mouse
   296                              <1> ; Input:
   297                              <1> ;	AX = 0C205h
   298                              <1> ;	BH = data package size in bytes (03h or 04h)
   299                              <1> ; Output:
   300                              <1> ;	none
   301                              <1> ;-------------------------------------------------------------------------
   302                              <1> int_15_fnC205:
   303 000025A7 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
   304 000025AA 88F8                <1>         mov     al, bh
   305 000025AC E680                <1>     	out	post_reg,al             ; Output to POST Package Size before -1
   306                              <1> 
   307 000025AE 80FF03              <1> 	cmp	bh,03h
   308 000025B1 7303E91AFF          <1> 	jb	int_15_fnC2_err2	; invalid input value
   309 000025B6 80FF04              <1> 	cmp	bh,04h
   310 000025B9 7603E912FF          <1> 	ja	int_15_fnC2_err2	; invalid input value
   311 000025BE FECF                <1> 	dec	bh
   312                              <1> 
   313 000025C0 A02700              <1> 	mov	al,byte [mouse_flags_2]
   314 000025C3 24F8                <1> 	and	al,0F8h			; mask out package size bits
   315 000025C5 08F8                <1> 	or	al,bh			; add the new package size
   316 000025C7 A22700              <1> 	mov	byte [mouse_flags_2],al
   317                              <1> 
   318 000025CA B90500              <1> 	mov	cx,5			; try the reset 5 times
   319                              <1> .1:
   320 000025CD B0FF                <1> 	mov	al,dev_cmd_reset	; reset auxiliary device, set defaults
   321 000025CF E808F7              <1> 	call	kbc_aux_send
   322 000025D2 730A                <1> 	jnc	.2			; no error - continue
   323 000025D4 80FC03              <1> 	cmp	ah,03h			; timeout error?
   324 000025D7 E1F4                <1> 	loopz	.1			; try again
   325                              <1> 
   326 000025D9 B40A                <1>         mov     ah, 0Ah                 ; Initialisze Error - So we don't confuse with C2!
   327 000025DB E9FEFE              <1> 	jmp	int_15_fnC2_err		; error
   328                              <1> .2:
   329 000025DE E8EDF6              <1> 	call	kbc_aux_read
   330 000025E1 7303E9EEFE          <1> 	jc	int_15_fnC2_err3	; interface error
   331 000025E6 E8E5F6              <1> 	call	kbc_aux_read
   332 000025E9 7303E9E6FE          <1> 	jc	int_15_fnC2_err3	; interface error
   333 000025EE E9D3FE              <1> 	jmp	int_15_fnC2_ok
   334                              <1> 
   335                              <1> ;=========================================================================
   336                              <1> ; int_15_fnC206 - set scaling or get status
   337                              <1> ; Input:
   338                              <1> ;	AX = 0C206h
   339                              <1> ;	BH - sub-function:
   340                              <1> ;		00h - return status
   341                              <1> ;		01h - set scaling factor to 1:1
   342                              <1> ;		02h - set scaling factor to 2:1
   343                              <1> ; Output:
   344                              <1> ;	if BH = 00h on entry:
   345                              <1> ;		BL - status byte 1:
   346                              <1> ;			bit 0 = 1 - right button pressed
   347                              <1> ;			bit 1 = 0 - reserved
   348                              <1> ;			bit 2 = 1 - left button pressed
   349                              <1> ;			bit 3 = 0 - reserved
   350                              <1> ;			bit 4 = 0 - 1:1 scaling, 1 - 2:1 scaling
   351                              <1> ;			bit 5 = 0 - disable, 1 - enable
   352                              <1> ;			bit 6 = 0 - stream mode, 1 - remote mode
   353                              <1> ;			bit 7 = 0 - reserved
   354                              <1> ;		CL - status byte 2:
   355                              <1> ;			00h - 1 count per millimeter
   356                              <1> ;			01h - 2 counts per millimeter
   357                              <1> ;			02h - 4 counts per millimeter
   358                              <1> ;			03h - 8 counts per millimeter
   359                              <1> ;		DL - status byte 3:
   360                              <1> ;			0Ah - 10 samples per second
   361                              <1> ;			14h - 20 samples per second
   362                              <1> ;			3Ch - 40 samples per second
   363                              <1> ;			3Ch - 60 samples per second
   364                              <1> ;			50h - 80 samples per second
   365                              <1> ;			64h - 100 samples per second
   366                              <1> ;			0C8h - 200 samples per second
   367                              <1> ;-------------------------------------------------------------------------
   368                              <1> int_15_fnC206:
   369 000025F1 8A7E09              <1> 	mov	bh,byte [bp+int_15_fnC2_bh]
   370 000025F4 88F8                <1>         mov     al, bh
   371 000025F6 E680                <1>     	out	post_reg,al             ; Output to POST Sub Function
   372                              <1>         
   373 000025F8 80FF02              <1> 	cmp	bh,02h
   374 000025FB 7603E9CCFE          <1> 	ja	int_15_fnC2_err1	; invalid sub-function
   375 00002600 743B                <1> 	je	.scale_2x1
   376 00002602 80FF01              <1> 	cmp	bh,01h
   377 00002605 743A                <1> 	je	.scale_1x1
   378                              <1> 					; BH == 0, return status
   379 00002607 B0E9                <1> 	mov	al,aux_cmd_status	; request status command
   380 00002609 E8CEF6              <1> 	call	kbc_aux_send
   381 0000260C B40B                <1>         mov     ah, 0Bh                 ; Get status Error - So we don't confuse with C2!
   382 0000260E 7303E9C9FE          <1> 	jc	int_15_fnC2_err		; error
   383 00002613 E8B8F6              <1> 	call	kbc_aux_read
   384 00002616 7303E9B9FE          <1> 	jc	int_15_fnC2_err3	; interface error
   385 0000261B 884608              <1> 	mov	byte [bp+int_15_fnC2_bl],al
   386 0000261E E680                <1>     	out	post_reg,al             ; Output to POST Status Byte 0
   387                              <1> 
   388 00002620 E8ABF6              <1> 	call	kbc_aux_read
   389 00002623 7303E9ACFE          <1> 	jc	int_15_fnC2_err3	; interface error
   390 00002628 884606              <1> 	mov	byte [bp+int_15_fnC2_cl],al
   391 0000262B E680                <1>     	out	post_reg,al             ; Output to POST Status Byte 1
   392                              <1> 
   393 0000262D E89EF6              <1> 	call	kbc_aux_read
   394 00002630 7303E99FFE          <1> 	jc	int_15_fnC2_err3	; interface error
   395 00002635 884604              <1> 	mov	byte [bp+int_15_fnC2_dl],al
   396 00002638 E680                <1>     	out	post_reg,al             ; Output to POST Status Byte 2
   397                              <1> 	
   398 0000263A E987FE              <1>         jmp	int_15_fnC2_ok
   399                              <1> 
   400                              <1> .scale_2x1:
   401 0000263D B0E7                <1> 	mov	al,aux_cmd_scale21	; set 2:1 scaling factor command
   402 0000263F EB02                <1> 	jmp	.send_it
   403                              <1> .scale_1x1:
   404 00002641 B4E6                <1> 	mov	ah,aux_cmd_scale11	; set 1:1 scaling factor command
   405                              <1> .send_it:
   406                              <1> 
   407                              <1>         ; MS Mouse driver gets confused by Scaling and not called by Cute Mouse so disable.
   408                              <1> 
   409                              <1> 	;call	kbc_aux_send
   410                              <1> 	;jc	int_15_fnC2_err		; error
   411 00002643 E97EFE              <1> 	jmp	int_15_fnC2_ok
   412                              <1> 
   413                              <1> ;=========================================================================
   414                              <1> ; int_15_fnC207 - set PS/2 mouse driver
   415                              <1> ; Input:
   416                              <1> ;	AX = 0C207h
   417                              <1> ;	ES:BX - pointer to mouse driver
   418                              <1> ;-------------------------------------------------------------------------
   419                              <1> int_15_fnC207:
   420 00002646 8B5E08              <1> 	mov	bx,word [bp+int_15_fnC2_bl]
   421 00002649 891E2200            <1> 	mov	word [mouse_driver],bx
   422 0000264D 88D8                <1>         mov     al, bl
   423 0000264F E680                <1>     	out	post_reg,al             ; Output to POST bl
   424 00002651 88F8                <1>         mov     al, bh
   425 00002653 E680                <1>     	out	post_reg,al             ; Output to POST bh
   426                              <1>         
   427 00002655 8CC0                <1> 	mov	ax,es
   428 00002657 A32400              <1> 	mov	word [mouse_driver+2],ax
   429 0000265A E680                <1>     	out	post_reg,al             ; Output to POST al
   430 0000265C 86C4                <1>         xchg    al, ah                  ; This wont affect or below!
   431 0000265E E680                <1>     	out	post_reg,al             ; Output to POST ah
   432                              <1>         
   433 00002660 09C0                <1> 	or	ax,ax
   434 00002662 750C                <1> 	jnz	.set_handler
   435 00002664 09DB                <1> 	or	bx,bx
   436 00002666 7508                <1> 	jnz	.set_handler
   437                              <1> ; remove handler
   438 00002668 802627007F          <1> 	and	byte [mouse_flags_2],~80h
   439 0000266D E954FE              <1> 	jmp	int_15_fnC2_ok
   440                              <1> 
   441                              <1> .set_handler:
   442 00002670 800E270080          <1> 	or	byte [mouse_flags_2],80h
   443 00002675 E94CFE              <1> 	jmp	int_15_fnC2_ok
   444                              <1> 
   445                              <1> ;=========================================================================
   446                              <1> ; int_74 - PS/2 mouse hardware interrupt service routine
   447                              <1> ;-------------------------------------------------------------------------
   448                              <1> int_74:
   449 00002678 FB                  <1> 	sti
   450 00002679 50                  <1> 	push	ax
   451 0000267A 53                  <1> 	push	bx
   452 0000267B 1E                  <1> 	push	ds
   453 0000267C B84000              <1> 	mov	ax,biosdseg
   454 0000267F 8ED8                <1> 	mov	ds,ax
   455                              <1> 
   456 00002681 B074                <1>         mov     al, 074h    ; Output debug for POST
   457 00002683 E680                <1>         out	post_reg,al
   458 00002685 A10E00              <1> 	mov	ax,word [ebda_segment]
   459 00002688 8ED8                <1> 	mov	ds,ax
   460                              <1> 
   461 0000268A E680                <1>         out	post_reg,al  ; ebda_segment LSB
   462 0000268C 88E0                <1>         mov     al,ah
   463 0000268E E680                <1>         out	post_reg,al  ; ebda_segment MSB
   464                              <1>         
   465 00002690 E464                <1> 	in	al,kbc_status_reg
   466 00002692 2421                <1> 	and	al,kbc_stat_obf | kbc_stat_aobf
   467 00002694 3C21                <1> 	cmp	al,kbc_stat_obf | kbc_stat_aobf
   468 00002696 7403E98100          <1> 	jne	.exit			; no mouse data in the buffer
   469                              <1> 
   470 0000269B E460                <1> 	in	al,kbc_data_reg
   471 0000269D 88C4                <1> 	mov	ah,al			; save to AH
   472                              <1> 
   473 0000269F E680                <1>         out	post_reg,al  ; Mouse Data
   474                              <1> 
   475 000026A1 A02700              <1> 	mov	al,byte [mouse_flags_2]
   476 000026A4 E680                <1>         out	post_reg,al  ; Mouse Flags 2
   477                              <1> 
   478 000026A6 A880                <1> 	test	al,80h
   479 000026A8 7472                <1> 	jz	.exit			; no mouse driver installed
   480                              <1> 
   481 000026AA A02600              <1> 	mov	al,byte [mouse_flags_1]
   482 000026AD E680                <1>         out	post_reg,al  ; Mouse Flags 1
   483                              <1> 
   484 000026AF 2407                <1> 	and	al,07h			; bits 2-0 are index in buffer
   485 000026B1 BB2800              <1> 	mov	bx,mouse_data
   486 000026B4 00C3                <1> 	add	bl,al			; note: we shouldn't have an overflow...
   487 000026B6 8827                <1> 	mov	byte [bx],ah		; save data to the buffer
   488                              <1> 
   489 000026B8 8A262700            <1> 	mov	ah,byte [mouse_flags_2]
   490 000026BC 80E407              <1> 	and	ah,07h			; bits 2-0 are package count-1
   491                              <1> 
   492 000026BF 38E0                <1> 	cmp	al,ah			; enough bytes in the buffer?
   493 000026C1 7306                <1> 	jae	.call_driver
   494                              <1> 
   495 000026C3 FE062600            <1> 	inc	byte [mouse_flags_1]	; increment the index
   496 000026C7 EB53                <1> 	jmp	.exit
   497                              <1> 
   498                              <1> .call_driver:
   499                              <1> 
   500                              <1> ;-------------------------------------------------------------------------
   501                              <1> ; This BIOS supports 3 bytes (standard PS/2) and 4 bytes (MS Intellimouse)
   502                              <1> ; package sizes.
   503                              <1> ; Stack layout (bX refers to byte position X in mouse_data buffer):
   504                              <1> ; 	- for 3 bytes package: 00 00 b2 00 b1 00 b0 00
   505                              <1> ; 	- for 4 bytes package: 00 00 b3 00 b2 00 b0 b1
   506                              <1> ;-------------------------------------------------------------------------
   507                              <1> 
   508 000026C9 80FC03              <1> 	cmp	ah,03h			; check 4 bytes package size?
   509 000026CC 7413                <1> 	jz	.four_bytes
   510                              <1> 					; put data in stack for 3 bytes format
   511 000026CE 31C0                <1> 	xor	ax,ax
   512 000026D0 A02800              <1> 	mov	al,byte [mouse_data]
   513 000026D3 50                  <1> 	push	ax
   514 000026D4 A02900              <1> 	mov	al,byte [mouse_data+1]
   515 000026D7 50                  <1> 	push	ax
   516 000026D8 A02A00              <1> 	mov	al,byte [mouse_data+2]
   517 000026DB 50                  <1> 	push	ax
   518 000026DC B000                <1> 	mov	al,00h
   519 000026DE 50                  <1> 	push	ax
   520 000026DF EB15                <1> 	jmp	.do_call
   521                              <1> 
   522                              <1> .four_bytes:				; put data in stack for 4 bytes format
   523 000026E1 8A262900            <1> 	mov	ah,byte [mouse_data+1]
   524 000026E5 A02800              <1> 	mov	al,byte [mouse_data]
   525 000026E8 50                  <1> 	push	ax
   526 000026E9 B400                <1> 	mov	ah,00h
   527 000026EB A02A00              <1> 	mov	al,byte [mouse_data+2]
   528 000026EE 50                  <1> 	push	ax
   529 000026EF A02B00              <1> 	mov	al,byte [mouse_data+3]
   530 000026F2 50                  <1> 	push	ax
   531 000026F3 B000                <1> 	mov	al,00h
   532 000026F5 50                  <1> 	push	ax
   533                              <1> 
   534                              <1> .do_call:
   535 000026F6 B04D                <1>         mov     al, 04dh ; M for Mouse driver
   536 000026F8 E680                <1>         out	post_reg,al
   537 000026FA A02200              <1>         mov     al,[mouse_driver]
   538 000026FD E680                <1>         out	post_reg,al
   539 000026FF A02300              <1>         mov     al,[mouse_driver+1]
   540 00002702 E680                <1>         out	post_reg,al
   541 00002704 A02400              <1>         mov     al,[mouse_driver+2]
   542 00002707 E680                <1>         out	post_reg,al
   543 00002709 A02500              <1>         mov     al,[mouse_driver+3]
   544 0000270C E680                <1>         out	post_reg,al
   545 0000270E B000                <1> 	mov	al,00h
   546                              <1>         
   547 00002710 FF1E2200            <1> 	call	far [mouse_driver]
   548 00002714 83C408              <1> 	add	sp,0008h		; remove parameters from the stack
   549 00002717 80262600F8          <1> 	and	byte [mouse_flags_1],0F8h ; reset mouse data index
   550                              <1> 
   551                              <1> .exit:
   552 0000271C B020                <1> 	mov	al,20h
   553 0000271E E6A0                <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
   554 00002720 E620                <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
   555 00002722 1F                  <1> 	pop	ds
   556 00002723 5B                  <1> 	pop	bx
   557 00002724 58                  <1> 	pop	ax
   558 00002725 CF                  <1> 	iret
   286                                  %endif
   287                                  %include	"sound.inc"		; sound test
     1                              <1> ;=========================================================================
     2                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25 00002726 6908                <1> notes	dw	pic_freq/554		; D flat
    26 00002728 FFFF                <1> 	dw	-1			; silent
    27 0000272A D310                <1> 	dw	pic_freq/277		; D flat
    28 0000272C 980C                <1> 	dw	pic_freq/370		; G flat
    29 0000272E D310                <1> 	dw	pic_freq/277		; D flat
    30 00002730 3B0B                <1> 	dw	pic_freq/415		; A flat
    31 00002732 0000                <1> 	dw	0
    32                              <1> 
    33                              <1> ;=========================================================================
    34                              <1> ; sound - Play power-on sound.
    35                              <1> ; Input:
    36                              <1> ;	none
    37                              <1> ; Output:
    38                              <1> ;	none, destroys some registers
    39                              <1> ;-------------------------------------------------------------------------
    40                              <1> sound:
    41 00002734 FC                  <1> 	cld
    42 00002735 BE[2627]            <1> 	mov	si,notes		; set SI to notes table
    43                              <1> 
    44 00002738 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
    45 0000273A E643                <1> 	out	pit_ctl_reg,al
    46                              <1> 
    47                              <1> .loop:
    48 0000273C 2EAD                <1>     cs	lodsw				; load next note to AX
    49 0000273E 83F800              <1> 	cmp	ax,0
    50 00002741 7422                <1> 	jz	.exit
    51 00002743 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
    52 00002745 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
    53 00002747 88E0                <1> 	mov	al,ah
    54 00002749 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
    55                              <1> 
    56 0000274B E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
    57 0000274D 0C03                <1>         or      al,03h			; turn on the speaker
    58 0000274F E661                <1>         out     ppi_pb_reg,al		; write the new value
    59                              <1> 
    60                              <1> .silent:
    61 00002751 B90030              <1> 	mov	cx,3000h
    62 00002754 E8BBEA              <1> 	call	delay_15us		; delay while note is playing
    63                              <1> 
    64 00002757 E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
    65 00002759 24FC                <1> 	and	al,0FCh			; turn off the speaker
    66 0000275B E661                <1>         out     ppi_pb_reg,al		; write the new value
    67                              <1> 
    68 0000275D B90001              <1>         mov     cx,0100h
    69 00002760 E8AFEA              <1> 	call	delay_15us		; delay after the note
    70                              <1>         
    71 00002763 EBD7                <1>         jmp     .loop			; play the next note
    72                              <1> .exit:
    73 00002765 C3                  <1> 	ret
    74                              <1> 
    75                              <1> ;=========================================================================
    76                              <1> ; beep - Play a beep sound
    77                              <1> ; Input:
    78                              <1> ;	BL - duration in 0.1 second
    79                              <1> ; Output:
    80                              <1> ;	BL = 0
    81                              <1> ;-------------------------------------------------------------------------
    82                              <1> beep:
    83 00002766 50                  <1> 	push	ax
    84 00002767 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
    85 00002769 E643                <1> 	out	pit_ctl_reg,al
    86 0000276B B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
    87 0000276E E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
    88 00002770 88E0                <1> 	mov	al,ah
    89 00002772 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
    90 00002774 E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
    91 00002776 0C03                <1> 	or	al,03h			; turn on the speaker
    92 00002778 E661                <1> 	out	ppi_pb_reg,al		; write the new value
    93                              <1> .loop:
    94 0000277A B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
    95 0000277D E892EA              <1> 	call	delay_15us
    96 00002780 FECB                <1> 	dec	bl
    97 00002782 75F6                <1> 	jnz	.loop
    98 00002784 3403                <1> 	xor	al,03h			; turn off the speaker
    99 00002786 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   100 00002788 58                  <1> 	pop	ax
   101 00002789 C3                  <1> 	ret
   288                                  %include	"cpu.inc"		; CPU and FPU detection
     1                              <1> ;=========================================================================
     2                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
     3                              <1> ;-------------------------------------------------------------------------
     4                              <1> ;
     5                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
     8                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
    26                              <1> 
    27                              <1> ;=========================================================================
    28                              <1> ; detect_cpu - detect and print CPU type
    29                              <1> ; Note:
    30                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
    31                              <1> ;	  incorrect results if used on other CPU types.
    32                              <1> ;-------------------------------------------------------------------------
    33                              <1> detect_cpu:
    34 0000278A 50                  <1> 	push	ax
    35 0000278B 56                  <1> 	push	si
    36 0000278C B021                <1> 	mov	al,e_cpu_detect
    37 0000278E E680                <1> 	out	post_reg,al
    38                              <1> 
    39 00002790 BE[9900]            <1> 	mov	si,msg_cpu
    40 00002793 E81A01              <1> 	call	print
    41                              <1> 
    42                              <1> ; test for NEC V20
    43 00002796 B80101              <1> 	mov	ax,0101h
    44 00002799 D510                <1> 	aad	10h			; NEC V20 ignores the argument
    45 0000279B 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
    46 0000279D 7452                <1> 	je	.nec_v20
    47                              <1> 
    48                              <1> ; not NEC V20, test for various 8088 versions
    49                              <1> .i8088:					; 8088 - NMOS version of 8088
    50 0000279F FA                  <1> 	cli				; disable interrupts
    51 000027A0 1E                  <1> 	push	ds
    52 000027A1 31C0                <1> 	xor	ax,ax
    53 000027A3 8ED8                <1> 	mov	ds,ax			; interrupt table segment
    54 000027A5 B8[0B28]            <1> 	mov	ax,.int_01		; new int 01h offset
    55 000027A8 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
    56 000027AC 50                  <1> 	push	ax			; save to stack
    57 000027AD 8CC8                <1> 	mov	ax,cs			; new int 01h segment
    58 000027AF 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
    59 000027B3 50                  <1> 	push	ax			; save to stack
    60 000027B4 9C                  <1> 	pushf				; push flags to stack (save)
    61 000027B5 9C                  <1> 	pushf				; push flags to stack (modify)
    62 000027B6 58                  <1> 	pop	ax			; and move them to AX
    63 000027B7 0D0001              <1> 	or	ax,flags_tf		; set TF
    64 000027BA 50                  <1> 	push	ax
    65 000027BB 31C0                <1> 	xor	ax,ax			; AX = 0
    66 000027BD 9D                  <1> 	popf				; load modified value to FLAGS register
    67                              <1> 					; enable single-step
    68 000027BE 90                  <1> 	nop
    69 000027BF 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
    70                              <1> 					; after PUSH SREG instructions
    71                              <1> .push_sreg:				; and will not single-step to here
    72 000027C0 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
    73                              <1> 					; after modifying segment registers
    74                              <1> .pop_sreg:				; and will not single-step to here
    75 000027C1 90                  <1> 	nop
    76 000027C2 9D                  <1> 	popf				; restore original FLAGS, disable
    77                              <1> 					; single-step
    78                              <1> 
    79 000027C3 5E                  <1> 	pop	si			; get original int 01h segment
    80 000027C4 89360600            <1> 	mov	word [6],si		; save it to interrupt table
    81 000027C8 5E                  <1> 	pop	si			; get original int 01h offset
    82 000027C9 89360400            <1> 	mov	word [4],si		; save it to interrupt table
    83 000027CD 1F                  <1> 	pop	ds
    84 000027CE FB                  <1> 	sti				; enable interrupts
    85 000027CF 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
    86 000027D2 740D                <1> 	jz	.i8088_78
    87                              <1> 
    88 000027D4 83F802              <1> 	cmp	ax,0002h
    89 000027D7 7410                <1> 	jz	.i8088_81
    90                              <1> 
    91                              <1> .harris:				; Harris / Intersil 80C88
    92 000027D9 BE[6201]            <1> 	mov	si,msg_cpu_harris
    93 000027DC E8D100              <1> 	call	print
    94 000027DF EB16                <1> 	jmp	.cpu_freq
    95                              <1> 
    96                              <1> .i8088_78:
    97 000027E1 BE[D300]            <1> 	mov	si,msg_cpu_8088_78
    98 000027E4 E8C900              <1> 	call	print
    99 000027E7 EB0E                <1> 	jmp	.cpu_freq
   100                              <1> 
   101                              <1> .i8088_81:
   102 000027E9 BE[3301]            <1> 	mov	si,msg_cpu_8088_81
   103 000027EC E8C100              <1> 	call	print
   104 000027EF EB06                <1> 	jmp	.cpu_freq
   105                              <1> 
   106                              <1> .nec_v20:
   107                              <1> %ifdef MACHINE_HOMEBREW8088
   108                              <1> ; Test for NEC V40
   109                              <1> ; NEC V40 has on-chip configuration registers at 0FFE0h-0FFFFh I/0 addresses.
   110                              <1> ; The code below tries to modify the value of 0FFFE0 register and read it back.
   111                              <1> ; If the value is stored, it is assumed to be a NEC V40 CPU
   112                              <1> 	push	dx
   113                              <1> 	mov	dx,0FFE0h	; Use 0FFFE0h register for V40 tests
   114                              <1> 	in	al,dx		; read the original value
   115                              <1> 	mov	ah,al		; store the orginal value in AH
   116                              <1> 	xor	al,0FFh		; invert all the bits
   117                              <1> 	out	dx,al		; write the inverted value
   118                              <1> 	in	al,dx		; read it back
   119                              <1> 	xor	al,0FFh		; invert all the bits again
   120                              <1> 	cmp	al,ah		; compare with the original value
   121                              <1> 	jne	.not_v40
   122                              <1> 	out	dx,al		; write the original value
   123                              <1> 	in	al,dx		; read it back again
   124                              <1> 	cmp	al,ah		; compare with the original value
   125                              <1> 	jne	.not_v40
   126                              <1> 	pop	dx
   127                              <1> 	mov	si,msg_cpu_nec_v40
   128                              <1> 	call	print
   129                              <1> 	jmp	.cpu_freq
   130                              <1> 
   131                              <1> .not_v40:
   132                              <1> 	pop	dx
   133                              <1> %endif ; MACHINE_HOMEBREW8088
   134 000027F1 BE[7801]            <1> 	mov	si,msg_cpu_nec_v20
   135 000027F4 E8B900              <1> 	call	print
   136                              <1> 
   137                              <1> .cpu_freq:
   138                              <1> 
   139                              <1> %ifdef TURBO_MODE
   140                              <1> %ifdef BIOS_SETUP
   141                              <1> ; print CPU clock frequency
   142                              <1> 
   143                              <1> 	mov	si,msg_at
   144                              <1> 	call	print
   145                              <1> 
   146                              <1> 	push	ax
   147                              <1> 	call	get_config_a		; read BIOS configuration byte A
   148                              <1> 	call	print_cpu_clk
   149                              <1> 	pop	ax
   150                              <1> 
   151                              <1> %endif ; BIOS_SETUP
   152                              <1> %endif ; TURBO_MODE
   153                              <1> 
   154 000027F7 BE[8B00]            <1> 	mov	si,msg_crlf
   155 000027FA E8B300              <1> 	call	print
   156                              <1> 
   157 000027FD 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   158 00002800 7506                <1> 	jnz	.exit
   159 00002802 BE[E200]            <1> 	mov	si,msg_cpu_bug
   160 00002805 E8A800              <1> 	call	print
   161                              <1> 
   162                              <1> 
   163                              <1> 
   164                              <1> .exit:
   165                              <1> %ifdef MACHINE_HOMEBREW8088
   166                              <1> 	call	.estimate_clock
   167                              <1> %endif ; MACHINE_HOMEBREW8088
   168 00002808 5E                  <1> 	pop	si
   169 00002809 58                  <1> 	pop	ax
   170 0000280A C3                  <1> 	ret
   171                              <1> 
   172                              <1> %ifdef MACHINE_HOMEBREW8088
   173                              <1> ; Estimate CPU clock frequency
   174                              <1> ; Algorithm:
   175                              <1> ; Run a cycle that's setup + a loop of 100 "AAA".
   176                              <1> ; That takes N ticks of the timer, and it includes N1 of actual operations + N2 wait-states from loading the instructions.
   177                              <1> ; Then run similar setup + a loop of 100 "AAM".  That takes M ticks, which is M1 actual operations + N2 wait states.
   178                              <1> ; So M - N will remove the "wait state" factor and be how many ticks it took to do "the difference in work between 100 AAAs and 100 AAMs"
   179                              <1> ; Since that's a fixed number of CPU cycles, the M-N value is an inverse of the CPU clock and we can divide by a constant (determined experimentally) to get a reasonable MHz figure
   180                              <1> ; independent of wait-states.  Note this does not compensate for external variations (i. e. DRAM refresh or a device that seizes the bus)
   181                              <1> ; It's not hyper-accurate-- it's often off by a few hundred KHz, and it can vary from run to run due to timer noise, but it should be enough to differentiate the major speed grades
   182                              <1> ; A further possible cleanup would be to "bin" the results-- anything below 5MHz as 4.77, anything 7.5-8.5 as 8, etc.
   183                              <1> .estimate_clock:
   184                              <1> 	push	dx
   185                              <1> 	push	ax
   186                              <1> 	push	cx
   187                              <1> 	push	bx
   188                              <1> 	push	si
   189                              <1> 	mov	si,msg_est
   190                              <1> 	cli				; Disable interrupts for better accuracy
   191                              <1> 	call	print
   192                              <1> 
   193                              <1> 	call	io_wait_latch
   194                              <1> 	push	ax
   195                              <1> 	xor	ax,ax
   196                              <1> ; Must be unrolled or it behaves inconsistently on different waitstates IME
   197                              <1> 	%rep 100
   198                              <1> 	aam
   199                              <1> 	%endrep
   200                              <1> 	call	io_wait_latch
   201                              <1> 	sti
   202                              <1> 	pop	bx
   203                              <1> 	cmp	ax,bx
   204                              <1> 	jae	.second_scan_is_bigger_simple
   205                              <1> 	sub	bx,ax
   206                              <1> 	jmp	.sub_done_simple
   207                              <1> 
   208                              <1> .second_scan_is_bigger_simple:
   209                              <1> 	mov	cx,0FFFFh
   210                              <1> 	sub	cx,ax
   211                              <1> 	add	bx,cx
   212                              <1> 
   213                              <1> .sub_done_simple:
   214                              <1> 	push	bx	; Save the runtime for the faster instruction
   215                              <1> 	cli
   216                              <1> 	call	io_wait_latch
   217                              <1> 	push	ax
   218                              <1> 	xor	ax,ax
   219                              <1> 	%rep 100
   220                              <1> 	mul	cl
   221                              <1> 	%endrep
   222                              <1> 	call	io_wait_latch
   223                              <1> 	sti
   224                              <1> 	pop	bx
   225                              <1> 	cmp	ax,bx
   226                              <1> 	jae	.second_scan_is_bigger
   227                              <1> 	sub	bx,ax
   228                              <1> 	jmp	.sub_done
   229                              <1> 
   230                              <1> .second_scan_is_bigger:
   231                              <1> 	mov	cx,0FFFFh
   232                              <1> 	sub	cx,ax
   233                              <1> 	add	bx,cx
   234                              <1> 
   235                              <1> .sub_done:
   236                              <1> 	pop	ax	; pull the count from the simple run
   237                              <1> 	sub	bx,ax
   238                              <1> 	; We'd expect BX to be the amount of clock ticks corresponding to (some large number) more cycles
   239                              <1> 
   240                              <1> 
   241                              <1> ;	mov ax,bx			; Refinement tool:  Display the number of clock ticks the loop generated.
   242                              <1> ;	call	print_dec		; Uncomment this code and run it on your machine and it will say things like "244 ticks ~ 8.00MHz"
   243                              <1> ;	mov	si,msg_ticks   ; Calculate (number of ticks) * 100 * (CPU actual MHz)
   244                              <1> ;	call	print			; and place it in DX:AX as the "clock divider" for the CPU type you're using in the code below
   245                              <1> ;	mov	ax,0E20h
   246                              <1> ;	int	10h
   247                              <1> 
   248                              <1> 	mov	ax,0101h		; Repeat the NEC CPU test
   249                              <1> 	aad	10h			; NEC V20 ignores the argument
   250                              <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
   251                              <1> 	jne	.clock_divider_8088
   252                              <1> 	mov	dx,03h			; "Clock Divider" for NEC CPUs.  Value was based on an 10MHz V40: ~214 ticks, so the expected value is 1000*214 = 214000 = 343F0H
   253                              <1> 	mov	ax,43F0h		; On the V-series, AAM is faster than MUL (by quite a bit), so a large difference for the clock speed is expected.
   254                              <1> 	jmp	.clock_divider_set
   255                              <1> 
   256                              <1> .clock_divider_8088:
   257                              <1> 	neg	bx			; "Clock Divider" for 8088 CPUs.  Value was based on a 4.77MHz 8088: It shows as 65186 ticks, but on an 8088, MUL is faster than AAM
   258                              <1> 	mov	dx,0002h		; This means that BX is negative here, so flip the sign and we get 349 ticks... 349 ticks * 477  = 166473 = 28A49H.
   259                              <1> 	mov	ax,8A49h
   260                              <1> 
   261                              <1> .clock_divider_set:
   262                              <1> 	div	bx
   263                              <1> 	mov	bx,100			; Split to integer and fractional parts
   264                              <1> 	div	bl
   265                              <1> 
   266                              <1> 	mov	bx,ax
   267                              <1> 	xor	ah,ah
   268                              <1> 	call	print_dec		; Integer part
   269                              <1> 	mov 	ax,0E2Eh		; decimal point
   270                              <1> 	int	10h
   271                              <1> 	xor	ah,ah
   272                              <1> 	mov	al,bh
   273                              <1> 	cmp	al,10
   274                              <1> 	jae	.two_digits
   275                              <1> 	push	ax
   276                              <1> 	mov	ax,0E30h		; leading zero
   277                              <1> 	int	10h
   278                              <1> 	pop	ax
   279                              <1> 
   280                              <1> .two_digits:
   281                              <1> 	call	print_dec
   282                              <1> 	mov	si,msg_mhz
   283                              <1> 	call	print
   284                              <1> 	mov	si,msg_crlf
   285                              <1> 	call	print
   286                              <1> 	pop	dx
   287                              <1> 	pop	si
   288                              <1> 	pop	bx
   289                              <1> 	pop	cx
   290                              <1> 	pop	ax
   291                              <1> 	ret
   292                              <1> %endif
   293                              <1> 
   294                              <1> ; stack frame after "push bp"
   295                              <1> ; BP - word [BP]
   296                              <1> ; IP - word [BP+2]
   297                              <1> ; CS - word [BP+4]
   298                              <1> ; FLAGS - word [BP+6]
   299                              <1> .int_01:
   300 0000280B 55                  <1> 	push	bp
   301 0000280C 89E5                <1> 	mov	bp,sp
   302 0000280E 817E02[C127]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
   303 00002813 7504                <1> 	jne	.1
   304 00002815 B001                <1> 	mov	al,01h			; (C) INTEL '79
   305 00002817 EB09                <1> 	jmp	.int_01_exit
   306                              <1> .1:
   307 00002819 817E02[C027]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
   308 0000281E 7502                <1> 	jne	.int_01_exit
   309 00002820 B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
   310                              <1> .int_01_exit:
   311 00002822 5D                  <1> 	pop	bp
   312 00002823 CF                  <1> 	iret
   313                              <1> 
   314                              <1> ;=========================================================================
   315                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> test_word	equ	03FEh		; right at the end of interrupt table
   318                              <1> detect_fpu:
   319 00002824 50                  <1> 	push	ax
   320 00002825 51                  <1> 	push	cx
   321 00002826 56                  <1> 	push	si
   322 00002827 B022                <1> 	mov	al,e_fpu_detect
   323 00002829 E680                <1> 	out	post_reg,al
   324                              <1> 
   325 0000282B BE[B600]            <1> 	mov	si,msg_fpu
   326 0000282E E87F00              <1> 	call	print
   327 00002831 DBE3                <1> 	fninit				; initialize coprocessor
   328 00002833 B90300              <1> 	mov	cx,3
   329                              <1> .wait:
   330 00002836 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
   331                              <1> 					;   (can't use fwait, since it could
   332                              <1> 					;   be no coprocessor at all)
   333 00002838 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
   334 0000283C C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
   335 00002842 D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
   336 00002846 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
   337 0000284C 750D                <1> 	jne	.no_fpu			;   after finit
   338                              <1> 
   339                              <1> .fpu:
   340 0000284E BE[8001]            <1> 	mov	si,msg_fpu_present
   341 00002851 E85C00              <1> 	call	print
   342 00002854 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
   343 00002859 EB06                <1> 	jmp	.exit
   344                              <1> 
   345                              <1> .no_fpu:
   346                              <1> 
   347 0000285B BE[B202]            <1> 	mov	si,msg_absent
   348 0000285E E84F00              <1> 	call	print
   349                              <1> 
   350                              <1> .exit:
   351 00002861 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
   352                              <1> 
   353 00002865 5E                  <1> 	pop	si
   354 00002866 59                  <1> 	pop	cx
   355 00002867 58                  <1> 	pop	ax
   356 00002868 C3                  <1> 	ret
   357                              <1> 
   358                              <1> %ifdef MACHINE_FE2010A
   359                              <1> ;=========================================================================
   360                              <1> ; detect_chipset - detect and print chipset type
   361                              <1> ; Input:
   362                              <1> ;	none
   363                              <1> ; Output:
   364                              <1> ;	none
   365                              <1> ; Note: This subroutine also disables DRAM refresh on both FE2010A and PT8010AF
   366                              <1> ;-------------------------------------------------------------------------
   367                              <1> detect_chipset:
   368                              <1> 	push	ax
   369                              <1> 	push	si
   370                              <1> 	mov	si,msg_chipset
   371                              <1> 	call	print
   372                              <1> 	mov	si,msg_fe2010a
   373                              <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   374                              <1> 	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   375                              <1> 	mov	al,12h			; or for delays (using port_b, bit 4)
   376                              <1>         out     pit_ch1_reg,al		; pulse every 15ms
   377                              <1> 	mov	al,40h			; this disables refresh on FE2010A
   378                              <1> 	out	pit_ctl_reg,al		; but not on PT8010AF
   379                              <1> 	in	al,pit_ch1_reg
   380                              <1> 	cmp	al,12h			; should be 12h on FE2010A
   381                              <1> 	je	.print_chipset
   382                              <1> 	mov	si,msg_pt8010af
   383                              <1> 
   384                              <1> .print_chipset:
   385                              <1> 	call	print
   386                              <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   387                              <1> 	out	pit_ctl_reg,al		; this disables memory refresh
   388                              <1> 	pop	ax
   389                              <1> 	pop	si
   390                              <1> 	ret
   391                              <1> 
   392                              <1> %endif ; MACHINE_FE2010A
   393                              <1> 
   394                              <1> %ifdef TURBO_MODE
   395                              <1> %ifdef BIOS_SETUP
   396                              <1> ;=========================================================================
   397                              <1> ; print_cpu_clk - Print CPU clock frequency
   398                              <1> ; Input:
   399                              <1> ;	AL - NVRAM CPU clock frequency configuration (bits 1:0)
   400                              <1> ;		0 - 4.77 MHz / Normal
   401                              <1> ;		1 - 7.16 MHz / Turbo
   402                              <1> ;		2 - 9.55 MHz (FE2010A)
   403                              <1> ; Output:
   404                              <1> ;	none
   405                              <1> ;-------------------------------------------------------------------------
   406                              <1> print_cpu_clk:
   407                              <1> 	push	ax
   408                              <1> 	push	si
   409                              <1> 	and	al,nvram_trbo_mask	; get turbo bits
   410                              <1> %ifdef MACHINE_FE2010A
   411                              <1> 	mov	si,msg_clk_7_16mhz
   412                              <1> 	cmp	al,1
   413                              <1> 	je	.print
   414                              <1> 	mov	si,msg_clk_9_55mhz
   415                              <1> 	cmp	al,2
   416                              <1> 	je	.print
   417                              <1> %endif ; MACHINE_FE2010A
   418                              <1> %ifdef MACHINE_XI8088
   419                              <1> 	mov	si,msg_clk_turbo
   420                              <1> 	cmp	al,1
   421                              <1> 	je	.print
   422                              <1> %endif ; MACHINE_XI8088
   423                              <1> 	mov	si,msg_clk_4_77mhz
   424                              <1> 
   425                              <1> .print:
   426                              <1> 	call    print
   427                              <1> 	pop	si
   428                              <1> 	pop	ax
   429                              <1> 	ret
   430                              <1> %endif ; BIOS_SETUP
   431                              <1> 
   432                              <1> ;=========================================================================
   433                              <1> ; set_cpu_clk - Set CPU clock frequency
   434                              <1> ; Input:
   435                              <1> ;	AL - NVRAM CPU clock frequency configuration
   436                              <1> ;		0 - 4.77 MHz / Normal
   437                              <1> ;		1 - 7.16 MHz / Turbo
   438                              <1> ;		2 - 9.55 MHz (FE2010A)
   439                              <1> ; Output:
   440                              <1> ;	none
   441                              <1> ;-------------------------------------------------------------------------
   442                              <1> set_cpu_clk:
   443                              <1> %ifdef MACHINE_FE2010A
   444                              <1> 	cmp	al, 1 
   445                              <1> 	je	set_cpu_clk_7_16mhz
   446                              <1> 	cmp	al, 2
   447                              <1> 	je	set_cpu_clk_9_55mhz
   448                              <1> 	jmp	set_cpu_clk_4_77mhz   
   449                              <1> %endif ; MACHINE_FE2010A
   450                              <1> %ifdef MACHINE_XI8088
   451                              <1> 	cmp	al,1
   452                              <1> 	je	set_cpu_clk_turbo
   453                              <1> 	jmp	set_cpu_clk_4_77mhz   
   454                              <1> %endif ; MACHINE_XI8088
   455                              <1> 	ret
   456                              <1> 
   457                              <1> ;=========================================================================
   458                              <1> ; set_cpu_clk_4_77mhz - Set CPU clock at 4.77 MHz
   459                              <1> ; set_cpu_clk_7_16mhz - Set CPU clock at 7.16 MHz
   460                              <1> ; set_cpu_clk_9_55mhz - Set CPU clock at 9.55 MHz
   461                              <1> ; set_cpu_clk_turbo - Set CPU clock at turbo frequency (system dependent)
   462                              <1> ; Input:
   463                              <1> ;	none
   464                              <1> ; Output:
   465                              <1> ;	none
   466                              <1> ;-------------------------------------------------------------------------
   467                              <1> %ifdef MACHINE_FE2010A
   468                              <1> set_cpu_clk_4_77mhz:
   469                              <1> 	push ax
   470                              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   471                              <1> 	and	al,equip_fpu		; isolate FPU installed bit
   472                              <1> 	or	al,fe_par_disable	; disable memory parity checking
   473                              <1> 	out	fe_config_reg,al	; clear bits 7-5 - 4.77 MHz CPU clock
   474                              <1> 	pop ax
   475                              <1> 	ret
   476                              <1> 
   477                              <1> set_cpu_clk_7_16mhz:
   478                              <1> 	push ax
   479                              <1> 	call	get_config_a
   480                              <1> 	mov	ah,al
   481                              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   482                              <1> 	and	al,equip_fpu		; isolate FPU installed bit
   483                              <1> 	or	al,fe_par_disable	; disable memory parity checking
   484                              <1> 	or	al,fe_clk_7_norm	; set bit 6 - 7.15 MHz CPU clock
   485                              <1> 	test	ah,nvram_fast_ws	; nvram_fast_ws = 1 - Normal wait states
   486                              <1> 	jnz	.set_config
   487                              <1> 	or	al,fe_clk_7_fast
   488                              <1> 
   489                              <1> .set_config:
   490                              <1> 	out	fe_config_reg,al
   491                              <1> 	pop ax
   492                              <1> 	ret
   493                              <1> 
   494                              <1> set_cpu_clk_9_55mhz:
   495                              <1> 	push ax
   496                              <1> 	call	get_config_a
   497                              <1> 	mov	ah,al
   498                              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   499                              <1> 	and	al,equip_fpu		; isolate FPU installed bit
   500                              <1> 	or	al,fe_par_disable	; disable memory parity checking
   501                              <1> 	or	al,fe_clk_9_norm	; set bit 7 - 9.54 MHz CPU clock
   502                              <1> 	test	ah,nvram_fast_ws
   503                              <1> 	jnz	.set_config		; nvram_fast_ws = 1 - Normal wait states
   504                              <1> 	or	al,fe_clk_9_fast
   505                              <1> 
   506                              <1> .set_config:
   507                              <1> 	out	fe_config_reg,al
   508                              <1> 	pop ax
   509                              <1> 	ret
   510                              <1> %endif ; MACHINE_FE2010A
   511                              <1> %ifdef MACHINE_XI8088
   512                              <1> set_cpu_clk_4_77mhz:
   513                              <1> 	push	ax
   514                              <1> 	in	al,ppi_pb_reg
   515                              <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
   516                              <1> 	out	ppi_pb_reg,al
   517                              <1> 	pop	ax
   518                              <1> 	ret
   519                              <1> 
   520                              <1> set_cpu_clk_turbo:
   521                              <1> 	push	ax
   522                              <1> 	in	al,ppi_pb_reg
   523                              <1> 	or	al,04h			; set bit 2 (turbo enable bit)
   524                              <1> 	out	ppi_pb_reg,al
   525                              <1> 	pop	ax
   526                              <1> 	ret
   527                              <1> %endif ; MACHINE_XI8088
   528                              <1> %endif ; TURBO_MODE
   289                                  
   290                                  %ifdef SECOND_PIC
   291                                  
   292                                  ;=========================================================================
   293                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
   294                                  ;-------------------------------------------------------------------------
   295                                  int_ignore2:
   296 00002869 50                      	push	ax
   297 0000286A B020                    	mov	al,20h
   298 0000286C E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
   299 0000286E E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
   300 00002870 58                      	pop	ax
   301 00002871 CF                      	iret
   302                                  
   303                                  ;=========================================================================
   304                                  ; int_71 - IRQ9 ISR, emulate IRQ2
   305                                  ;-------------------------------------------------------------------------
   306                                  int_71:
   307 00002872 50                      	push	ax
   308 00002873 B020                    	mov	al,20h
   309 00002875 E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
   310 00002877 58                      	pop	ax
   311 00002878 CD0A                    	int	0Ah		; call IRQ2 ISR
   312 0000287A CF                      	iret
   313                                  
   314                                  ;=========================================================================
   315                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
   316                                  ;-------------------------------------------------------------------------
   317                                  int_75:
   318 0000287B 50                      	push	ax
   319 0000287C B020                    	mov	al,20h
   320 0000287E E6A0                    	out	pic2_reg0,al	; signal EOI to the slave PIC
   321 00002880 E620                    	out	pic1_reg0,al	; signal EOI to the master PIC
   322 00002882 58                      	pop	ax
   323 00002883 CD02                    	int	02h		; call NMI ISR
   324 00002885 CF                      	iret
   325                                  
   326                                  %endif ; SECOND_PIC
   327                                  
   328                                  ;=========================================================================
   329                                  ; boot_os -Boot the OS
   330                                  ;-------------------------------------------------------------------------
   331                                  boot_os:
   332                                  
   333                                  ;-------------------------------------------------------------------------
   334                                  ; Check for F1 (setup key), run setup utility if pressed
   335                                  
   336 00002886 B401                    	mov	ah,01h
   337 00002888 CD16                    	int	16h
   338 0000288A 740E                    	jz	.no_key
   339 0000288C B400                    	mov	ah,00h
   340 0000288E CD16                    	int	16h			; read the keystroke
   341 00002890 3D003B                  	cmp	ax,3B00h		; F1?
   342 00002893 7505                    	jne	.no_key
   343 00002895 800E120001              	or	byte [post_flags],post_setup
   344                                  .no_key:
   345                                  
   346 0000289A F606120001              	test	byte [post_flags],post_setup
   347 0000289F 7403                    	jz	.no_setup
   348                                  
   349                                  %ifdef BIOS_SETUP
   350 000028A1 E890E5                  	call	nvram_setup
   351                                  %endif ; BIOS_SETUP
   352                                  
   353                                  .no_setup:
   354                                  
   355                                  %ifdef TURBO_MODE
   356                                  %ifdef BIOS_SETUP
   357                                  	call	get_config_a		; read BIOS configuration byte A
   358                                  	and	al,nvram_trbo_mask
   359                                  	call	set_cpu_clk		; set CPU clock
   360                                  %endif ; BIOS_SETUP
   361                                  %endif ; TURBO_MODE
   362                                  
   363 000028A4 B000                    	mov	al,e_boot		; boot the OS POST code, this also sends 00 to DMA Page Register for DMA0
   364 000028A6 E680                    	out	post_reg,al
   365                                  
   366 000028A8 BE[0B04]                	mov	si,msg_boot
   367 000028AB E80200                  	call	print
   368 000028AE CD19                    	int	19h			; boot the OS
   369                                  
   370                                  ;=========================================================================
   371                                  ; print - print ASCIIZ string to the console
   372                                  ; Input:
   373                                  ;	CS:SI - pointer to string to print
   374                                  ; Output:
   375                                  ;	none
   376                                  ;-------------------------------------------------------------------------
   377                                  print:
   378 000028B0 9C                      	pushf
   379 000028B1 50                      	push	ax
   380 000028B2 53                      	push	bx
   381 000028B3 56                      	push	si
   382 000028B4 1E                      	push	ds
   383 000028B5 0E                      	push	cs
   384 000028B6 1F                      	pop	ds
   385 000028B7 FC                      	cld
   386                                  .1:
   387 000028B8 AC                      	lodsb
   388 000028B9 08C0                    	or	al,al
   389 000028BB 7408                    	jz	.exit
   390 000028BD B40E                    	mov	ah,0Eh
   391 000028BF B30F                    	mov	bl,0Fh
   392 000028C1 CD10                    	int	10h
   393 000028C3 EBF3                    	jmp	.1
   394                                  .exit:
   395 000028C5 1F                      	pop	ds
   396 000028C6 5E                      	pop	si
   397 000028C7 5B                      	pop	bx
   398 000028C8 58                      	pop	ax
   399 000028C9 9D                      	popf
   400 000028CA C3                      	ret
   401                                  
   402                                  ;=========================================================================
   403                                  ; print_hex - print 16-bit number in hexadecimal
   404                                  ; Input:
   405                                  ;	AX - number to print
   406                                  ; Output:
   407                                  ;	none
   408                                  ;-------------------------------------------------------------------------
   409                                  print_hex:
   410 000028CB 86C4                    	xchg	al,ah
   411 000028CD E80600                  	call	print_byte		; print the upper byte
   412 000028D0 86C4                    	xchg	al,ah
   413 000028D2 E80100                  	call	print_byte		; print the lower byte
   414 000028D5 C3                      	ret
   415                                  
   416                                  ;=========================================================================
   417                                  ; print_byte - print a byte in hexadecimal
   418                                  ; Input:
   419                                  ;	AL - byte to print
   420                                  ; Output:
   421                                  ;	none
   422                                  ;-------------------------------------------------------------------------
   423                                  print_byte:
   424 000028D6 D0C0                    	rol	al,1
   425 000028D8 D0C0                    	rol	al,1
   426 000028DA D0C0                    	rol	al,1
   427 000028DC D0C0                    	rol	al,1
   428 000028DE E82D00                  	call	print_digit
   429 000028E1 D0C0                    	rol	al,1
   430 000028E3 D0C0                    	rol	al,1
   431 000028E5 D0C0                    	rol	al,1
   432 000028E7 D0C0                    	rol	al,1
   433 000028E9 E82200                  	call	print_digit
   434 000028EC C3                      	ret
   435                                  
   436                                  ;=========================================================================
   437                                  ; print_dec - print 16-bit number in decimal
   438                                  ; Input:
   439                                  ;	AX - number to print
   440                                  ; Output:
   441                                  ;	none
   442                                  ;-------------------------------------------------------------------------
   443                                  print_dec:
   444 000028ED 50                      	push	ax
   445 000028EE 51                      	push	cx
   446 000028EF 52                      	push	dx
   447 000028F0 B90A00                  	mov	cx,10		; base = 10
   448 000028F3 E80400                  	call	.print_rec
   449 000028F6 5A                      	pop	dx
   450 000028F7 59                      	pop	cx
   451 000028F8 58                      	pop	ax
   452 000028F9 C3                      	ret
   453                                  
   454                                  .print_rec:			; print all digits recursively
   455 000028FA 52                      	push	dx
   456 000028FB 31D2                    	xor	dx,dx		; DX = 0
   457 000028FD F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
   458 000028FF 83F800                  	cmp	ax,0
   459 00002902 7403                    	je	.below10
   460 00002904 E8F3FF                  	call	.print_rec	; print number / 10 recursively
   461                                  .below10:
   462 00002907 89D0                    	mov	ax,dx		; reminder is in DX
   463 00002909 E80200                  	call	print_digit	; print reminder
   464 0000290C 5A                      	pop	dx
   465 0000290D C3                      	ret
   466                                  
   467                                  ;=========================================================================
   468                                  ; print_digit - print hexadecimal digit
   469                                  ; Input:
   470                                  ;	AL - bits 3...0 - digit to print (0...F)
   471                                  ; Output:
   472                                  ;	none
   473                                  ;-------------------------------------------------------------------------
   474                                  print_digit:
   475 0000290E 50                      	push	ax
   476 0000290F 53                      	push	bx
   477 00002910 240F                    	and	al,0Fh
   478 00002912 0430                    	add	al,'0'			; convert to ASCII
   479 00002914 3C39                    	cmp	al,'9'			; less or equal 9?
   480 00002916 7602                    	jna	.1
   481 00002918 0407                    	add	al,'A'-'9'-1		; a hex digit
   482                                  .1:
   483 0000291A B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
   484 0000291C B307                    	mov	bl,07h			; just in case we're in graphic mode
   485 0000291E CD10                    	int	10h
   486 00002920 5B                      	pop	bx
   487 00002921 58                      	pop	ax
   488 00002922 C3                      	ret
   489                                  
   490                                  %ifdef EBDA_SIZE
   491                                  ;=========================================================================
   492                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
   493                                  ; Input:
   494                                  ;	AX = memory size in KiB
   495                                  ; Notes:
   496                                  ;	- Assumes that EBDA memory was cleaned
   497                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
   498                                  ;-------------------------------------------------------------------------
   499                                  reserve_ebda:
   500 00002923 50                      	push	ax
   501 00002924 51                      	push	cx
   502 00002925 F70610000400            	test	word [equipment_list],equip_mouse
   503 0000292B 742B                    	jz	.no_mouse
   504 0000292D A11300                  	mov	ax,word [memory_size]	; get conventional memory size
   505 00002930 83E801                  	sub	ax,EBDA_SIZE		; substract EBDA size
   506 00002933 A31300                  	mov	word [memory_size],ax	; store new conventional memory size
   507 00002936 B106                    	mov	cl,6
   508 00002938 D3E0                    	shl	ax,cl			; convert to segment
   509 0000293A A30E00                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
   510 0000293D 1E                      	push	ds
   511 0000293E 8ED8                    	mov	ds,ax
   512 00002940 B80100                  	mov	ax,EBDA_SIZE
   513 00002943 A20000                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
   514 00002946 1F                      	pop	ds
   515 00002947 56                      	push	si
   516 00002948 BE[5C03]                	mov	si,msg_ebda
   517 0000294B E862FF                  	call	print
   518 0000294E E89CFF                  	call	print_dec
   519 00002951 BE[9603]                	mov	si,msg_kib
   520 00002954 E859FF                  	call	print
   521 00002957 5E                      	pop	si
   522                                  .no_mouse:
   523 00002958 59                      	pop	cx
   524 00002959 58                      	pop	ax
   525 0000295A C3                      	ret
   526                                  %endif ; EBDA_SIZE
   527                                  
   528                                  ;=========================================================================
   529                                  ; print display type
   530                                  ;-------------------------------------------------------------------------
   531                                  print_display:
   532 0000295B BE[8D01]                	mov	si,msg_disp
   533 0000295E E84FFF                  	call	print
   534 00002961 BE[AA01]                	mov	si,msg_disp_ega		; assume EGA or later
   535 00002964 833EA80000              	cmp	word [vga_table_ptr],0	; check if BIOS Video Save/Override
   536                                  					; Pointer Table address is initialized
   537 00002969 751D                    	jnz	.print_disp
   538 0000296B 833EAA0000              	cmp	word [vga_table_ptr+2],0
   539 00002970 7516                    	jnz	.print_disp
   540                                  					; Not an EGA/VGA - check equipment word
   541 00002972 A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
   542 00002975 2430                    	and	al,equip_video		; get video adapter type
   543 00002977 BE[E501]                	mov	si,msg_disp_mda
   544 0000297A 3C30                    	cmp	al,equip_mono		; monochrome?
   545 0000297C 740A                    	jz	.print_disp
   546 0000297E BE[C901]                	mov	si,msg_disp_cga_80
   547 00002981 3C20                    	cmp	al,equip_color_80	; CGA 80x25?
   548 00002983 7403                    	jz	.print_disp
   549 00002985 BE[D701]                	mov	si,msg_disp_cga_40	; Must be CGA 40x25
   550                                  .print_disp:
   551 00002988 E825FF                  	call	print
   552 0000298B C3                      	ret
   553                                  
   554                                  %ifdef PS2_MOUSE
   555                                  
   556                                  ;=========================================================================
   557                                  ; print PS/2 mouse presence
   558                                  ;-------------------------------------------------------------------------
   559                                  
   560                                  print_mouse:
   561 0000298C BE[8B02]                	mov	si,msg_mouse
   562 0000298F E81EFF                  	call	print
   563 00002992 BE[B202]                	mov	si,msg_absent
   564 00002995 F606100004              	test	byte [equipment_list],equip_mouse
   565 0000299A 7403                    	jz	.print_mouse
   566 0000299C BE[A802]                	mov	si,msg_present
   567                                  .print_mouse:
   568 0000299F E80EFF                  	call	print
   569 000029A2 C3                      	ret
   570                                  
   571                                  %endif ; PS2_MOUSE
   572                                  
   573                                  ;=========================================================================	
   574                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
   575                                  ;-------------------------------------------------------------------------
   576                                  interrupt_table:
   577 000029A3 [536F]                  	dw	int_dummy		; INT 00 - Divide by zero
   578 000029A5 [536F]                  	dw	int_dummy		; INT 01 - Single step
   579 000029A7 [C352]                  	dw	int_02			; INT 02 - Non-maskable interrupt
   580 000029A9 [536F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
   581 000029AB [536F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
   582 000029AD [546F]                  	dw	int_05			; INT 05 - BIOS Print Screen
   583 000029AF [536F]                  	dw	int_dummy		; INT 06
   584 000029B1 [536F]                  	dw	int_dummy		; INT 07
   585 000029B3 [9D6E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
   586 000029B5 [8759]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
   587 000029B7 [236F]                  	dw	int_ignore		; INT 0A - IRQ2
   588 000029B9 [236F]                  	dw	int_ignore		; INT 0B - IRQ3
   589 000029BB [236F]                  	dw	int_ignore		; INT 0C - IRQ4
   590 000029BD [236F]                  	dw	int_ignore		; INT 0D - IRQ5
   591 000029BF [575F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
   592 000029C1 [236F]                  	dw	int_ignore		; INT 0F - IRQ7
   593 000029C3 [6560]                  	dw	int_10			; INT 10 - BIOS Video Services
   594 000029C5 [0068]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
   595 000029C7 [F467]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
   596 000029C9 [595C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
   597 000029CB [2957]                  	dw	int_14			; INT 14 - BIOS Serial Communications
   598 000029CD [0C68]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
   599 000029CF [2E58]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
   600 000029D1 [D45F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
   601 000029D3 [5053]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
   602 000029D5 [F256]                  	dw	int_19			; INT 19 - BIOS Boot the OS
   603 000029D7 [6E6E]                  	dw	int_1A			; INT 1A - BIOS Time Services
   604 000029D9 [536F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
   605 000029DB [536F]                  	dw	int_dummy		; INT 1C - User Timer Tick
   606 000029DD [A460]                  	dw	int_1D			; INT 1D - Video Parameters Table
   607 000029DF [C75F]                  	dw	int_1E			; INT 1E - Floppy Parameters Table
   608                                  %ifndef MACHINE_XT
   609 000029E1 [1E08]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
   610                                  %else ; MACHINE_XT
   611                                  	dw	int_ignore
   612                                  %endif ; MACHINE_XT
   613                                  
   614                                  %ifdef SECOND_PIC
   615                                  interrupt_table2:
   616                                  %ifdef AT_RTC
   617 000029E3 [9613]                  	dw	int_70			; INT 70 - IRQ8 - RTC
   618                                  %endif
   619 000029E5 [7228]                  	dw	int_71			; INT 71 - IRQ9 - redirection
   620 000029E7 [6928]                  	dw	int_ignore2		; INT 72 - IRQ10
   621 000029E9 [6928]                  	dw	int_ignore2		; INT 73 - IRQ11
   622                                  %ifndef PS2_MOUSE
   623                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
   624                                  %else ; PS2_MOUSE
   625 000029EB [7826]                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
   626                                  %endif ; PS2_MOUSE
   627 000029ED [7B28]                  	dw	int_75			; INT 75 - IRQ13 - FPU
   628 000029EF [6928]                  	dw	int_ignore2		; INT 76 - IRQ14
   629 000029F1 [6928]                  	dw	int_ignore2		; INT 77 - IRQ15
   630                                  %endif ; SECOND_PIC
   631                                  
   632                                  ;=========================================================================
   633                                  ; init_v40 - Initialize NEC V40 built-in peripheral registers
   634                                  ;-------------------------------------------------------------------------	
   635                                  %ifdef MACHINE_HOMEBREW8088
   636                                  init_v40:
   637                                  	mov	dx,0FFFEh		; 0FFFEh: OPCN - INT Select
   638                                  	xor	al,al
   639                                  	out	dx,al
   640                                  
   641                                  	dec	dx			; 0FFFDh: OPSEL - Enable Peripheral
   642                                  	mov	al,06h			; Only enable the interrupt controller and timer
   643                                  	out	dx,al
   644                                  
   645                                  	dec	dx			; 0FFFCh: OPHA - On chip peripheral high address register 
   646                                  	mov	al,00h			; Any 256K block except overlap with resgisters 
   647                                  	out	dx,al
   648                                  
   649                                  	dec	dx			; 0FFFBh: DULA - DMA lower address register
   650                                  	xor	al,al			; Not initialized as not used
   651                                  	out	dx,al			; to save space
   652                                  
   653                                  	dec	dx			; 0FFFAh: IULA  - 8259 lower address register
   654                                  	mov	al,20h									
   655                                  	out	dx,al
   656                                  
   657                                  	dec	dx			; 0FFF9h: TULA - 8254 lower address register
   658                                  	mov	al,40h
   659                                  	out	dx,al
   660                                  
   661                                  	dec	dx			; 0FFF8h: SULA - Serial port lower address register
   662                                  	mov	al,0D0h			; Not initialized since not used
   663                                  	out	dx,al
   664                                  
   665                                  	dec	dx			; 0FFF7h: RES
   666                                  
   667                                  	dec	dx			; 0FFF6h: WCY2 - WAIT 
   668                                  	mov	al,01h			; Sets the number of wait cycles for DMA and refresh cycles
   669                                  	out	dx,al
   670                                  
   671                                  	dec	dx			; 0FFF5h: WCY1 - WAIT
   672                                  	mov	al,0FFh			; Bits 7-6: I/O, 5-4: upper mem, 3-2: middle mem, 1-0: lower mem
   673                                  					; 00 = no wait, 11 = longest wait
   674                                  	out	dx,al
   675                                  
   676                                  	dec	dx			; 0FFF4h: WMB - Memory boundaries
   677                                  	mov	al,06h			; Bits 6-4: lowest memory, BITS 2-0 highest memory, middle is everything else 0 
   678                                  	out	dx,al
   679                                  
   680                                  	dec	dx 			; 0FFF3h: RES
   681                                  
   682                                  	dec	dx			; 0FFF2h: RFC - Refresh control
   683                                  	xor	al,al			; NO 82
   684                                  	out	dx,al
   685                                  
   686                                  	dec	dx			; 0FFF1h: RES
   687                                  
   688                                  	dec	dx			; 0FFF0h: TCKS - Timer pin selection 
   689                                  	mov	al,14h			; 1 = pin, 0 = internal, bits 1-0: prescale div for internal
   690                                  	out	dx,al
   691                                  
   692                                  	; We formerly set up the interrupt controller and timer here, but the
   693                                  	; mainline BIOS does this itself.  Removing this and the beep as soon as power on occurs
   694                                  	; frees critical ROM space if we want to do something else clever here but keep IBM BIOS alignment.
   695                                  	; Silence the static on the beeper ASAP (with 8088 card)
   696                                  	xor	al,al
   697                                  	out	ppi_pb_reg,al
   698                                  
   699                                  	jmp	post_init_v40
   700                                  %endif
   701                                  
   702                                  %ifdef MACHINE_BBPC8088
   703 000029F3 FF<rep 60Dh>            	setloc	0C000h		; POST Entry Point modified from B000 for reduced size to allow XTIDE Tiny BIOS to be added at F8000-F8FFF BIOS now Starts at F9000
   703          ******************       warning: Inserting 1549 bytes [-w+user]
   704                                      %include	"8086Monitorv5.inc"		; Embed Nanocomp 8088 Monitor at 0xC000, Power on reset goes to NC Reset, then B for BIOS
     1                              <1> ;===========================================================================
     2                              <1> ; 8086monitor.asm - Nanocomp 8086 Monitor migrated from Motorola MC6809 code
     3                              <1> ; Note this is a literal translation of the 6802/6809 code and is not efficient or best practice
     4                              <1> ; The Nanocomp 6809 monitor was a quick translation of the 6802 version in the first place!
     5                              <1> ; nasm -f bin -o 8086monitor.bin -l 8086monitor.lst 8086monitorv4.asm
     6                              <1> ; 
     7                              <1> ; Version          Date            Description
     8                              <1> ;  1.0             6/1/24          Initial migration from 6809 to 8088, minus Save & Load SREC
     9                              <1> ;  2.0             8/1/24          Add Save and Load SREC for serial port, remove test RAM bytes, 57.6Kbps /64 Enabled
    10                              <1> ;  3.0             19/1/24         Convert to use IO Ports and add setting Extra Segment for Mem access and Code Segment for Go
    11                              <1> ;                                  Bug fixes for Go and added stack pointer to Register Display
    12                              <1> ;  4.0             10/4/24         Mask PIC interupt flags on power up. Add dummy interrupt function including EOI notification to PICs
    13                              <1> ;                                  Populate interupt vectors with dummy interupt function, leave video and floppy parameters int_1D & int_1E
    14                              <1> ;                                  Add far function wrappers for 7 segment display and key pad functions to allow calling from another code segment
    15                              <1> ;  5.0             07/05/24        Merged Monitor into BPC Bios as V5 at F000:B000. Use B to boot BIOS calls cold_start
    16                              <1> ;
    17                              <1> ; Conversion of 6809 Nanocomp monitor to 8086 Breadboard PC
    18                              <1> ;=========================================================================
    19                              <1> ; Note that due to there being no Monitor commands (yet) to set Segments then SS=7000, DS=7000 and ES=D000 (PIA etc). GO will use [7000:xxxx]
    20                              <1> ; Now E and C can be used to set the Extra and Code segments used by Memdisp, Save, Load and Go
    21                              <1> ; INT 3 is equivelevent of SWI used to do Register Display. 8088 Pushes Flags on Stack with CS and IP
    22                              <1> ; Need PUSHA to have most state (no DS, SS or ES),  AX, CX, DX, BX, SP, BP, SI, DI. SP+6 will be value before INT
    23                              <1> ; INT decrements the stack pointer by two, pushes the flags onto the stack, and clears the trap (TF) and interrupt-enable (IF) flags to
    24                              <1> ; disable single-step and maskable interrupts. The flags are stored in the format used by the PUSHF instruction. SP is decremented again
    25                              <1> ; by two, and the CS register is pushed onto the stack. The address of the interrupt pointer is calculated by multiplying interrupt-type by
    26                              <1> ; four, the second word of the interrupt pointer replaces CS. SP again is decremented by two and IP is pushed onto the stack and is 
    27                              <1> ; replaced by the first word of the interrupt pointer.
    28                              <1> 
    29                              <1>                       ; Flags Register
    30                              <1>                       ; CC  15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
    31                              <1>                       ;     -  -  -  -  OF DF IF TF SF ZF -  AF -  PF -  CF
    32                              <1>                       ;
    33                              <1>                       ; 0 CF Carry Flag
    34                              <1>                       ; 1 -
    35                              <1>                       ; 2 PF Parity Flag
    36                              <1>                       ; 3 -
    37                              <1>                       ; 4 AF Aux. Carry Flag
    38                              <1>                       ; 5 -
    39                              <1>                       ; 6 ZF Zero Flag
    40                              <1>                       ; 7 SF Sign Flag
    41                              <1>                       ; 8 TF Trap Flag
    42                              <1>                       ; 9 IF Interrupt Flag
    43                              <1>                       ;10 DF Direction Flag
    44                              <1>                       ;11 OF Overflow Flag
    45                              <1>                       ;12-15 - 
    46                              <1>                       
    47                              <1> ;-           After power up, display - wait for command
    48                              <1> ;RST Reset   Is hard reset bringing /RST line low via power supervisor debounce circuit
    49                              <1> ;AB  Abort   Is Non Maskable Interupt (NMI), vector at [0000:0008] IP:CS
    50                              <1> ;G  Go       Displays G to acknowledge command, enter 4 digit hex address and will run on 4th digit
    51                              <1> ;CN Continue After SWI or Abort (NMI) press CN to continue, values on the stack will be pulled including instruction pointer
    52                              <1> ;M  Memory   Display M in far right display (upside down U),
    53                              <1> ;            4 digit Hex entered in left 4 digits, 
    54                              <1> ;            displays memory contents in right two digits
    55                              <1> ;            change by typing in new digits enter in from right shift to left
    56                              <1> ;            Press I to save and move to next 
    57                              <1> ;            No changes press I to advance or AB to abort
    58                              <1> ;            Invalid address or hex bytes will return to monitor - prompt
    59                              <1> ;S  Save     SAVE range to serial port in V2+ in S19/SREC format 7DCB 
    60                              <1> ;            Display S to prompt for Start address
    61                              <1> ;            Display F to prompt for for finish address
    62                              <1> ;            Displays F when finished
    63                              <1> ;L  Load     LOAD from serial port in V2+ 7DC4
    64                              <1> ;            When finished Display F Finished or E for Hex error or C for Checksum error
    65                              <1> ;AB Abort    Return to monitor start via NMI if not changed NMI vector
    66                              <1> ;R  Register Display register values via the pushed values on the stack (automatic after INT3 vector at [0000:000C] IP:CS)
    67                              <1> ;            Right digits show 
    68                              <1> ;            	FL Flags register
    69                              <1> ;            	CS Code Segment
    70                              <1> ;            	IP Instruction Pointer
    71                              <1> ;             AX AX register CX, DX, BX, SP, BP, SI, DI
    72                              <1> ;            	CX CX Register
    73                              <1> ;             DX DX Register
    74                              <1> ;             BX BX Register
    75                              <1> ;             SP SP Register
    76                              <1> ;             BP BP Register
    77                              <1> ;             SI SI Register
    78                              <1> ;             DI DI Register
    79                              <1> ;            Press I between values
    80                              <1> ;            After DI displayed returns to Monitor, AB to Abort to monitor
    81                              <1> ;E Extra Segment Enter 4 chracter Hex address to set the ES register for use with Mem, Save and Load
    82                              <1> ;C Code Segment Enter 4 chracter Hex address to set the CS register for use with Go
    83                              <1> ;cpu	8086
    84                              <1> 
    85                              <1> ; This macro includes the setloc macro to pad code with FF to a given address
    86                              <1> ;%include "macro.inc"
    87                              <1> 
    88                              <1> ; Define 7 Segment display character codes
    89                              <1> seg0                          EQU 0x7E
    90                              <1> seg1                          EQU 0x06
    91                              <1> seg2                          EQU 0x5B
    92                              <1> seg3                          EQU 0x1F
    93                              <1> seg4                          EQU 0x27
    94                              <1> seg5                          EQU 0x3D
    95                              <1> seg6                          EQU 0x7D
    96                              <1> seg7                          EQU 0x0E
    97                              <1> seg8                          EQU 0x7F
    98                              <1> seg9                          EQU 0x3F
    99                              <1> segA                          EQU 0x6F
   100                              <1> segB                          EQU 0x75
   101                              <1> segC                          EQU 0x78
   102                              <1> segD                          EQU 0x57
   103                              <1> segE                          EQU 0x79
   104                              <1> segF                          EQU 0x69
   105                              <1> segG                          EQU 0x7C
   106                              <1> segH                          EQU 0x67
   107                              <1> segI                          EQU 0x60
   108                              <1> segL                          EQU 0x70
   109                              <1> segM                          EQU 0x6E ; (upside down U)
   110                              <1> segN                          EQU 0x6E ; (upside down U)
   111                              <1> segO                          EQU 0x7E
   112                              <1> segP                          EQU 0x6B
   113                              <1> segS                          EQU 0x3D ; (Same as 5)
   114                              <1> segU                          EQU 0x76
   115                              <1> segX                          EQU 0x67
   116                              <1> segY                          EQU 0x37
   117                              <1> segDash                       EQU 0x01
   118                              <1> segSpace                      EQU 0x00
   119                              <1> 
   120                              <1> ; Define Nanocomp Keypad key codes
   121                              <1> keyCN                         EQU 0x25
   122                              <1> keyG                          EQU 0x35
   123                              <1> keyI                          EQU 0x32
   124                              <1> keyL                          EQU 0x05
   125                              <1> keyM                          EQU 0x31
   126                              <1> keyP                          EQU 0x15 ; P Punch replaced with S Save
   127                              <1> keyS                          EQU 0x15
   128                              <1> keyR                          EQU 0x30
   129                              <1> key0                          EQU 0x22
   130                              <1> key1                          EQU 0x24
   131                              <1> key2                          EQU 0x02
   132                              <1> key3                          EQU 0x12
   133                              <1> key4                          EQU 0x14
   134                              <1> key5                          EQU 0x00
   135                              <1> key6                          EQU 0x10
   136                              <1> key7                          EQU 0x04
   137                              <1> key8                          EQU 0x01
   138                              <1> key9                          EQU 0x11
   139                              <1> keyA                          EQU 0x03
   140                              <1> keyB                          EQU 0x13
   141                              <1> keyC                          EQU 0x23
   142                              <1> keyD                          EQU 0x33
   143                              <1> keyE                          EQU 0x21
   144                              <1> keyF                          EQU 0x20
   145                              <1> 
   146                              <1> asciiNull                     EQU 0x00
   147                              <1> asciiBS                       EQU 0x08
   148                              <1> asciiLF                       EQU 0x0A
   149                              <1> asciiFF                       EQU 0x0C
   150                              <1> asciiCR                       EQU 0x0D
   151                              <1> 
   152                              <1> ascii0                        EQU 0x30
   153                              <1> ascii1                        EQU 0x31
   154                              <1> ascii3                        EQU 0x33
   155                              <1> ascii9                        EQU 0x39
   156                              <1> asciiA                        EQU 0x41
   157                              <1> asciiC                        EQU 0x43
   158                              <1> asciiF                        EQU 0x46
   159                              <1> asciiS                        EQU 0x53
   160                              <1> 
   161                              <1> ; Serial Port Constants
   162                              <1> SERIALCTRL                    EQU  0xE000           ; Use IO Port E000
   163                              <1> SERIALSTATUS                  EQU  0xE000           ; Use IO Port E000
   164                              <1> SERIALDATA                    EQU  0xE001           ; Use IO Port E001
   165                              <1> 
   166                              <1> CTRLRESET                     EQU  0b00000011       ; CR1, CR0 1,1 for Master Reset
   167                              <1> CTRLDIVIDE16                  EQU  0b00000001       ; CR1, CR0 0,1 for divide by 16
   168                              <1> CTRLDIVIDE64                  EQU  0b00000010       ; CR1, CR0 1,0 for divide by 64
   169                              <1> CTRLWORD8N1S                  EQU  0b00010100       ; CR4, CR3, CR2 1, 0, 1 for 8 Bits, 1 Stop No Parity
   170                              <1> CTRLRTSLOW                    EQU  0b00000000       ; CR6, CR5, 0,0 RTS low IRQ disabled, requests data
   171                              <1> CTRLRTSHIGH                   EQU  0b01000000       ; CR6, CR5, 1,0 RTS high IRQ disabled, prevents receiving data
   172                              <1> CTRLIRQENABLED                EQU  0b10000000       ; CR7, 1 IRQ enabled
   173                              <1> 
   174                              <1> STATUSRDRF                    EQU  0b00000001       ; Receive Data Register Full Bit 0
   175                              <1> STATUSTDRE                    EQU  0b00000010       ; Transmit Data Register Empty Bit 1
   176                              <1> STATUSDCD                     EQU  0b00000100       ; Data Carrier Detect Bit 2
   177                              <1> STATUSCTS                     EQU  0b00001000       ; Clear To Send Bit 3
   178                              <1> STATUSFE                      EQU  0b00010000       ; Framing Error Bit 4
   179                              <1> STATUSOVRN                    EQU  0b00100000       ; Receiver Overrun Bit 5
   180                              <1> STATUSPE                      EQU  0b01000000       ; Parity Error Bit 6
   181                              <1> STATUSIRQREQ                  EQU  0b10000000       ; Interupt Request /IRQ Bit 7
   182                              <1> 
   183                              <1> EOS                           EQU  0x00             ; end of string
   184                              <1> 
   185                              <1> ; Now Monitor is part of BIOS then disable
   186                              <1> ;%define	START		0x8000		; BIOS/ROM starts at offset 8000h Physical Address is F8000 [F000:8000]
   187                              <1> %define	STACKSTART 0xFFEC ; Saved User Stack Pointer (and possibly Stack Segment) after INT 3
   188                              <1> %define	GO_CS 0xFFEA ; Code Segment for Go
   189                              <1> %define	GO_IP 0xFFE8 ; Instruction Pointer for Go
   190                              <1> %define SAVE_START 0xFFE6 ; Save Start Addres 
   191                              <1> %define SAVE_FINISH 0xFFE4 ; Save Finish Address
   192                              <1> %define EXTRA_SEGMENT 0xFFE2 ; E command data segment used by Memdisp, Save, Load
   193                              <1> 
   194                              <1> 
   195                              <1> %define MONSTACK 0xFEFE   ; Monitor default stack starting point, on less FEFF is where it starts
   196                              <1> %define USERSTACK 0xFDFE   ; User program default stack starting point, on less FEFF is where it starts
   197                              <1> 
   198                              <1> %define	DBUF		0xFFF0		; Display Buffer DBUF starts at offset FFF0 Physical Address is 7FFF0 [7000:FFF0] at top of 512K RAM
   199                              <1> ; Note es set to D000 for PIA
   200                              <1> 
   201                              <1> %define DATASEG 0x7000    ; Data Segment Same as stack until we add setting Segments to Monitor
   202                              <1> %define USERCODESEG 0x7000    ; Data Segment Same as stack until we add setting Segments to Monitor
   203                              <1> %define STACKSEG 0x7000   ; Stack Segment is current top of 512K RAM minus 256 bytes for Monitor use
   204                              <1> %define	PIASEG  0xD000		; PIA Segment A D0000    [D000:0000]
   205                              <1> %define MONCODESEG 0xF000 ; Monitor Code Segment
   206                              <1> 
   207                              <1> %define DIVIDE0VECTOR 0x0000 ; IP and CS for divide by 0
   208                              <1> %define SINGLESTEPVECTOR 0x0004 ; IP and CS for Single Step
   209                              <1> %define NMIVECTOR 0x0008  ; IP and CS for Non Maskable Interrupt
   210                              <1> %define INT3VECTOR 0x000c ; IP and CS for INT 3 Software Interrupt
   211                              <1> %define OVERFLOWVECTOR 0x0010 ; IP and CS for Overflow
   212                              <1> 
   213                              <1> %define	PORTA		0xD000		; PIA Port A IO Port D000
   214                              <1> %define	CTRLA		0xD001		; PIA Control A IO Port D001
   215                              <1> %define	PORTB		0xD002		; PIA Port B IO Port D002
   216                              <1> %define	CTRLB		0xD003		; PIA Control B IO Port D003
   217                              <1> 
   218                              <1> 
   219                              <1> pic1_reg0	equ	0x20        ; PC 8259 Interrupt controllers for EOI in irq_ignore
   220                              <1> pic1_reg1	equ	21h
   221                              <1> pic2_reg0	equ	0xA0        ; PC 8259 Interrupt controllers for EOI in irq_ignore
   222                              <1> pic2_reg1	equ	0A1h
   223                              <1> 
   224                              <1> pit_ch0_reg	equ	40h       ; PC 8252/8253 Programmable Interval Timer ports
   225                              <1> pit_ch1_reg	equ	41h
   226                              <1> pit_ch2_reg	equ	42h
   227                              <1> pit_ctl_reg	equ	43h
   228                              <1>     
   229                              <1> 
   230                              <1> ;org	START		; Use only upper 32 KiB of ROM, now at 0xB000 rather than 0x8000
   231                              <1> 
   232                              <1> ;   Reset Handler
   233                              <1> reset:
   234                              <1>                      ;RESET               lds      #MONSTACK          ; Load System Stack Pointer with Monitor default  
   235                              <1>                      ;                    jsr      DISPRESET          ; Reset VGA Display CRTC etc
   236                              <1>     ; Clear Interrupts until vectors defined
   237 00003000 FA                  <1>     cli
   238 00003001 31C0                <1>     xor ax,ax
   239 00003003 8ED8                <1>     mov ds,ax  ; Interupt Vectors start at [0000:0000] and are 4 bytes each IP then CS
   240                              <1> 
   241                              <1>     ; Define Divide by 0 error vector (Display Registers now Ignore)
   242 00003005 3EC7060000[8436]    <1>     mov [ds:DIVIDE0VECTOR], word sw_int_ignore
   243 0000300C 3EC706020000F0      <1>     mov [ds:DIVIDE0VECTOR+2],word  MONCODESEG
   244                              <1>     ; Define Single Step vector (Display Registers  now Ignore)
   245 00003013 3EC7060400[8436]    <1>     mov [ds:SINGLESTEPVECTOR], word sw_int_ignore
   246 0000301A 3EC706060000F0      <1>     mov [ds:SINGLESTEPVECTOR+2], word MONCODESEG
   247                              <1>     ; Define NMI Vector and Code Segment
   248                              <1> ;   Set up NMI to point here
   249                              <1>                      
   250                              <1> ;    mov [ds:NMIVECTOR], word regdispswi        ;                     ldx      #NMISR            ; Save NMI Service Routine address in NMI Vector  
   251 00003021 3EC7060800[5D31]    <1>     mov [ds:NMIVECTOR], word nmisr        ;                     ldx      #NMISR            ; Save NMI Service Routine address in NMI Vector  
   252 00003028 3EC7060A0000F0      <1>     mov [ds:NMIVECTOR+2], word MONCODESEG ;                     stx      NMIVEC
   253                              <1>     ; Define Software Interrupt INT 3 Vector and Code Segment
   254 0000302F 3EC7060C00[2434]    <1>     mov [ds:INT3VECTOR], word regdispswi
   255 00003036 3EC7060E0000F0      <1>     mov [ds:INT3VECTOR+2], word MONCODESEG
   256                              <1>     ; Define Overflow Error Vector and Code Segment (Display Registers  now Ignore)
   257 0000303D 3EC7061000[8436]    <1>     mov [ds:OVERFLOWVECTOR], word sw_int_ignore
   258 00003044 3EC706120000F0      <1>     mov [ds:OVERFLOWVECTOR+2], word MONCODESEG
   259                              <1> 
   260                              <1>     ; Use hw_int_ignore for Hardware IRQ 0-7 mapped to IRQ 8-15 starting at 0x20-0x3F and IRQ 8-15 to IRQ 70-77 0x1C0-0x1DF rest can be sw_int_ignore
   261                              <1>     ; iterate over 0x014 to 0x3ff with sw_int_ignore then populate 0x20-0x3F and IRQ 8-15 to IRQ 70-77 0x1C0-0x1DF rest can be sw_int_ignore
   262                              <1>     ; Ignore 1D and 1E for Video and Floppy Parameters 0x74 - 0x7b, 0x7c onwards
   263                              <1> ;    mov cx, 0x00FA
   264 0000304B B91800              <1>     mov cx, 0x0018
   265 0000304E BF1400              <1>     mov di, 0x0014
   266                              <1> vectorLoop:
   267 00003051 3EC705[8436]        <1>     mov [ds:di], word sw_int_ignore
   268 00003056 83C702              <1>     add di, 2
   269 00003059 3EC70500F0          <1>     mov [ds:di], word MONCODESEG
   270 0000305E 83C702              <1>     add di, 2
   271 00003061 E2EE                <1>     loop vectorLoop
   272                              <1> 
   273 00003063 B9E000              <1>     mov cx, 0x00E0
   274 00003066 BF7C00              <1>     mov di, 0x007c
   275                              <1> vectorLoop1:
   276 00003069 3EC705[8436]        <1>     mov [ds:di], word sw_int_ignore
   277 0000306E 83C702              <1>     add di, 2
   278 00003071 3EC70500F0          <1>     mov [ds:di], word MONCODESEG
   279 00003076 83C702              <1>     add di, 2
   280 00003079 E2EE                <1>     loop vectorLoop1
   281                              <1> 
   282                              <1>     ; Now do IRQ0-IRQ7
   283 0000307B B90800              <1>     mov cx, 0x0008
   284 0000307E BF2000              <1>     mov di, 0x0020
   285                              <1> vectorLoop2:
   286 00003081 3EC705[7B36]        <1>     mov [ds:di], word hw_int_ignore
   287 00003086 83C702              <1>     add di, 2
   288 00003089 3EC70500F0          <1>     mov [ds:di], word MONCODESEG
   289 0000308E 83C702              <1>     add di, 2
   290 00003091 E2EE                <1>     loop vectorLoop2
   291                              <1> 
   292                              <1>     ; Now do IRQ8-IRQ15
   293 00003093 B90800              <1>     mov cx, 0x0008
   294 00003096 BFC001              <1>     mov di, 0x01c0
   295                              <1> vectorLoop3:
   296 00003099 3EC705[7B36]        <1>     mov [ds:di], word hw_int_ignore
   297 0000309E 83C702              <1>     add di, 2
   298 000030A1 3EC70500F0          <1>     mov [ds:di], word MONCODESEG
   299 000030A6 83C702              <1>     add di, 2
   300 000030A9 E2EE                <1>     loop vectorLoop3
   301                              <1> 
   302                              <1>     ; Initialise PIC0 and PIC1 as per BIOS except for Mask all IRQ
   303 000030AB B011                <1>     mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
   304 000030AD E620                <1>     out	pic1_reg0,al
   305 000030AF E6A0                <1>     out	pic2_reg0,al
   306 000030B1 B008                <1>     mov	al,8			; ICW2 - interrupt vector offset = 8
   307 000030B3 E621                <1>     out	pic1_reg1,al
   308 000030B5 B070                <1>     mov	al,70h			; ICW2 - interrupt vector offset = 70h
   309 000030B7 E6A1                <1>     out	pic2_reg1,al
   310 000030B9 B004                <1>     mov	al,4			; ICW3 - slave is connected to IR2
   311 000030BB E621                <1>     out	pic1_reg1,al
   312 000030BD B002                <1>     mov	al,2			; ICW3 - slave ID = 2 (IR2)
   313 000030BF E6A1                <1>     out	pic2_reg1,al
   314 000030C1 B001                <1>     mov	al,1			; ICW4 - 8086/8088
   315 000030C3 E621                <1>     out	pic1_reg1,al
   316 000030C5 E6A1                <1>     out	pic2_reg1,al
   317                              <1> 
   318 000030C7 B0FF                <1>     mov	al,0xff		; OCW1 - Mask all interrupts
   319 000030C9 E621                <1>     out	pic1_reg1,al
   320 000030CB E6A1                <1>     out	pic2_reg1,al
   321                              <1> 
   322                              <1>     ; Initialize PIT (8254 timer) and disable timers 0,1,2 mode 0
   323 000030CD B030                <1>     mov	al,30h			; channel 0, LSB & MSB, mode 0, binary
   324 000030CF E643                <1>     out	pit_ctl_reg,al
   325 000030D1 B000                <1>     mov	al,0
   326 000030D3 E640                <1>     out	pit_ch0_reg,al
   327 000030D5 E640                <1>     out	pit_ch0_reg,al
   328 000030D7 B070                <1>     mov	al,70h			; channel 1, LSB & MSB, mode 0, binary
   329 000030D9 E643                <1>     out	pit_ctl_reg,al
   330 000030DB B000                <1>     mov	al,0h			; 
   331 000030DD E641                <1>     out	pit_ch1_reg,al
   332 000030DF E641                <1>     out	pit_ch1_reg,al
   333                              <1> 
   334 000030E1 B0B0                <1>     mov	al,0xb0			; channel 3, LSB & MSB, mode 0, binary
   335 000030E3 E643                <1>     out	pit_ctl_reg,al
   336 000030E5 B000                <1>     mov	al,0h			; 
   337 000030E7 E642                <1>     out	pit_ch2_reg,al
   338 000030E9 E642                <1>     out	pit_ch2_reg,al
   339                              <1> 
   340                              <1>     ; DMA should be disabled from RESET - check this
   341                              <1>     
   342                              <1>     
   343                              <1>     ; Don't want to set stack with segments incase we need to refresh segments later
   344 000030EB BCFEFE              <1>     mov sp, MONSTACK ; Stack starts at 0x7FEFE downwards [7000:FEFE] leaving 256 bytes for Monitor working memory from (7)FF00-(7)FFFF
   345 000030EE 3EC706ECFFFEFD      <1>     mov [ds:STACKSTART], word USERSTACK; Set the default userstack value on reset    
   346                              <1>     
   347                              <1> monitor_segments:    
   348                              <1>     ; Set up the segment registers and stack
   349 000030F5 B80070              <1>     mov ax, STACKSEG
   350 000030F8 8ED0                <1>     mov ss, ax     ; Set Stack Segment at 0x7000
   351 000030FA B80070              <1>     mov ax, DATASEG
   352 000030FD 8ED8                <1>     mov ds, ax     ; Set ds to 0x7000
   353 000030FF 8EC0                <1>     mov es, ax     ; Set es to 0x7000
   354                              <1>     ;mov ax, PIASEG PIA now uses IO Port don't need es anymore, use for memdisp
   355                              <1>     ;mov es, ax     ; Set es to 0xD000 for PIA (at 0xD0000)  PIA now uses IO Port don't need es anymore, use for memdisp
   356 00003101 3EC706EAFF0070      <1>     mov [ds:GO_CS], word USERCODESEG; Store default User Code Segment for Go now can be set with C code segment command
   357 00003108 3EC706E2FF0070      <1>     mov [ds:EXTRA_SEGMENT], word DATASEG; Store default Data Segment for Go now can be set with E extra segment command     
   358                              <1> ;    xor ax, ax
   359                              <1> ;    xor bx, bx
   360                              <1> ;    xor cx, cx
   361                              <1> ;    xor dx, dx
   362                              <1> ;    xor di, di
   363                              <1> ;    xor si, si
   364                              <1>     
   365                              <1>     ; Re-enable interrupts
   366 0000310F FB                  <1>     sti
   367                              <1>     ; Write ascending byte values to ds
   368                              <1> ;    xor di, di
   369                              <1>  ;   xor bx, bx
   370                              <1> 
   371                              <1> ;fill_memory:
   372                              <1>     ; Write the incrementing bx to memory for testing Memory access
   373                              <1> ;    mov [ds:di], bl
   374                              <1> 
   375                              <1>     ; Increment bl and the index register
   376                              <1> ;    inc bl
   377                              <1> ;    inc di
   378                              <1>     ;inc di when using bx for word at time
   379                              <1>     ; If di is 0, increase the data segment register to next 64K block
   380                              <1> ;    jnz fill_memory
   381                              <1>     ;mov [ds:0x0000], byte 0xcc 
   382                              <1>     
   383                              <1>     ; Add Flags, IP and CS to stack after reset as DisplayRegisters may get confused before INT3 or NMI?
   384 00003110 31C0                <1>     xor ax, ax  ; Put flags in known state
   385 00003112 9C                  <1>     pushf
   386 00003113 B800F0              <1>     mov ax, MONCODESEG
   387 00003116 50                  <1>     push ax     ; Monitor CS
   388 00003117 B83412              <1>     mov ax, 0x1234
   389 0000311A 50                  <1>     push ax     ; Test IP
   390                              <1>     
   391                              <1> fill_disp_buff:
   392                              <1>     ; Write NC 8088 version# 
   393 0000311B BFF0FF              <1>     mov di, DBUF
   394 0000311E 3EC6056E            <1>     mov byte [ds:di], segN
   395 00003122 47                  <1>     inc di
   396 00003123 3EC60578            <1>     mov byte [ds:di], segC
   397 00003127 47                  <1>     inc di
   398 00003128 3EC6057F            <1>     mov byte [ds:di], seg8
   399 0000312C 47                  <1>     inc di
   400 0000312D 3EC6057E            <1>     mov byte [ds:di], seg0
   401 00003131 47                  <1>     inc di
   402 00003132 3EC6057F            <1>     mov byte [ds:di], seg8
   403 00003136 47                  <1>     inc di
   404 00003137 3EC6057F            <1>     mov byte [ds:di], seg8
   405 0000313B 47                  <1>     inc di
   406 0000313C 3EC60501            <1>     mov byte [ds:di], segDash
   407 00003140 47                  <1>     inc di
   408 00003141 3EC6053D            <1>     mov byte [ds:di], seg5 ; Version 5
   409 00003145 E82401              <1>     call getkey
   410                              <1> 
   411                              <1>     ; Fill registers with test data for testing Reg Display
   412 00003148 B83322              <1>     mov ax, 0x2233
   413 0000314B B95544              <1>     mov cx, 0x4455
   414 0000314E BA7766              <1>     mov dx, 0x6677
   415 00003151 BB9988              <1>     mov bx, 0x8899
   416 00003154 BDBBAA              <1>     mov bp, 0xaabb
   417 00003157 BEDDCC              <1>     mov si, 0xccdd
   418 0000315A BFFFEE              <1>     mov di, 0xeeff
   419                              <1> 
   420                              <1> nmisr:
   421                              <1>    ; Put rest of registers on the stack (now has Flags and dummy IP and CS if after reset)
   422                              <1>    ; After INT 3 or NMI then Flags, CS and IP are on stack already
   423                              <1>    ; pusha does not exist on 8088/8086!
   424                              <1> 
   425 0000315D 54                  <1>    push sp  ; Need sp on stack to use in Regdisp
   426 0000315E 50                  <1>    push ax
   427 0000315F 51                  <1>    push cx
   428 00003160 52                  <1>    push dx
   429 00003161 53                  <1>    push bx
   430 00003162 55                  <1>    push bp
   431 00003163 56                  <1>    push si
   432 00003164 57                  <1>    push di
   433                              <1> 
   434                              <1>    ; Save User Program Stack pointer current value, is restored on Continue or set on GO   default FDFE
   435 00003165 3E8926ECFF          <1>    mov [ds:STACKSTART], sp; NMISR               sts      STACKSTART         ; Save current stack pointer at STACKSTART $13F8 (after NMI or RESET)
   436                              <1> 
   437                              <1> 
   438                              <1> resume:
   439                              <1>     ; Set up the segment registers and stack
   440 0000316A B80070              <1>     mov ax, STACKSEG ;RESUME               lds      #MONSTACK         ; Resume monitor and reinitialise stack pointer   
   441 0000316D 8ED0                <1>     mov ss, ax     ; Set Stack Segment at 0x7000
   442 0000316F BCFEFE              <1>     mov sp, MONSTACK ; Reset Stack from user to monitor which is allocated 250+ bytes FEFE - FE00
   443 00003172 B80070              <1>     mov ax, DATASEG
   444 00003175 8ED8                <1>     mov ds, ax     ; Set ds to 0x7000
   445 00003177 3EA1E2FF            <1>     mov ax, [ds:EXTRA_SEGMENT] ; Get saved extra segment value, defaults to 7000 
   446 0000317B 8EC0                <1>     mov es, ax     ; PIA now uses IO Port for es used for Memdisp, Save & Load
   447                              <1>     ; Leave stack pointer for Register Display, reset will fix broken Stack
   448                              <1>     
   449                              <1>                    ;                     lda      #dpRam            ; Initialise direct page register 
   450                              <1>                    ;                     tfr      a,dp
   451 0000317D E87A02              <1>    call cleardisp  ;                     bsr      CLEARDISP         ; Clear 7 segment display
   452                              <1> 
   453                              <1> ;   Show '-' at left
   454 00003180 B401                <1>    mov ah, segDash ;                     lda      #segDash          ; Display - on left hand digit 1   
   455 00003182 3E8826F0FF          <1>    mov [ds:DBUF],ah;                     sta      <dbuf+0 
   456 00003187 E8E200              <1>    call getkey     ;                     lbsr     GETKEY            ; Wait for a key
   457                              <1> 
   458                              <1> ;   If key is 'M'
   459 0000318A 80FC31              <1>    cmp ah, keyM    ;                     cmpa     #keyM             ; If M Display Memory
   460 0000318D 7503E9DA01          <1>    je memdisp      ;                     lbeq     MEMDISP
   461                              <1> 
   462                              <1> ;   If key is 'R'
   463 00003192 80FC30              <1>    cmp ah, keyR    ;                     cmpa     #keyR             ; If R display Registers
   464 00003195 7503E99702          <1>    je regdisp      ;                     beq      REGDISP
   465                              <1> 
   466                              <1> ;   If key is 'CN'
   467 0000319A 80FC25              <1>    cmp ah, keyCN   ;                     cmpa     #keyCN            ; If Continue then pull CPU state from stack and continue 
   468 0000319D 7448                <1>    je cont         ;                     beq      CONT
   469                              <1> 
   470                              <1> ;   If key is 'L'
   471 0000319F 80FC05              <1>    cmp ah, keyL    ;                     cmpa     #keyL             ; If L then Load from Serial Port in S-REC
   472 000031A2 7503E9ED02          <1>    je load         ;                     lbeq     LOAD
   473                              <1> 
   474                              <1> ;   If key is 'S' (was P for punch)
   475 000031A7 80FC15              <1>    cmp ah, keyS    ;                     cmpa     #keyS             ; If S then Save to Serial Port in S-REC
   476 000031AA 7503E98C03          <1>    je save         ;                     lbeq     SAVE
   477                              <1> 
   478                              <1> ;   If key is 'E' Extra Segment
   479 000031AF 80FC21              <1>    cmp ah, keyE    ;
   480 000031B2 7441                <1>    je setes        ;
   481                              <1> 
   482                              <1> ;   If key is 'C' Code Segment
   483 000031B4 80FC23              <1>    cmp ah, keyC    ;
   484 000031B7 7450                <1>    je setcs        ;
   485                              <1> 
   486                              <1> ;   If key is 'B' Boot BIOS via cold_start
   487 000031B9 80FC13              <1>    cmp ah, keyB    ;
   488 000031BC C70672000000        <1>    mov	word [warm_boot],0	; indicate cold boot
   489 000031C2 7503E9941E          <1>    je cold_start; Start the PC BIOS
   490                              <1> 
   491                              <1> ;   If key is 'G'
   492 000031C7 80FC35              <1>    cmp ah, keyG    ;                     cmpa     #keyG             ; If G then prompt for Address and execute starting at that address
   493 000031CA 759E                <1>    jne resume      ;                     bne      RESUME            ; Otherwise wait for another key
   494                              <1> 
   495                              <1> ;   Prompt and accept start address
   496                              <1> go:
   497 000031CC B47C                <1>    mov ah, segG    ;GO                   lda      #segG             ; Display G on right hand data segment 6
   498 000031CE 3E8826F5FF          <1>    mov [ds:DBUF+5],ah;                   sta      <dbuf+5
   499 000031D3 E80A01              <1>    call baddr      ;                     lbsr     BADDR             ; Get 16 bit address in bx and display on segments 1-4
   500                              <1>    ; Temporary measure until sorted segments and stack from INT3
   501 000031D6 3E891EE8FF          <1>    mov [ds:GO_IP], bx ;               Store desired IP
   502                              <1>    ; mov [ds:GO_CS], word USERCODESEG;Store User Code Segment Now done by reset and C Command
   503 000031DB 3E8B26ECFF          <1>    mov sp, [ds:STACKSTART] ; Restore the user stack pointer from FDFE downwards, saved on NMI and INT 3
   504                              <1>   ; Need FAR in call to use Code Segment at GO_IP/GO_IP_CS
   505 000031E0 3EFF1EE8FF          <1>    call FAR [ds:GO_IP]    ; Now use IP and CS from GO_IP_CS
   506                              <1>                    ;                     ldy      <STACKSTART       ; Get previous saved stack pointer before NMI or SWI
   507                              <1>                    ;                     stx      $0A,y             ; Overwrite PC saved on stack
   508                              <1>                    ;                     lda      #$80              ; Set Entire bit in Condition Code register on stack
   509                              <1>                    ;                     ora      ,y                ; OR with existing CC value
   510                              <1>                    ;                     sta      ,y                ; Save back CC with Entire bit set
   511 000031E5 EB83                <1>    jmp resume      ; Return to monitor if return from Go
   512                              <1>    
   513                              <1> cont:
   514                              <1>                    ;CONT                 lds      <STACKSTART       ; Load stack pointer from saved value
   515                              <1>    ;popa 8088/8086 does not support popa!            ; Get saved registers from stack
   516                              <1> 
   517 000031E7 3E8B26ECFF          <1>    mov sp, [ds:STACKSTART] ; Restore sp from end of push on NMI/INT 3   
   518 000031EC 5F                  <1>    pop di
   519 000031ED 5E                  <1>    pop si
   520 000031EE 5D                  <1>    pop bp
   521 000031EF 5B                  <1>    pop bx
   522 000031F0 5A                  <1>    pop dx
   523 000031F1 59                  <1>    pop cx
   524 000031F2 58                  <1>    pop ax
   525 000031F3 5C                  <1>    pop sp ; This should result in the same sp value before iret as is in STACKSTART
   526                              <1> 
   527 000031F4 CF                  <1>    iret            ;                  rti                        ; Return from interupt, which will load program counter from X value returned from BADDR
   528                              <1> 
   529                              <1> 
   530                              <1> ;   Prompt with E and accept extra segment address
   531                              <1> setes:
   532 000031F5 B479                <1>    mov ah, segE    ; Display E on right hand data segment 6
   533 000031F7 3E8826F5FF          <1>    mov [ds:DBUF+5],ah;                   sta      <dbuf+5
   534 000031FC E8E100              <1>    call baddr      ;                     lbsr     BADDR             ; Get 16 bit address in bx and display on segments 1-4
   535 000031FF 3E891EE2FF          <1>    mov [ds:EXTRA_SEGMENT], bx ; Store desired extra segment
   536 00003204 8EC3                <1>    mov es, bx      ; Change es as well, shouldn't be changed else where other than reset and resume
   537 00003206 E961FF              <1>    jmp resume 
   538                              <1> 
   539                              <1> ;   Prompt with C and accept code segment address
   540                              <1> setcs:
   541 00003209 B478                <1>    mov ah, segC    ; Display C on right hand data segment 6
   542 0000320B 3E8826F5FF          <1>    mov [ds:DBUF+5],ah;                   sta      <dbuf+5
   543 00003210 E8CD00              <1>    call baddr      ;                     lbsr     BADDR             ; Get 16 bit address in bx and display on segments 1-4
   544 00003213 3E891EEAFF          <1>    mov [ds:GO_CS], bx ; Store desired code segment, used by Go
   545 00003218 E94FFF              <1>    jmp resume 
   546                              <1> 
   547                              <1>     ; Note es should be set to PIA map D000, ds to 7000 before calling
   548                              <1> dispresh:	
   549 0000321B 50                  <1>     push ax	           ;dispresh             pshs     x,b,a
   550 0000321C 52                  <1>     push dx            ; dx=x as destination
   551 0000321D 56                  <1>     push si            ; si=x as source
   552                              <1>                        ; ah=a al=b (6809 D=AB)
   553                              <1> 	  ;   set output ports using IO Ports now, change mov to in or out using dx and al, need to reverse 6809 A & B so now A=al and B=ah
   554 0000321E BA01D0              <1>     mov dx, CTRLA	     ;                     ldx      #PORTA            ; This routine uses a different approach from GETKEY using index X and offsets
   555 00003221 31C0                <1>     xor ax,ax	         ;                     clra                       ; note 6809 offsets changed for RS0=A0 & RS1=A1
   556 00003223 EE                  <1>     out dx, al      	 ;                     sta      $01,x             ; Set CTRLA Port A to data direction register b2=0 DDR
   557 00003224 BA03D0              <1>     mov dx, CTRLB	     ;    
   558 00003227 EE                  <1>     out dx, al      	 ;                     sta      $03,x             ; Set CTRLB Port B to data direction register
   559 00003228 B07F                <1>     mov al, 0x7f       ;                     lda      #$7F              ; 
   560 0000322A BA00D0              <1>     mov dx, PORTA
   561 0000322D EE                  <1>     out dx, al	       ;                     sta      ,x                ; Set Port A to output bits 0-6
   562 0000322E B00F                <1>     mov al, 0x0f       ;                     lda      #$0F              ; Set bits 0-3 for output
   563 00003230 BA02D0              <1>     mov dx, PORTB
   564 00003233 EE                  <1>     out dx, al      	 ;                     sta      $02,x             ; Set Port B to output for bits 0-3
   565 00003234 B004                <1>     mov al, 0x04       ;                     lda      #$04              ; Set control register b2=1 Output Register
   566 00003236 BA01D0              <1>     mov dx, CTRLA
   567 00003239 EE                  <1>     out dx, al      	 ;                     sta      $01,x             ; Set CTRLA Port A control register for Port Output, will be keypad switch input
   568 0000323A BA03D0              <1>     mov dx, CTRLB
   569 0000323D EE                  <1>     out dx, al      	 ;                     sta      $03,x             ; Set CTRLB Port B control register for Port Output, will be keypad row
   570                              <1> 	
   571                              <1>     ; initialise loop over digits
   572 0000323E BEF0FF              <1>     mov si, DBUF	    ;                      ldx      #dbuf             ; Segments are numbered 4..9 to correspond to outputs from the 74LS145/7442 decoder.
   573 00003241 B403                <1>     mov ah, 0x03      ;	                     ldb      #$03
   574                              <1> disp1:
   575 00003243 FEC4                <1>     inc ah	          ;disp1                 incb                       ; Start at 04
   576 00003245 80FC0C              <1>     cmp ah, 0x0c      ;	                     cmpb     #$0C              ; until done 11/0B
   577 00003248 7504                <1>     jne disp2 	      ;                      bne      DISP2             ; Display next digit
   578                              <1> 	
   579                              <1> 	  ; finished
   580 0000324A 5E                  <1>     pop si
   581 0000324B 5A                  <1>     pop dx	          ;                      puls     a,b,x,pc          ;(pul? pc=rts) Done all 6 segments 04-09
   582 0000324C 58                  <1>     pop ax	
   583 0000324D C3                  <1>     ret	
   584                              <1> 
   585                              <1>     ; light up the next digit                     ; Changes to reduce Ghosting of 7 Segment displays
   586                              <1> disp2:
   587 0000324E B07F                <1>     mov al, 0x7f      ;disp2                lda      #$7F              ; This turns off all 7 Segments
   588 00003250 BA00D0              <1>     mov dx, PORTA
   589 00003253 EE                  <1> 	  out dx, al        ;                     sta      PORTA             ; Turn off current segments before changing PORTB
   590                              <1>     ; Moved PORTB code from below as need to copy ah to al for out
   591 00003254 BA02D0              <1>     mov dx, PORTB
   592 00003257 88E0                <1>     mov al, ah
   593 00003259 EE                  <1> 	  out dx, al        ;                     stb      PORTB             ; Select segment on Port B (04-09)            
   594                              <1> 
   595 0000325A 3E8A04              <1> 	  mov al, [ds:si]   ;                     lda      ,x+               ; Get segment value from Display buffer first
   596 0000325D 46                  <1>     inc si
   597 0000325E F6D0                <1>     not al	          ;                     coma                       ; Complement 7 Segment values as 1 turns off segment
   598 00003260 BA00D0              <1>     mov dx, PORTA
   599 00003263 EE                  <1> 	  out dx, al        ;                     sta      PORTA               ; Save segment bits to Port A
   600                              <1> 	
   601                              <1> 	  ;   delay loop
   602 00003264 B0A0                <1>     mov al, 0xa0	    ;                     lda      #$A0              ; Delay loop for 160 iterations
   603                              <1> disp3:
   604 00003266 FEC8                <1>     dec al            ;disp3                deca                       
   605 00003268 75FC                <1>     jne disp3	        ;                     bne      DISP3             ; Delay until A is zero
   606 0000326A EBD7                <1>     jmp disp1	        ;                     bra      DISP1             ; Process next segment
   607                              <1> 
   608                              <1> 
   609                              <1> ; Key codes
   610                              <1> ;  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  L SP CN G  M  R  I
   611                              <1> ; 22 24 02 12 14 00 10 04 01 11 03 13 23 33 21 20 05 15 25 35 31 30 32
   612                              <1> 
   613                              <1> ; Now reverses ah and al due to OUT and IN Uses a=al, b=ah returns key code in ah
   614                              <1> 
   615                              <1> getkey:
   616 0000326C 53                  <1>     push bx           ;GETKEY               pshs     y,dp,b
   617 0000326D 52                  <1>     push dx           ;                     lda      #dpPIA            ; Set Direct Page register to PIA page ($40), PIA code uses Direct addressing 
   618                              <1>                       ;                     tfr      a,dp
   619                              <1> 
   620                              <1> ;   Set up I/O port for Port A 0-7 input and Port B 0-3 output, for IO Ports need to swap use of al and ah
   621                              <1> getkey1:
   622 0000326E E8AAFF              <1>     call dispresh     ;GETKEY1              bsr      DISPRESH          ; Refresh 7 Segment display while waiting for key
   623 00003271 31C0                <1>     xor ax, ax        ;                     clra     
   624 00003273 BA01D0              <1>     mov dx, CTRLA
   625 00003276 EE                  <1>     out dx, al        ;                     sta      <CTRLA            ; Set Port A to data direction register b2=0 DDR
   626 00003277 BA03D0              <1>     mov dx, CTRLB
   627 0000327A EE                  <1>     out dx, al        ;                     sta      <CTRLB            ; Set Port B to data direction register
   628 0000327B BA00D0              <1>     mov dx, PORTA
   629 0000327E EE                  <1>     out dx, al        ;                     sta      <PORTA            ; Set Port A to input bits 0-7
   630 0000327F B00F                <1>     mov al, 0x0f      ;                     lda      #$0F              ; set bits 0-3 for output
   631 00003281 BA02D0              <1>     mov dx, PORTB
   632 00003284 EE                  <1>     out dx, al        ;                     sta      <PORTB            ; Set Port B to output for bits 0-3
   633 00003285 B004                <1>     mov al, 0x04      ;                     lda      #$04              ; Set control register b2=1 Output Register
   634 00003287 BA01D0              <1>     mov dx, CTRLA
   635 0000328A EE                  <1>     out dx, al        ;                     sta      <CTRLA            ; Set Port A control register for Port Output, will be keypad switch input
   636 0000328B BA03D0              <1>     mov dx, CTRLB
   637 0000328E EE                  <1>     out dx, al        ;                     sta      <CTRLB            ; Set Port B control register for Port Output, will be keypad row
   638 0000328F B4FF                <1>     mov ah, 0xff      ;                     lda(b)      #$FF           ; *** This should probably set ldb to $FF, bug in original Monitor Code
   639                              <1> getkey2:              ; B register is used to strobe keypad output PB0, PB1 to drive 74LS145 decoder (7442 in original)
   640 00003291 FEC4                <1>     inc ah            ;GETKEY2              incb                       ; Read next keypad row (row will change to 0, key pressed changes from 1 to 0)
   641 00003293 80FC04              <1>     cmp ah,0x04       ;                     cmpb     #$04              ; Done rows 0,1,2,3?
   642 00003296 74D6                <1>     je getkey1        ;                     beq      GETKEY1           ; Scanned all 4 keypad lines, update display and start again
   643 00003298 BA02D0              <1>     mov dx, PORTB
   644 0000329B 88E0                <1>     mov al, ah
   645 0000329D EE                  <1>     out dx, al        ;                     stb      <PORTB            ; Output current keypad row to Port B, selected row output will be set to 0 (default to 1)
   646 0000329E BA00D0              <1>     mov dx, PORTA
   647 000032A1 EC                  <1>     in al, dx         ;                     lda      <PORTA            ; Read keypad keys from Port A (note Port A is pulled high, pressed key sets bit to 0)
   648 000032A2 F6D0                <1>     not al            ;                     coma                       ; Complement keypad input so pressed key is indicated by 1
   649 000032A4 3C00                <1>     cmp al, 0x00
   650 000032A6 74E9                <1>     je getkey2        ;                     beq      GETKEY2           ; If all zero, no key pressed, try next keypad row
   651                              <1> 
   652                              <1> ;   Found a key: decode it, use bh for tmp3 (PA0-5) and bl for tmp2 (Q0-3)
   653 000032A8 88E7                <1>     mov bh, ah        ;                     stb      tmp2              ; Save the keypad row in B to tmp2 (better name ****)
   654 000032AA 88C3                <1>     mov bl, al        ;                     sta      tmp3              ; Save input key to tmp3 (was chksum which maps to same address $13ed)
   655 000032AC 30C0                <1>     xor al, al        ;                     clra                       ; A maintains the bit count of which bit is set
   656 000032AE B401                <1>     mov ah, 0x01      ;                     ldb      #$01              ; Set b0 as test bit
   657                              <1> getkey3:
   658 000032B0 38DC                <1>     cmp ah,bl         ;GETKEY3              cmpb     tmp3              ; Is bit A set?, what happens if two keys pressed, just the lowest?
   659 000032B2 740B                <1>     je getkey4        ;                     beq      GETKEY4           ; If bit is set calculate key code GETKEY4
   660 000032B4 FEC0                <1>     inc al            ;                     inca                       ; Next bit count                       
   661 000032B6 D0E4                <1>     shl ah,0x01       ;                     aslb                       ; Rotate bit to next positon, fill b0 with 0, when all 0 set Z (eq)
   662 000032B8 80FC00              <1>     cmp ah,0x00
   663 000032BB 74D4                <1>     je getkey2        ;                     beq      GETKEY2           ; When done 0-7 then process next keypad row
   664 000032BD EBF1                <1>     jmp getkey3       ;                     bra      GETKEY3           ; Check next bit
   665                              <1> 
   666                              <1> getkey4:
   667 000032BF 88FC                <1>     mov ah,bh         ;GETKEY4              ldb      tmp2              ; Get the keypad row (Q0-3)
   668 000032C1 D0E4                <1>     shl ah,0x01       ;                     aslb                       ; Shift to the top nibble
   669 000032C3 D0E4                <1>     shl ah,0x01       ;                     aslb     
   670 000032C5 D0E4                <1>     shl ah,0x01       ;                     aslb     
   671 000032C7 D0E4                <1>     shl ah,0x01       ;                     aslb     
   672 000032C9 00C4                <1>     add ah,al         ; We want to return key in ah after pop                     pshs     b                 ; Add B to A via stack
   673                              <1>                       ;                     adda     ,s+               ; Add value of B on stack to A to calculate keycode
   674                              <1> 
   675                              <1> ;   Wait for the key to be released
   676 000032CB 50                  <1>     push ax           ;                     pshs     a                 ; Save keycode
   677                              <1>                       ; Use bx for Y and B
   678 000032CC BB0008              <1>     mov bx, 0x0800    ;                     ldy      #$08              ; Keybounce delay will be 8 (Y) x 256 (B), 2048 loops
   679                              <1> getkey5:
   680                              <1>                       ;GETKEY5              clrb                       ; Initialise B as inner loop counter
   681                              <1> getkey6:
   682 000032CF BA00D0              <1>     mov dx, PORTA                      
   683 000032D2 EC                  <1>     in al, dx         ;GETKEY6              lda      <PORTA            ; Check port to see if key still pressed (bit=0 key pressed)
   684 000032D3 F6D0                <1>     not al            ;                     coma                       ; Complement A, non zero (NE) means a key still held down
   685 000032D5 3C00                <1>     cmp al,0x00
   686 000032D7 75F6                <1>     jne getkey5       ;                     bne      GETKEY5           ; If key still pressed, zero count and check again 
   687 000032D9 4B                  <1>     dec bx            ;                     decb                       ; Key released, decrement count
   688 000032DA 75F3                <1>     jne getkey6       ;                     bne      GETKEY6           ; If still not zero check port again (this will de-bounce keys)
   689                              <1>                       ;                     leay     -$01,y            ; Counted down B to 0 from 255, decrement Y
   690                              <1>                       ;                     bne      GETKEY6           ; Check port again, until Y is zero
   691 000032DC 58                  <1>     pop ax            ;                     puls     a,b,dp,y,pc       ; (pul? pc=rts) Keycode returned in A 
   692 000032DD 5A                  <1>     pop dx
   693 000032DE 5B                  <1>     pop bx
   694 000032DF C3                  <1>     ret
   695                              <1> 
   696                              <1> 
   697                              <1> ; 7CB5 BADDR Build 4 digit hex address from keyboard, refreshing display and return address in bx register
   698                              <1> baddr:
   699 000032E0 50                  <1>     push ax           ;BADDR                pshs     b,a               ; Preserve A and B
   700 000032E1 57                  <1>     push di
   701 000032E2 31C0                <1>     xor ax,ax         ;                     clra                       ; Clears D (A+B)
   702                              <1>                       ;                     clrb                       ;
   703 000032E4 BFF0FF              <1>     mov di, DBUF      
   704 000032E7 3E8905              <1>     mov [ds:di],ax    ;                     std      dbuf              ; Clear left 4 digits in display buffer
   705 000032EA 3E894502            <1>     mov [ds:di+2],ax  ;                     std      dbuf+2           
   706                              <1>                       ;                     ldx      #dbuf             ; X is left hand digit of display buffer
   707 000032EE E80A00              <1>     call hexin        ;                     bsr      HEXIN             ; Get two Hexadecimal keys, and display at di, returns value in ah
   708 000032F1 88E7                <1>     mov bh,ah         ;                     pshs     a                 ; Save most significant byte on stack
   709 000032F3 E80500              <1>     call hexin        ;                     bsr      HEXIN             ; Get two Hexadecimal keys, and display at X, returns in A
   710                              <1>                       ;                     puls     b                 ; Now get most significant byte from stack (now in bh)
   711                              <1>                       ;                     bra      BADDR1            ; B=MSB, A=LSB which is wrong way around for D
   712                              <1>                       ; Assume this code is before BADDR to keep the subroutine addresses consistent with 6802 code
   713 000032F6 88E3                <1>     mov bl,ah         ;BADDR1               exg      a,b               ; Swap A and B
   714                              <1>     ; bx now has MSB and LSB for return     tfr      d,x               ; Return address in X
   715 000032F8 5F                  <1>     pop di            ;                     puls     a,b,pc ;(pul? pc=rts)
   716 000032F9 58                  <1>     pop ax
   717 000032FA C3                  <1>     ret
   718                              <1>     
   719                              <1> ; 7CCC HEXIN Use KEYHEX to accept two hex key entries and combines two hex digits in one byte in A and updates display at X and X+1
   720                              <1> hexin:
   721 000032FB E82200              <1>     call keyhex     ;HEXIN                bsr      KEYHEX            ; Get most significant byte (left hand segment)
   722 000032FE 53                  <1>     push bx
   723 000032FF D0E4                <1>     shl ah,0x01     ;                     asla                       ; Shift hex digit value to upper nibble
   724 00003301 D0E4                <1>     shl ah,0x01     ;                     asla     
   725 00003303 D0E4                <1>     shl ah,0x01     ;                     asla     
   726 00003305 D0E4                <1>     shl ah,0x01     ;                     asla     
   727 00003307 88E7                <1>     mov bh, ah      ;                     pshs     a                 ; Save for return value
   728 00003309 E83000              <1>     call l7seg      ;                     bsr      L7SEG             ; Convert MSB (Left hand segment) to segment value
   729 0000330C 3E8825              <1>     mov [ds:di], ah ;                     sta      ,x+               ; Display segment at X and increment to next segment
   730 0000330F 47                  <1>     inc di
   731 00003310 E80D00              <1>     call keyhex     ;                     bsr      KEYHEX            ; Get least significant byte
   732 00003313 00E7                <1>     add bh, ah      ;                     adda     ,s+               ; Add to saved most significant byte and remove from stack
   733                              <1>     ; bh has sum                          pshs     a                 ; Save sum of MSB and LSB
   734 00003315 E82C00              <1>     call r7seg      ;                     bsr      R7SEG             ; Convert LSB (right hand segment) to segment
   735 00003318 3E8825              <1>     mov [ds:di], ah ;                     sta      ,x+               ; Display segment at X and increment to next segment
   736 0000331B 47                  <1>     inc di
   737 0000331C 88FC                <1>     mov ah, bh      ;(pul? pc=rts) return saved Hex two digit value in A 
   738 0000331E 5B                  <1>     pop bx
   739 0000331F C3                  <1>     ret
   740                              <1>     
   741                              <1> ; 7CE4 KEYHEX Combines GETKEY and HEXCON
   742                              <1> ; Gets a single key digit 0-F, converts to 7 Segment, return to monitor if invalid key
   743                              <1> keyhex:
   744 00003320 E849FF              <1>     call getkey       ;KEYHEX               lbsr     GETKEY            ; Get a single key
   745                              <1> 
   746                              <1> ;   Fall-thru
   747                              <1> ; 7CE7 HEXCON converts key code in ah into Hex equivalent for the key and returns in ah, al is not preserved. 
   748                              <1> ; If non Hex command key entered returns to monitor
   749                              <1> hexcon:
   750 00003323 53                  <1>     push bx          ;HEXCON                pshs     x,b
   751 00003324 BB[4636]            <1>     mov bx,KEYCODE-1 ;                      ldx      #KEYCODE          ; Lookup key in KEYCODE table
   752 00003327 B0FF                <1>     mov al, 0xff     ;                      ldb      #$FF
   753                              <1> hexcon1:
   754 00003329 FEC0                <1>     inc al           ;HEXCON1               incb                       ; B will have hex value of KEYCODE
   755 0000332B 43                  <1>     inc bx
   756 0000332C 3C10                <1>     cmp al,0x10      ;                      cmpx     #SVNSEG           ; Check if X is at end of KEYCODE table (or al < 0x10)
   757 0000332E 7503E937FE          <1>     je resume        ;                      beq      TORESUME2         ; If it is at end without finding key, the resume to monitor **** (may not need toresume2 perhaps to avoid lbeq)
   758 00003333 2E3A27              <1>     cmp ah, [cs:bx]  ;                      cmpa     ,x+               ; Compare KEYCODE at X with current key value
   759 00003336 75F1                <1>     jne hexcon1      ;                      bne      HEXCON1           ; If no match then move to next KEYCODE value
   760 00003338 88C4                <1>     mov ah,al        ;                      tfr      b,a               ; Hex digit value returned in A
   761 0000333A 5B                  <1>     pop bx           ;                      puls     b,x,pc ;(pul? pc=rts)
   762 0000333B C3                  <1>     ret 
   763                              <1>     
   764                              <1> ; 7CFF L7SEG converts left hex digit of ah into 7 segment code for display and returns in ah, ax/al is not preserved
   765                              <1> l7seg:
   766                              <1>     ; we could use cl=4
   767 0000333C D0EC                <1>     shr ah,0x01       ;L7SEG                asra                       ; Shift MSB right 4 bits so it is LSB
   768 0000333E D0EC                <1>     shr ah,0x01       ;                     asra     
   769 00003340 D0EC                <1>     shr ah,0x01       ;                     asra     
   770 00003342 D0EC                <1>     shr ah,0x01       ;                     asra     
   771                              <1> 
   772                              <1> ; 7D03 R7SEG converts right hex digit of ah into 7 segment code for display and returns in ah, ax/al is not preserved
   773                              <1> ;   Convert low-order 4 bits of ah to 7seg
   774                              <1> r7seg:
   775 00003344 56                  <1>     push si           ;R7SEG                pshs     x                 ; Save X, used as index to lookup 7 segment values
   776 00003345 53                  <1>     push bx
   777 00003346 BB[5736]            <1>     mov bx, SVNSEG    ;                     ldx      #SVNSEG           ; X is 7 segment lookup table start
   778 00003349 80E40F              <1>     and ah, 0x0f      ;                     anda     #$0F              ; mask MSB
   779 0000334C 88E0                <1>     mov al, ah
   780 0000334E 30E4                <1>     xor ah, ah
   781 00003350 89C6                <1>     mov si, ax        ;R71                  beq      R72               ; A=0 we have found value already
   782                              <1>                       ;                     leax     $01,x             ; Increment X
   783                              <1>                       ;                     deca                       ; Decrease A (note that leax A,X would avoid the need for the loop)
   784                              <1>                       ;                     bra      R71               ; Check next value
   785 00003352 2E8A20              <1>     mov ah, [cs:bx+si];R72                  lda      ,x                ; Get 7 segment value for A
   786 00003355 5B                  <1>     pop bx            ;puls     x,pc              ;(pul? pc=rts) return A and restore X 
   787 00003356 5E                  <1>     pop si
   788 00003357 C3                  <1>     ret
   789                              <1> 
   790                              <1> ; 7D15 SVNHEX Converts 7 segment code in ah to a hex value returned in ah, default to monitor if code not hex, , ax/al is not preserved
   791                              <1> svnhex:
   792 00003358 53                  <1>     push bx          ;SVNHEX               pshs     x,b
   793 00003359 BB[5636]            <1>     mov bx, SVNSEG-1 ;                     ldx      #SVNSEG           ; Lookup value in A in SVNSEG table
   794 0000335C 88E0                <1>     mov al, ah       ;
   795 0000335E 30E4                <1>     xor ah, ah       ;                     clra                       ; Initialise A
   796                              <1> svnhex1:
   797 00003360 43                  <1>     inc bx
   798 00003361 2E3A07              <1>     cmp al,  [cs:bx] ;SVNHEX1              cmpb     ,x+               ; Does 7 segment value match?
   799 00003364 7404                <1>     je svnhex2       ;                     beq      SVNHEX2           ; If match return value in A
   800 00003366 FEC4                <1>     inc ah           ;                     inca                       ; Next segment value
   801 00003368 EBF6                <1>     jmp svnhex1       ;                     bra      SVNHEX1           ; Lookup next code value in SVNSEG 
   802                              <1> svnhex2:
   803 0000336A 5B                  <1>     pop bx           ;SVNHEX2              puls     b,x,pc ;(pul? pc=rts)
   804 0000336B C3                  <1>     ret
   805                              <1> 
   806                              <1> ;   Prompt for address with 'M' and display memory contents
   807                              <1> ;   Changed memory access statements to use es rather than ds as getkey, dispresh etc need ds set to 7000 too
   808                              <1> memdisp:
   809 0000336C 31C0                <1>     xor ax,ax         ;MEMDISP              clra                       ;
   810 0000336E 3E8826F4FF          <1>     mov [ds:DBUF+4],ah;                     sta      <dbuf+4           ; Clear Left Hand Data segment (digit 5)
   811 00003373 B46E                <1>     mov ah, segM      ;                     lda      #segM             ; Display M in right hand data segment (digit 6)
   812 00003375 3E8826F5FF          <1>     mov [ds:DBUF+5],ah;                     sta      <dbuf+5
   813 0000337A E863FF              <1>     call baddr        ;                     bsr      BADDR             ; Gets 4 digit address then displays in Digits 1-4, then returns address in bx
   814                              <1> mem0:
   815 0000337D 268A27              <1>     mov ah, [es:bx]   ;es should be been set by reset, resume or setes ;MEM0                 lda      ,x                ; Get current memory value at X
   816 00003380 88E6                <1>     mov dh, ah        ; Make a copy so we don't use SVNHEX!
   817 00003382 50                  <1>     push ax           ;                     pshs     a                 ; Save memory value
   818 00003383 E8B6FF              <1>     call l7seg        ;                     bsr      L7SEG             ; Convert Most Significant Byte / Left Hand digit to segment
   819 00003386 3E8826F4FF          <1>     mov [ds:DBUF+4],ah;                     sta      <dbuf+4           ; Display MSB on left data segment
   820 0000338B 58                  <1>     pop ax            ;                     puls     a                 ; Get saved memory value
   821 0000338C E8B5FF              <1>     call r7seg        ;                     bsr      R7SEG             ; Convert Least Significant Byte / Right hand digit to segment
   822 0000338F 3E8826F5FF          <1>     mov [ds:DBUF+5],ah;                     sta      <dbuf+5           ; Display LSB on right data segment
   823                              <1> 
   824                              <1> ;   Check for I key
   825                              <1> mem1:
   826 00003394 E8D5FE              <1>     call getkey       ;MEM1                 lbsr     GETKEY            ; Check for key press
   827 00003397 80FC32              <1>     cmp ah, keyI      ;                     cmpa     #keyI             ;  
   828 0000339A 7422                <1>     je mem2           ;                     beq      MEM2              ; If I pressed then save and then get next memory value
   829 0000339C E884FF              <1>     call hexcon       ;                     bsr      HEXCON            ; Not I so convert key to hex value in A, returns to monitor if not 0-F
   830 0000339F 80E60F              <1>     and dh, 0x0F      ; mask top nibble
   831 000033A2 D0E6                <1>     shl dh,0x01       ; Move lower nibble to upper 
   832 000033A4 D0E6                <1>     shl dh,0x01       ;  
   833 000033A6 D0E6                <1>     shl dh,0x01       ;  
   834 000033A8 D0E6                <1>     shl dh,0x01       ;  
   835 000033AA 00E6                <1>     add dh, ah        ; Add the new digit, when saving we can use dh
   836 000033AC 3EA0F5FF            <1>     mov al,[ds:DBUF+5];                     ldb      <dbuf+5           ; Move LSB to MSB (move right to left data segment)
   837 000033B0 3EA2F4FF            <1>     mov [ds:DBUF+4],al;                     stb      <dbuf+4
   838 000033B4 E88DFF              <1>     call r7seg        ;                     bsr      R7SEG             ; Convert A LSB / right hand digit into 7 segment value
   839 000033B7 3E8826F5FF          <1>     mov [ds:DBUF+5],ah;                     sta      <dbuf+5           ; Display LSB in right hand data segment
   840 000033BC EBD6                <1>     jmp mem1          ;                     bra      MEM1              ; Get next key (hex values will continue to rotate LSB to MSB until I pressed or Abort
   841                              <1> 
   842                              <1> 
   843                              <1> ;   Store and increment
   844                              <1> mem2:
   845                              <1>     ; Now dh includes the new contents, no need to use SVNHEX - was using jp NOT jmp!!
   846                              <1>     ;mov ah,[ds:DBUF+4];MEM2                 lda      <dbuf+4           ; Get MSB 7 Segment value
   847                              <1>     ;call svnhex       ;                     bsr      SVNHEX            ; Convert A from 7 segment to Hex MSB value
   848                              <1>     ;shl ah,0x01       ;                     asla                       ; Shift left 4 bits to become MSB nibble     
   849                              <1>     ;shl ah,0x01       ;                     asla     
   850                              <1>     ;shl ah,0x01       ;                     asla     
   851                              <1>     ;shl ah,0x01       ;                     asla     
   852                              <1>     ;mov dl, ah        ;                     pshs     a                 ; Save MSB value
   853                              <1>     ;mov ah,[ds:DBUF+5];                     lda      <dbuf+5           ; Get LSB 7 segment value
   854                              <1>     ;call svnhex       ;                     bsr      SVNHEX            ; Convert A from 7 segment to Hex LSB value
   855                              <1>     ;add ah, dl        ;                     adda     ,s+               ; Add LSB to MSB nibble
   856                              <1>     ;mov dl, ah        ;                     tfr      a,b               ; Save A in B
   857 000033BE 268837              <1>     mov [es:bx], dh   ;                      sta      ,x                ; Store new value in A at X
   858 000033C1 268A27              <1>     mov ah, [es:bx]   ;                      lda      ,x+               ; Re-read memory value from X then increment X for next byte
   859                              <1> ; This won't handle next segment, will wrap around to start of segment
   860 000033C4 43                  <1>     inc bx            ;                     pshs     b                 ; Push new value onto stack
   861 000033C5 38F4                <1>     cmp ah, dh        ;                     cmpa     ,s+               ; Compare new value and current value at X
   862                              <1>     ;int3 debug new code
   863 000033C7 7403E99EFD          <1>     jne resume        ;                     bne      RESUME            ; If not equal then tried to update invalid RAM (eg ROM etc), return to monitor
   864 000033CC 89D8                <1>     mov ax, bx        ;                     tfr      x,d               ; X is now next address, copy to D (A=MSB, B=LSB)
   865 000033CE E86BFF              <1>     call l7seg        ;                     bsr      L7SEG             ; Convert MSB left digit to 7 segment code
   866 000033D1 3E8826F0FF          <1>     mov [ds:DBUF+0],ah;                     sta      <dbuf+0           ; display MSB left digit
   867 000033D6 89D8                <1>     mov ax, bx        ;                     tfr      x,d               ; Copy X to D again
   868 000033D8 E869FF              <1>     call r7seg        ;                     bsr      R7SEG             ; Convert MSB right digit to 7 segment code
   869 000033DB 3E8826F1FF          <1>     mov [ds:DBUF+1],ah;                     sta      <dbuf+1           ; display MSB right digit
   870 000033E0 89D8                <1>     mov ax, bx        ;                     tfr      b,a               ; Copy LSB to A
   871 000033E2 88C4                <1>     mov ah, al        ; r7seg/l7seg does not preserve al
   872 000033E4 E855FF              <1>     call l7seg        ;                                        bsr      L7SEG             ; Convert LSB left digit to 7 segment code
   873 000033E7 3E8826F2FF          <1>     mov [ds:DBUF+2],ah;                     sta      <dbuf+2           ; display LSB left digit
   874 000033EC 89D8                <1>     mov ax, bx        ;                     tfr      b,a               ; Copy B to A again
   875 000033EE 88C4                <1>     mov ah, al        ; r7seg/l7seg does not preserve al
   876 000033F0 E851FF              <1>     call r7seg        ;                     lbsr     R7SEG             ; Convert LSB right digit to 7 segment code
   877 000033F3 3E8826F3FF          <1>     mov [ds:DBUF+3],ah;                     sta      <dbuf+3           ; display LSB right digit
   878 000033F8 EB83                <1>     jmp mem0          ;                 bra      MEM0              ; Get memory value from new X address now on display
   879                              <1> 
   880                              <1> 
   881                              <1> 
   882                              <1> 
   883                              <1> ;   Clear display
   884                              <1> cleardisp:
   885 000033FA 50                  <1>     push ax          ;CLEARDISP            pshs     x,b,a
   886 000033FB 57                  <1>     push di
   887 000033FC 31C0                <1>     xor ax, ax       ;                     clra                       ; Blank segment value
   888 000033FE B008                <1>     mov al, 0x08     ;                     ldb      #$06              ; Iterate over 6 digits 
   889 00003400 BFF0FF              <1>     mov di, DBUF     ;                     ldx      #dbuf 
   890                              <1> cleardisp1:
   891 00003403 3E8825              <1>    mov [ds:di], ah   ;CLEARDISP1           sta      ,x+               ; Clear display buffer
   892 00003406 47                  <1>    inc di
   893 00003407 FEC8                <1>    dec al            ;                     decb                       ; Next segment (1-6)
   894 00003409 75F8                <1>    jne cleardisp1    ;                     bne      CLEARDISP1        ; Next segment
   895 0000340B 5F                  <1>    pop di            ;                     puls     a,b,x,pc ;(pul? pc=rts)
   896 0000340C 58                  <1>    pop ax
   897 0000340D C3                  <1>    ret
   898                              <1> 
   899                              <1> ;R  Register Display register values via the pushed values on the stack (automatic after INT3 vector at [0000:000C] IP:CS)
   900                              <1> ;            Right digits show 
   901                              <1> ;            	FL Flags register
   902                              <1> ;            	CS Code Segment
   903                              <1> ;            	IP Instruction Pointer
   904                              <1> ;             AX AX register CX, DX, BX, (SP), BP, SI, DI
   905                              <1> ;            	CX CX Register
   906                              <1> ;             DX DX Register
   907                              <1> ;             BX BX Register
   908                              <1> ;             (SP SP Register exclude)
   909                              <1> ;             BP BP Register
   910                              <1> ;             SI SI Register
   911                              <1> ;             DI DI Register
   912                              <1> ;            Press I between values
   913                              <1> ;            After DI displayed returns to Monitor, AB to Abort to monitor
   914                              <1> 
   915                              <1> ;   Characters for Register Display  FL CS IP AX CX DX BX SP BP SI DI
   916                              <1> ;   On INT 3, 8088 Pushes Flags on Stack with CS and IP
   917                              <1> ;   Need PUSHA to have most state (no DS, SS or ES),  AX, CX, DX, BX, SP, BP, SI, DI. SP+6 will be value before INT
   918 0000340E 6970783D606B3D6B6F- <1> REGDISPCHAR          db segF,segL, segC,segS, segI,segP, segS,segP, segA,segX
   918 00003417 67                  <1>
   919 00003418 786757677567        <1>                      db segC,segX, segD,segX, segB,segX 
   920 0000341E 756B3D605760        <1>                      db segB,segP, segS,segI, segD,segI
   921                              <1> 
   922                              <1> regdispswi:
   923                              <1>     ; Save the remaining registers to the current stack
   924                              <1>     ; pusha does not exist on 8088/8086!
   925 00003424 54                  <1>     push sp
   926 00003425 50                  <1>     push ax
   927 00003426 51                  <1>     push cx
   928 00003427 52                  <1>     push dx
   929 00003428 53                  <1>     push bx
   930 00003429 55                  <1>     push bp
   931 0000342A 56                  <1>     push si
   932 0000342B 57                  <1>     push di   
   933                              <1> 
   934 0000342C 3E8926ECFF          <1>     mov [ds:STACKSTART],sp; REGDISPSWI           lda      #dpRam             ; Initialise direct page register
   935                              <1>                           ;                      tfr      a,dp
   936                              <1>                           ;                      sts      <STACKSTART        ; Save stackpointer from running code on SWI
   937                              <1>     ; mov sp, MONSTACK this is done in Resume     ;                      lds      #MONSTACK          ; Set stackpointer to monitor default  
   938                              <1> regdisp:
   939 00003431 E8C6FF              <1>     call cleardisp        ; REGDISP              bsr      CLEARDISP          ; Clear display
   940 00003434 3EA1ECFF            <1>     mov ax, [ds:STACKSTART]
   941 00003438 83C015              <1>     add ax, 0x15          ; 10 Registers 22 dec bytes 0x15 (including 0) 
   942 0000343B 89C6                <1>     mov si,ax             ;                      ldx      <STACKSTART        ; Get running stack pointer from saved value into X
   943                              <1> 
   944                              <1> ;   Read double characters from REGDISPCHAR
   945 0000343D BB[0E34]            <1>     mov bx,REGDISPCHAR  ;                      leay     -$1B,pc            ; Loads Y with REGDISPCHAR register table start address ($7DEB) 
   946                              <1> regdisp1:
   947 00003440 2E8A27              <1>     mov ah, [cs:bx]       ;REGDISP1             lda      ,y+                ; Get register prefix character
   948 00003443 3E8826F6FF          <1>     mov [ds:DBUF+6], ah   ;                     sta      <dbuf+5            ; Display at segment 6
   949 00003448 43                  <1>     inc bx
   950 00003449 2E8A27              <1>     mov ah, [cs:bx]       ;                     
   951 0000344C 3E8826F7FF          <1>     mov [ds:DBUF+7], ah   ;                     
   952 00003451 43                  <1>     inc bx
   953                              <1>                           ;                     cmpy     #REGDISPSWI        ; Are we on the last register DI?       
   954                              <1>                           ;                     ldx      #STACKSTART
   955                              <1>                           ;SHOWLEFT             cmpy     #REGDISPCHAR2      ; Are we on single byte values still? X is first 2 byte
   956                              <1>                           ;                     bls      SHOWBYTE           ; Display single byte value
   957 00003452 368A24              <1>     mov ah,[ss:si]        ; This will be LSB    lda      ,x                 ; Get most significant byte of two byte value
   958 00003455 E8E4FE              <1>     call l7seg            ;                     lbsr     L7SEG              ; Get left hand digit segment code
   959 00003458 3E8826F0FF          <1>     mov [ds:DBUF+0], ah   ;                     sta      <dbuf+0            ; Display at segment 1
   960 0000345D 368A24              <1>     mov ah,[ss:si]        ;                     lda      ,x+                ; Get same byte for register and increment X
   961 00003460 E8E1FE              <1>     call r7seg            ;                     lbsr     R7SEG              ; Get right hand digit segment code
   962 00003463 3E8826F1FF          <1>     mov [ds:DBUF+1], ah   ;                     sta      <dbuf+1            ; Display at segment 2
   963 00003468 4E                  <1>     dec si
   964 00003469 368A24              <1>     mov ah,[ss:si]        ;    SHOWBYTE         lda      ,x                 ; Get byte value for register from stack
   965 0000346C E8CDFE              <1>     call l7seg            ;                     lbsr     L7SEG              ; Get left hand segment code
   966 0000346F 3E8826F2FF          <1>     mov [ds:DBUF+2], ah   ;                     sta      <dbuf+2            ; Display at segment 3
   967 00003474 368A24              <1>     mov ah,[ss:si]        ;                     lda      ,x+                ; Get same byte value for register and increment X
   968 00003477 4E                  <1>     dec si
   969 00003478 E8C9FE              <1>     call r7seg            ;                     lbsr     R7SEG              ; Get right hand segment code
   970 0000347B 3E8826F3FF          <1>     mov [ds:DBUF+3], ah   ;                     sta      <dbuf+3            ; Display at segment 4
   971 00003480 E8E9FD              <1>     call getkey           ;                     lbsr     GETKEY             ; Get a key
   972 00003483 80FC32              <1>     cmp ah, keyI          ;                     cmpa     #keyI              ; Has I been pressed
   973 00003486 7403E9DFFC          <1>     jne resume            ;                     lbne     RESUME             ; No then return to monitor 
   974 0000348B 81FB[2434]          <1>     cmp bx, regdispswi    ;                     cmpy     #REGDISPSWI        ; Are we at end of register table?       
   975 0000348F 75AF                <1>     jne regdisp1          ;                     bne      REGDISP1           ; No so display next register
   976 00003491 E9D6FC              <1>     jmp resume            ;                     lbra     RESUME             ; Yes so return to monitor
   977                              <1> 
   978                              <1> 
   979                              <1> ;   Set up serial port, now uses IO Ports not memory mapped IO, need to use al for A and ah for B
   980                              <1> load:
   981 00003494 B003                <1>     mov al, CTRLRESET      ;LOAD                 lda      #CTRLRESET  ; Master Reset bits
   982 00003496 BA00E0              <1>     mov dx, SERIALCTRL
   983 00003499 EE                  <1>     out dx, al             ;                     sta      SERIALCTRL  ; Serial Port Control Master Reset
   984 0000349A B016                <1>     mov al, CTRLDIVIDE64 | CTRLWORD8N1S | CTRLRTSLOW ;
   985                              <1> ;    mov al, CTRLDIVIDE16 | CTRLWORD8N1S | CTRLRTSLOW ;
   986 0000349C EE                  <1>     out dx, al             ;                     sta      SERIALCTRL  ; Serial Port Divide by 64 (3.6864Mhz Xtal /64 =57,600 ), 8 Bits No Parity 1 Stop, /RTS Low - receive data, DCD wired low
   987                              <1> 
   988                              <1> reload:
   989 0000349D E85400              <1>     call recvbyte           ;RELOAD               bsr      RECVBYTE    ; Get a byte without Hex conversion, should be S1 or S9 combination
   990                              <1> 
   991                              <1> ;   Wait for $53 = S
   992 000034A0 3C53                <1>     cmp al, asciiS         ;                     cmpa     #asciiS    
   993 000034A2 75F9                <1>     jne reload             ;                     bne      RELOAD      ; Not S then get next byte
   994 000034A4 E84D00              <1>     call recvbyte          ;                     bsr      RECVBYTE    ; We have S so get next byte, should be S record type 1 or 9
   995                              <1> 
   996                              <1> ;   Code S1 begins a record
   997 000034A7 3C31                <1>     cmp al, ascii1         ;                     cmpa     #ascii1    
   998 000034A9 7408                <1>     je load2               ;                     beq      LOAD2       ; Parse the bytecount and start address, the data and checksum
   999                              <1> 
  1000                              <1> ;   Code S9 means EOF
  1001 000034AB 3C39                <1>     cmp al, ascii9         ;                     cmpa     #ascii9   
  1002 000034AD 75EE                <1>     jne reload             ;                     bne      RELOAD      ; If not S1 or S9 keep reading otherwise display F for finished
  1003                              <1> 
  1004                              <1> ;   Show F for Finished in display forever
  1005                              <1> messagef:
  1006 000034AF B069                <1>     mov al, segF           ;MESSAGEF             lda      #segF
  1007 000034B1 EB35                <1>     jmp errstop            ;                     bra      ERRSTOP
  1008                              <1> 
  1009                              <1> 
  1010                              <1> ;   Get byte count and initialise checksum, use cl for byte count and ch for checksum once calculated in ah, tmp=bx, x=di
  1011                              <1> load2:
  1012 000034B3 E84B00              <1>     call recvhexbyte       ; LOAD2                bsr      RECVHEXBYTE ; Read the Byte Count for Srec format (note NOT Hex character count)
  1013 000034B6 88E1                <1>     mov cl, ah             ;                      stb      bytecount (cl) 
  1014 000034B8 88E5                <1>     mov ch, ah             ;                      lda      bytecount  ; Initialise checksum in A with byte count for new record 
  1015 000034BA FEC9                <1>     dec cl                 ;                      dec      bytecount (cl)
  1016                              <1> 
  1017                              <1> ;   Get two-byte address where to load bytes, accumulating checksum in A
  1018 000034BC E84200              <1>     call recvhexbyte       ;                      bsr      RECVHEXBYTE  ; Get high address byte in B
  1019 000034BF 88E7                <1>     mov bh, ah             ;                      stb      tmpX (bh)  
  1020                              <1>                            ;                      pshs     b
  1021 000034C1 00E5                <1>     add ch, ah             ;                      adda     ,s+          ; add high address to checksum in A
  1022 000034C3 FEC9                <1>     dec cl                 ;                      dec      bytecount   ; reduce byte count by 1
  1023                              <1> 
  1024 000034C5 E83900              <1>     call recvhexbyte       ;                      bsr      RECVHEXBYTE  ; Get low address byte in B
  1025 000034C8 88E3                <1>     mov bl, ah             ;                      stb      tmpX+1 (bl)     ; Save low address byte in tmpX
  1026                              <1>                            ;                      pshs     b
  1027 000034CA 00E5                <1>     add ch, ah             ;                      adda     ,s+          ; add low address to checksum in A
  1028 000034CC 89DF                <1>     mov di, bx             ;                      ldx      tmpX        ; Load address in X for use row data bytes storage  
  1029                              <1> ldloop:
  1030 000034CE FEC9                <1>     dec cl                 ;LDLOOP                dec      bytecount (cl)  ; reduce byte count by 1
  1031                              <1> 
  1032 000034D0 740B                <1>     je lddone              ;                      beq      LDDONE       ; No more bytes? just checksum left
  1033 000034D2 E82C00              <1>     call recvhexbyte       ;                      bsr      RECVHEXBYTE  ; Get next hex characters and convert to bytes in B
  1034                              <1>     ; Now uses extra segment for load
  1035 000034D5 268825              <1>     mov [es:di], ah        ;                      stb      ,x+          ; Save to memory at X
  1036 000034D8 47                  <1>     inc di;                ;
  1037                              <1>                            ;                      pshs     b
  1038 000034D9 00E5                <1>     add ch, ah             ;                      adda     ,s+          ; Add B to checksum held in A     
  1039 000034DB EBF1                <1>     jmp ldloop             ;                      bra      LDLOOP       ; Next byte
  1040                              <1> 
  1041                              <1> 
  1042                              <1> ;   Verify checksum
  1043                              <1> lddone:
  1044 000034DD E82100              <1>     call recvhexbyte       ;LDDONE                bsr      RECVHEXBYTE  ; Get checksum from end of line in B
  1045 000034E0 F6D4                <1>     not ah                 ;                      coma                  ; Since complement not twos complement (NEG) as S19 format checksum would not work
  1046                              <1> 
  1047                              <1>                            ;                      pshs     b            ; Compare B to checksum (which is complement of sum)
  1048 000034E2 38EC                <1>     cmp ah, ch             ;                      cmpa     ,s+          ; to sum of bytes
  1049 000034E4 74B7                <1>     je reload              ;                      beq      RELOAD       ; If zero then checksum and complement of sum of bytes are equal, get next row in file
  1050                              <1> ; Display C for Checksum Error
  1051 000034E6 B078                <1>     mov al, segC           ;                      lda      #segC        ; Checksum not equal so display C error and stop
  1052                              <1> 
  1053                              <1> ;   Fall-thru
  1054                              <1> errstop:
  1055 000034E8 E80FFF              <1>     call cleardisp         ;ERRSTOP              lbsr     CLEARDISP    ; Clear display then show charcters in A (F Finished, E error in Hex, C Checksum error)
  1056 000034EB 3EA2F0FF            <1>     mov [ds:DBUF], al      ;                     sta      dbuf+0  
  1057                              <1> dead:
  1058 000034EF E829FD              <1>     call dispresh          ;DEAD                 lbsr     DISPRESH
  1059 000034F2 EBFB                <1>     jmp dead               ;                     bra      DEAD
  1060                              <1> 
  1061                              <1> ;   Receive one byte from serial port in A, now returns in al
  1062                              <1> recvbyte:
  1063                              <1>                            ;RECVBYTE             lda     #STATUSRDRF   ; Mask Receive Data Register Full
  1064                              <1> recvbyte1:
  1065 000034F4 BA00E0              <1>     mov dx, SERIALSTATUS
  1066 000034F7 EC                  <1>     in al, dx              ;RECVBYTE1        bita    SERIALSTATUS  ; Check RDRF, 1 means has data, 0 loop back
  1067 000034F8 A801                <1>     test al, STATUSRDRF
  1068                              <1>     ;int3
  1069 000034FA 74F8                <1>     jz recvbyte1            ;                    beq     RECVBYTE1     ; Keep checking until read for more data
  1070 000034FC BA01E0              <1>     mov dx, SERIALDATA      ;
  1071 000034FF EC                  <1>     in al, dx               ;                    lda     SERIALDATA    ; Read data from serial port, should clear RDRF
  1072 00003500 C3                  <1>     ret                     ;                    rts
  1073                              <1> 
  1074                              <1> ;   Receive two ASCII characters, convert to a byte and return in B (now ah for IO changes), invalid Hex display E and stop 
  1075                              <1> recvhexbyte:
  1076 00003501 53                  <1>     push bx                 ; RECVHEXBYTE        pshs    a             ; Save A to stack as will have checksum
  1077 00003502 50                  <1>     push ax ; We need to return B/al so use bl 
  1078 00003503 E8EEFF              <1>     call recvbyte           ;                    bsr     RECVBYTE
  1079 00003506 E81900              <1>     call hextobin           ;                    bsr     HEXTOBIN      ; Convert ASCII Hex to Low Nibble
  1080 00003509 D0E0                <1>     shl al,0x01             ;                    lsla                  ; Shift to high nibble
  1081 0000350B D0E0                <1>     shl al,0x01             ;                    lsla
  1082 0000350D D0E0                <1>     shl al,0x01             ;                    lsla
  1083 0000350F D0E0                <1>     shl al,0x01             ;                    lsla
  1084 00003511 88C4                <1>     mov ah, al              ;                    tfr     a,b           ; Save high nibble to B
  1085 00003513 E8DEFF              <1>     call recvbyte           ;                    bsr     RECVBYTE
  1086 00003516 E80900              <1>     call hextobin           ;                    bsr     HEXTOBIN      ; Convert ASCII Hex to Low Nibble
  1087 00003519 00C4                <1>     add ah, al              ;                    addb    ,s+               
  1088 0000351B 88E7                <1>     mov bh, ah              ;
  1089 0000351D 58                  <1>     pop ax                  ;    
  1090 0000351E 88FC                <1>     mov ah, bh              ;                    puls    a,pc           ; B will have returned two chracter Hex Byte value
  1091 00003520 5B                  <1>     pop bx                  ;
  1092 00003521 C3                  <1>     ret
  1093                              <1>     
  1094                              <1> ; Take ASCII character in A (now al with IO changes) and convert to 4 bit Low nibble in A
  1095                              <1> hextobin:
  1096                              <1>     
  1097 00003522 3C30                <1>     cmp al, ascii0           ;HEXTOBIN            cmpa     #'0          ; Compare with ASCII 0
  1098 00003524 7811                <1>     js hexerr                ;                    bmi      HEXERR       ; Less than 0 then error
  1099 00003526 3C39                <1>     cmp al, ascii9           ;                    cmpa     #'9          ; Compare with ASCII 9
  1100 00003528 760A                <1>     jbe hexrts               ;                    ble      HEXRTS       ; Less than or equal then numeric, return value
  1101 0000352A 3C41                <1>     cmp al, asciiA           ;                    cmpa     #'A          ; Compare with ASCII A
  1102 0000352C 7809                <1>     js hexerr                ;                    bmi      HEXERR       ; Less then A then error
  1103 0000352E 3C46                <1>     cmp al, asciiF           ;                    cmpa     #'F          ; Compare with ASCII F
  1104 00003530 7F05                <1>     jg hexerr                ;                    bgt      HEXERR       ; Greater than F then error
  1105 00003532 2C07                <1>     sub al, 0x07             ;                    suba     #7           ; A=$41/65 becomes $3A/58 F=$46/70 becomes $3F/63
  1106                              <1> hexrts:
  1107 00003534 240F                <1>     and al, 0x0f             ;HEXRTS              anda     #$0F         ; Mask high nibble to convert from ASCII to binary 4 low bits      
  1108 00003536 C3                  <1>     ret                      ;                    rts
  1109                              <1> 
  1110                              <1> hexerr:
  1111                              <1> ; Display E for Error in Hexadecimal conversion 
  1112 00003537 B079                <1>    mov al, segE             ;HEXERR               lda      #segE         ; 7 Segment E
  1113 00003539 EBAD                <1>    jmp errstop              ;                     bra      ERRSTOP      ; Will display E - error as invalid Hex character
  1114                              <1> 
  1115                              <1> 
  1116                              <1> ;   Save memory to serial port Prompt S and get start address, ptr SAVE_START, addr SAVE_FINISH 6809 A now = al, B=ah IO Port changes
  1117                              <1> save:
  1118 0000353B 31C0                <1>     xor ax, ax
  1119 0000353D 31C9                <1>     xor cx, cx              ; use cl for checksum as dl now used for IO Port as par of dx!
  1120 0000353F B03D                <1>     mov al, segS            ;SAVE                 ldx      #segS
  1121 00003541 3EA2F4FF            <1>     mov [ds:DBUF+4], al     ;                     stx      <dbuf+4 Space & S
  1122 00003545 E898FD              <1>     call baddr              ;                     lbsr     BADDR
  1123 00003548 3E891EE6FF          <1>     mov [ds:SAVE_START], bx ;                     stx      <ptr
  1124                              <1>     ;int3
  1125                              <1> ;   Prompt F and get finish address
  1126 0000354D B069                <1>     mov al, segF            ;                     lda      #segF
  1127 0000354F 3EA2F4FF            <1>     mov [ds:DBUF+4], al     ;                     sta      <dbuf+5
  1128 00003553 E88AFD              <1>     call baddr              ;                     lbsr     BADDR
  1129 00003556 3E891EE4FF          <1>     mov [ds:SAVE_FINISH], bx;                     stx      <addr
  1130                              <1>     ;int3
  1131                              <1> ;   Set up serial output port - RESET should go in main reset code
  1132 0000355B B003                <1>     mov al, CTRLRESET       ;                     lda      #CTRLRESET  ; Master Reset bits
  1133 0000355D BA00E0              <1>     mov dx, SERIALCTRL
  1134 00003560 EE                  <1>     out dx, al              ;                     sta      SERIALCTRL ; Serial Port Control Master Reset
  1135 00003561 B016                <1>     mov al, CTRLDIVIDE64 | CTRLWORD8N1S | CTRLRTSLOW; lda      #CTRLDIVIDE64 | CTRLWORD8N1S | CTRLRTSLOW
  1136                              <1> ;    mov al, CTRLDIVIDE16 | CTRLWORD8N1S | CTRLRTSLOW; lda      #CTRLDIVIDE16 | CTRLWORD8N1S | CTRLRTSLOW
  1137 00003563 EE                  <1>     out dx, al              ;                     sta      SERIALCTRL ; Serial Port Divide by 64 (3.6864Mhz Xtal /6 /64 =9600 ), 8 Bits No Parity 1 Stop, /RTS Low - send data
  1138                              <1> 
  1139                              <1> save1:                      ;SAVE1 
  1140                              <1> ;   Send block start
  1141                              <1> save4:
  1142 00003564 E88500              <1>     call sendstart          ;SAVE4                lbsr     SENDSTART
  1143 00003567 B0FF                <1>     mov al, 0xFF            ;                     lda      #$FF          ; This is effectively -1
  1144 00003569 3E8A26E6FF          <1>     mov ah, [ds:SAVE_START] ;                     ldb      <ptr+1
  1145                              <1>                              ;                    pshs     b
  1146 0000356E 28E0                <1>     sub al, ah               ;                    suba     ,s+           ; Subtract -1 from b gives +1 - not sure why do it this way 
  1147                              <1> 
  1148                              <1> ;   Send length code and init checksum, dh for checksum
  1149                              <1> save2:
  1150 00003570 240F                <1>     and al, 0x0f             ;SAVE2               anda     #$0F          ; Do maximum of 16 bytes (0-F), but need to allow for data byte 0 in length calculation
  1151 00003572 0404                <1>     add al, 0x04             ;                    adda     #$04          ; Length+2, Checksum+1 data0+1 total 4
  1152                              <1>     ;int3
  1153 00003574 E87F00              <1>     call sendhexa            ;                    lbsr     SENDHEXA      ; Send the length in Hex
  1154 00003577 88C1                <1>     mov cl, al               ;                    sta      <chksum       ; Start the checksum with the length value
  1155                              <1>     ;int3
  1156                              <1> ;   Send (half of) address and add to checksum
  1157 00003579 BBE7FF              <1>     mov bx, SAVE_START+1     ;                    ldx      #ptr          ; Get most significant byte of start address
  1158                              <1>     ; sendbytex loads al from [bx]
  1159                              <1>     ;int3
  1160 0000357C E87400              <1>     call sendbytex           ;                    lbsr     SENDBYTEX     ; Send MSB as Hex
  1161 0000357F 00C1                <1>     add cl, al               ;                    adda     <chksum       ; Add byte value to checksum
  1162                              <1>                              ;                    sta      <chksum 
  1163                              <1> 
  1164                              <1> ;   Send other half of address and add to checksum
  1165 00003581 BBE6FF              <1>     mov bx, SAVE_START  ; LSB in little endian leax     $01,x         ; Get the least significant byte of the start address
  1166                              <1>     ;int3
  1167 00003584 E86C00              <1>     call sendbytex           ;                    lbsr     SENDBYTEX     ; Send LSB as Hex
  1168 00003587 00C1                <1>     add cl, al               ;                    adda     <chksum       ; Add byte value to checksum 
  1169                              <1>                              ;                    sta      <chksum 
  1170 00003589 3E8B1EE6FF          <1>     mov bx, [ds:SAVE_START]  ;                    ldx      <ptr
  1171                              <1> 
  1172                              <1> ;   Send a data byte and add to checksum
  1173                              <1> save3:
  1174 0000358E E86200              <1>     call sendbytex           ;SAVE3                bsr      SENDBYTEX     ; Send the byte pointed to by X a Hex
  1175 00003591 00C1                <1>     add cl, al               ;                     adda     <chksum       ; Add data byte to checksum
  1176                              <1>                              ;                     sta      <chksum 
  1177 00003593 3E391EE4FF          <1>     cmp [ds:SAVE_FINISH], bx ;                     cmpx     <addr
  1178 00003598 740E                <1>     je endblock              ;                     beq      ENDBLOCK      ; Has X reached the Finish Address
  1179 0000359A 43                  <1>     inc bx                   ;                     leax     $01,x         ; Increment X to the next byte
  1180 0000359B 3E891EE6FF          <1>     mov [ds:SAVE_START], bx  ;                     stx      <ptr          ; Update ptr to current X value
  1181 000035A0 3EA0E6FF            <1>     mov al, [ds:SAVE_START]  ;                     lda      <ptr+1        ; Get the LSB value
  1182 000035A4 A80F                <1>     test al, 0x0f            ;                     bita     #$0F          ; Only check the least significant nibble
  1183 000035A6 75E6                <1>     jne save3                ;                     bne      SAVE3         ; Keep sending until 0 (we have done xF byte)
  1184                              <1> 
  1185                              <1> ;   Send checksum
  1186                              <1> endblock:
  1187 000035A8 88C8                <1>     mov al, cl               ;ENDBLOCK             lda      <chksum       ; Done block of 16 bytes (other than 1st or last block)
  1188 000035AA F6D0                <1>     not al                   ;                     coma                   ; Complement checksum (reverse all bits)
  1189 000035AC E84700              <1>     call sendhexa            ;                     bsr      SENDHEXA      ; Send checksum as 2 Hex characters
  1190 000035AF B00D                <1>     mov al, asciiCR          ;                     lda      #asciiCR      ; Send CR LF to end line
  1191 000035B1 E86500              <1>     call send                ;                     lbsr     SEND     
  1192 000035B4 B00A                <1>     mov al, asciiLF          ;                     lda      #asciiLF    
  1193 000035B6 E86000              <1>     call send                ;                     bsr      SEND
  1194                              <1> 
  1195                              <1> ;   Test if all finished
  1196 000035B9 3E3B1EE4FF          <1>     cmp bx, [ds:SAVE_FINISH] ;                     cmpx     <addr         ; Check X against Finish Address
  1197 000035BE 7423                <1>     je sendeof               ;                     beq      SENDEOF       ; Send S9 End of File if X=Finish Address
  1198                              <1> 
  1199                              <1> ;   Test if another full block to send
  1200 000035C0 3EA0E7FF            <1>     mov al,[ds:SAVE_START+1] ;                     lda      <ptr          ; Compare current byte MSB with finish MSB
  1201 000035C4 3E3A06E5FF          <1>     cmp al,[ds:SAVE_FINISH+1];                     cmpa     <addr
  1202 000035C9 7899                <1>     js save4                 ;                     bmi      SAVE4
  1203 000035CB 3E8A26E6FF          <1>     mov ah,[ds:SAVE_START]   ;                     ldb      <ptr+1
  1204 000035D0 3EA0E4FF            <1>     mov al,[ds:SAVE_FINISH]  ;                     lda      <addr+1
  1205 000035D4 24F0                <1>     and al, 0xF0             ;                     anda     #$F0
  1206                              <1>                              ;                     pshs     b
  1207 000035D6 38E0                <1>     cmp al, ah               ;                     cmpa     ,s+
  1208 000035D8 758A                <1>     jne save4                ;                     bne      SAVE4
  1209                              <1> 
  1210                              <1> ;   Last block may be short
  1211 000035DA E80F00              <1>     call sendstart           ;                     bsr      SENDSTART
  1212 000035DD 3EA0E4FF            <1>     mov al, [ds:SAVE_FINISH] ;                     lda      <addr+1
  1213 000035E1 EB8D                <1>     jmp save2                ;                     bra      SAVE2
  1214                              <1> 
  1215                              <1> 
  1216                              <1> ;   Send S19 End of file 53 39 30 33 30 30 30 30 42 46 = 'S9030000FC'
  1217                              <1> sendeof:
  1218 000035E3 BE[3A36]            <1>     mov si, SENDEOFMSG       ;SENDEOF              ldy      #SENDEOFMSG
  1219 000035E6 E83F00              <1>     call sendmsg             ;                     bsr      SENDMSG
  1220 000035E9 E9C3FE              <1>     jmp messagef             ;                     lbra     MESSAGEF 
  1221                              <1> 
  1222                              <1> 
  1223                              <1> ;   Send S19 file format start line 'S1'
  1224                              <1> sendstart:
  1225 000035EC BE[3736]            <1>     mov si, SENDSTARTMSG     ;SENDSTART            ldy      #SENDSTARTMSG
  1226 000035EF E83600              <1>     call sendmsg             ;                     bsr      SENDMSG
  1227 000035F2 C3                  <1>     ret                      ;                     rts
  1228                              <1> 
  1229                              <1> 
  1230                              <1> ;   Transmit byte from (X) and convert from 8 bits to two ASCII HEX characters and send over serial port
  1231                              <1> sendbytex:
  1232 000035F3 268A07              <1>     mov al, [es:bx]             ;SENDBYTEX         lda      ,x       Now uses al=A for IO changes and es for extra segment
  1233                              <1> ; Convert byte in A (al) into Hex as two ASCII characters and send over serial port
  1234                              <1> sendhexa:
  1235 000035F6 50                  <1>     push ax                     ;                  pshs     a            ; Save byte value as need to return since used for checksum calc
  1236 000035F7 50                  <1>     push ax                     ;                  pshs     a            ; Save again so we can mask top and lower nibbles
  1237                              <1>     ; Must use al as daa only works with this register
  1238                              <1>     ; mov al, ah already using al with IO changes
  1239 000035F8 24F0                <1>     and al, 0b11110000          ;                  anda     #%11110000   ; Mask High nibble
  1240 000035FA D0E8                <1>     shr al,0x01                 ;                  lsra                  ; Shift to Low nibble
  1241 000035FC D0E8                <1>     shr al,0x01                 ;                  lsra 
  1242 000035FE D0E8                <1>     shr al,0x01                 ;                  lsra
  1243 00003600 D0E8                <1>     shr al,0x01                 ;                  lsra
  1244                              <1> 
  1245 00003602 0490                <1>     add al, 0x90                ;                  adda     #$90          ; LSB to ASCII Hex as per page 7-2 of Leventhal 0-9  $30-$39 A-F $41-$46
  1246 00003604 27                  <1>     daa                         ;                  daa                    ; DAA on adding $90 sets carry which Makes 0-9 3x and A-F be 4x in adca
  1247 00003605 1440                <1>     adc al, 0x40                ;                  adca     #$40          ; Add $40 makes 0-9 D0-D9  in Decimal 130-139, A-F A0-A5 +$40 + Carry in decimal 141-146 = $41-$46
  1248 00003607 27                  <1>     daa                         ;                  daa                    ; Strips 100 from result to give 30-39 and 41-46
  1249                              <1> 
  1250                              <1>     ; mov ah, al now using al for A
  1251                              <1> 
  1252 00003608 E80E00              <1>     call send                   ;                  bsr      SEND
  1253                              <1> 
  1254 0000360B 58                  <1>     pop ax                      ;                  puls     a 
  1255                              <1>     ; mov al, ah already using al with IO changes
  1256 0000360C 240F                <1>     and al, 0b00001111          ;                  anda     #%00001111    ; Mask Low nibble
  1257                              <1> 
  1258 0000360E 0490                <1>     add al, 0x90                ;                  adda     #$90          ; LSB to ASCII Hex as per page 7-2 of Leventhal, same as above
  1259 00003610 27                  <1>     daa                         ;                  daa
  1260 00003611 1440                <1>     adc al, 0x40                ;                  adca     #$40
  1261 00003613 27                  <1>     daa                         ;                  daa
  1262                              <1>     ; mov ah, al now using al for A
  1263                              <1> 
  1264 00003614 E80200              <1>     call send                   ;                  bsr      SEND
  1265 00003617 58                  <1>     pop ax                      ;                  puls     a
  1266 00003618 C3                  <1>     ret                         ;                  rts
  1267                              <1> 
  1268                              <1> ;   Transmit byte from A now A=al for IO Changes
  1269                              <1> send:
  1270 00003619 50                  <1>     push ax                     ;SEND              pshs    a
  1271                              <1>     ;mov al, STATUSTDRE          ;                  lda     #STATUSTDRE   ; Mask Transmit Data Register Empty
  1272                              <1> send1:
  1273 0000361A BA00E0              <1>     mov dx, SERIALSTATUS
  1274 0000361D EC                  <1>     in al, dx    
  1275 0000361E A802                <1>     test al, STATUSTDRE         ;SEND1             bita    SERIALSTATUS  ; Check TDRE, 1 means ready for more data, 0 loop back
  1276 00003620 74F8                <1>     je send1                    ;                  beq     SEND1         ; Keep checking until ready for more data
  1277 00003622 58                  <1>     pop ax                      ;                  puls    a             ; 
  1278 00003623 BA01E0              <1>     mov dx, SERIALDATA 
  1279 00003626 EE                  <1>     out dx, al                  ;                  sta     SERIALDATA
  1280 00003627 C3                  <1>     ret                         ;                  rts                   ; Return
  1281                              <1> 
  1282                              <1> 
  1283                              <1> ; Send NULL terminated list of BYTES pointed to by Y (si) to serial port
  1284                              <1> sendmsg:
  1285 00003628 2E8A04              <1>     mov al, [cs:si]             ;SENDMSG           lda      ,y+
  1286 0000362B 46                  <1>     inc si
  1287 0000362C 3C00                <1>     cmp al, 0x00
  1288 0000362E 7406                <1>     je sendmsg2                 ;                  beq      SENDMSG2
  1289 00003630 E8E6FF              <1>     call send                   ;                  bsr      SEND
  1290 00003633 90                  <1>     nop                         ;                  nop                 ; Allow SWI to be entered and continue
  1291 00003634 EBF2                <1>     jmp sendmsg                 ;                  bra      SENDMSG
  1292                              <1> 
  1293                              <1> sendmsg2:
  1294 00003636 C3                  <1>     ret                         ;SENDMSG2             rts
  1295                              <1> 
  1296                              <1> ;   Send S19 Start of data S1                         
  1297 00003637 533100              <1> SENDSTARTMSG:        db      asciiS, ascii1, asciiNull    
  1298                              <1> 
  1299                              <1> ;   Send S19 End of file 53 39 30 33 30 30 30 30 46 43 = 'S9030000FC'
  1300 0000363A 533930333030303046- <1> SENDEOFMSG:          db      asciiS, ascii9, ascii0, ascii3, ascii0, ascii0, ascii0, ascii0, asciiF, asciiC, asciiCR, asciiLF, asciiNull    
  1300 00003643 430D0A00            <1>
  1301                              <1> 
  1302                              <1>     
  1303                              <1> ; Keypad keycode lookup table to convert key to nibble values, used by KEYHEX and HEXCON
  1304 00003647 2224021214001004    <1> KEYCODE:             db  key0, key1, key2, key3, key4, key5, key6, key7
  1305 0000364F 0111031323332120    <1>                      db  key8, key9, keyA, keyB, keyC, keyD, keyE, keyF 
  1306                              <1> 
  1307                              <1> ; Seven Segment display lookup table, used to convert 7 Seg value to nibble and nibble to 7 Seg value
  1308                              <1> ; Used by HEXCON, R7SEG and SVNHEX subroutines
  1309 00003657 7E065B1F273D7D0E    <1> SVNSEG:              db  seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7
  1310 0000365F 7F3F6F7578577969    <1>                      db  seg8, seg9, segA, segB, segC, segD, segE, segF
  1311                              <1> 
  1312                              <1> ;        setloc	0FF00h			; Make Far functions fairly fixed in memory map
  1313                              <1>   
  1314                              <1> ; Use this function to avoid hardware interrupts messing up the Nanocomp monitor
  1315                              <1> far_dispresh:
  1316 00003667 E8B1FB              <1>   call dispresh
  1317 0000366A CB                  <1>   retf
  1318                              <1>   
  1319                              <1> far_cleardisp:
  1320 0000366B E88CFD              <1>   call cleardisp
  1321 0000366E CB                  <1>   retf
  1322                              <1> 
  1323                              <1> far_getkey:
  1324 0000366F E8FAFB              <1>    call getkey
  1325 00003672 CB                  <1>    retf
  1326                              <1> 
  1327                              <1> far_send:
  1328 00003673 E8A3FF              <1>    call send
  1329 00003676 CB                  <1>    retf
  1330                              <1> 
  1331                              <1> ; Send byte in al as 2 hex characters to serial port
  1332                              <1> far_sendbytex:
  1333 00003677 E879FF              <1>    call sendbytex
  1334 0000367A CB                  <1>    retf
  1335                              <1> 
  1336                              <1> hw_int_ignore:
  1337 0000367B 50                  <1> 	push	ax
  1338 0000367C B020                <1> 	mov	al,20h
  1339 0000367E E6A0                <1> 	out	pic2_reg0,al	; signal EOI to the slave PIC OCW2
  1340 00003680 E620                <1> 	out	pic1_reg0,al	; signal EOI to the master PIC OCW2
  1341 00003682 58                  <1> 	pop	ax
  1342 00003683 CF                  <1> 	iret
  1343                              <1>    
  1344                              <1> ; Use this function to avoid software interrupts messing up the Nanocomp monitor
  1345                              <1> sw_int_ignore:
  1346 00003684 CF                  <1> 	iret
  1347                              <1> 
  1348                              <1> ; BIOS will now call reset rather than cols_start, then use B to boot BIOS
  1349                              <1> ;=========================================================================
  1350                              <1> ; start - at power up or reset execution starts here (F000:FFF0)
  1351                              <1> ;-------------------------------------------------------------------------
  1352                              <1> ;        setloc	0FFF0h			; Power-On Entry Point, macro fills space from last line with FF
  1353                              <1> ;start:
  1354                              <1> ;        jmp     0F000h:reset
  1355                              <1> ;        setloc	0FFFFh			; Pad remainder of ROM
  1356                              <1> ;	      db	0ffh
   705                                  %endif
   706                                  
   707                                  ;=========================================================================
   708                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
   709                                  ;-------------------------------------------------------------------------	
   710 00003685 FF<rep 19D6h>           	setloc	0E05Bh		; POST Entry Point
   710          ******************       warning: Inserting 6614 bytes [-w+user]
   711                                  cold_start:
   712 0000505B B84000                  	mov	ax,biosdseg
   713 0000505E 8ED8                    	mov	ds,ax
   714 00005060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
   715                                  
   716                                  warm_start:
   717                                  	%ifdef MACHINE_HOMEBREW8088
   718                                  	jmp init_v40
   719                                  	post_init_v40:
   720                                  	%endif; MACHINE_HOMEBREW8088
   721 00005066 FA                      	cli				; disable interrupts
   722 00005067 FC                      	cld				; clear direction flag
   723 00005068 B001                    	mov	al,e_cpu_test
   724 0000506A E680                    	out	post_reg,al		; POST start code
   725                                  
   726                                  ;-------------------------------------------------------------------------
   727                                  ; test CPU's FLAG register
   728                                  
   729 0000506C 31C0                    	xor	ax,ax			; AX = 0
   730 0000506E 724A                    	jb	cpu_fail
   731 00005070 7048                    	jo	cpu_fail
   732 00005072 7846                    	js	cpu_fail
   733 00005074 7544                    	jnz	cpu_fail
   734 00005076 7B42                    	jpo	cpu_fail
   735 00005078 83C001                  	add	ax,1			; AX = 1
   736 0000507B 743D                    	jz	cpu_fail
   737 0000507D 7A3B                    	jpe	cpu_fail
   738 0000507F 2D0280                  	sub	ax,8002h
   739 00005082 7836                    	js	cpu_fail
   740 00005084 40                      	inc	ax
   741 00005085 7133                    	jno	cpu_fail
   742 00005087 D1E0                    	shl	ax,1
   743 00005089 732F                    	jnb	cpu_fail
   744 0000508B 752D                    	jnz	cpu_fail
   745 0000508D D1E0                    	shl	ax,1
   746 0000508F 7229                    	jb	cpu_fail
   747                                  
   748                                  ;-------------------------------------------------------------------------
   749                                  ; Test CPU registers
   750                                  
   751 00005091 B8AAAA                  	mov	ax,0AAAAh
   752                                  .1:
   753 00005094 8ED8                    	mov	ds,ax
   754 00005096 8CDB                    	mov	bx,ds
   755 00005098 8EC3                    	mov	es,bx
   756 0000509A 8CC1                    	mov	cx,es
   757 0000509C 8ED1                    	mov	ss,cx
   758 0000509E 8CD2                    	mov	dx,ss
   759 000050A0 89D5                    	mov	bp,dx
   760 000050A2 89EC                    	mov	sp,bp
   761 000050A4 89E6                    	mov	si,sp
   762 000050A6 89F7                    	mov	di,si
   763 000050A8 81FFAAAA                	cmp	di,0AAAAh
   764 000050AC 7506                    	jnz	.2
   765 000050AE 89F8                    	mov	ax,di
   766 000050B0 F7D0                    	not	ax
   767 000050B2 EBE0                    	jmp	.1
   768                                  .2:
   769 000050B4 81FF5555                	cmp	di,5555h
   770 000050B8 741A                    	jz	cpu_ok
   771                                  
   772                                  cpu_fail:
   773 000050BA B052                    	mov	al,e_cpu_fail
   774 000050BC E680                    	out	post_reg,al
   775                                  
   776                                  ;-------------------------------------------------------------------------
   777                                  ; CPU error: continious beep - 400 Hz
   778                                  
   779 000050BE B0B6                    	mov	al,0B6h
   780 000050C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   781 000050C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   782 000050C5 E642                    	out	pit_ch2_reg,al
   783 000050C7 88E0                    	mov	al,ah
   784 000050C9 E642                    	out	pit_ch2_reg,al
   785 000050CB E461                    	in	al,ppi_pb_reg
   786 000050CD 0C03                    	or	al,3			; turn speaker on and enable
   787 000050CF E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   788                                  
   789                                  .1:
   790 000050D1 F4                      	hlt
   791 000050D2 EBFD                    	jmp	.1
   792                                  
   793                                  ;-------------------------------------------------------------------------
   794                                  ; CPU test passed
   795                                  
   796                                  cpu_ok:
   797                                  
   798                                  ;-------------------------------------------------------------------------
   799                                  ; disable NMI, turbo mode, and video output on CGA and MDA
   800                                  
   801 000050D4 B002                    	mov	al,e_init_cfg
   802 000050D6 E680                    	out	post_reg,al
   803                                  
   804                                  %ifdef AT_NMI
   805                                  	mov	al,0Dh & nmi_disa_mask
   806                                  	out	nmi_mask_reg,al		; disable NMI
   807                                  	jmp	$+2
   808                                  	in	al,(nmi_mask_reg+1)	; dummy read to keep RTC happy
   809                                  %else ; AT_NMI
   810 000050D8 B000                    	mov	al,nmi_disable
   811 000050DA E6A0                    	out	nmi_mask_reg,al		; disable NMI
   812                                  %endif ; AT_NMI
   813                                  
   814                                  %ifdef MACHINE_XI8088
   815                                  	mov	al,iochk_disable	; clear and disable ~IOCHK
   816                                  	out	ppi_pb_reg,al
   817                                  	mov	al,00h			; clear turbo bit
   818                                  	out	ppi_pb_reg,al		; and also turn off the speaker
   819                                  %endif ; MACHINE_XI8088
   820                                  
   821                                  %ifdef MACHINE_FE2010A
   822                                  	mov	al,fe_par_disable	; Disable parity checking
   823                                  	out	fe_config_reg,al	; FE2010A chipset configuration register
   824                                  	mov	al,10110000b		; Clear keyboard, disable keyboard clock
   825                                  					; disable IOCHCK NMI, disable MB DRAM NMI
   826                                  	out	ppi_pb_reg,al		; Disable parity and IOCHK
   827                                  %endif ; MACHINE_FE2010A
   828                                  
   829                                  %ifdef MACHINE_BOOK8088
   830                                  	mov	al,00h			; clear turbo bit
   831                                  	out	ppi_pb_reg,al		; and also turn off the speaker
   832                                  %endif ; MACHINE_BOOK8088
   833                                  
   834                                  %ifdef MACHINE_XT
   835                                  	mov	al,ppi_cwd_value	; PPI port A and port C inputs
   836                                  	out	ppi_cwd_reg,al		; PPI control word register
   837                                  	mov	al,10100101b		; Clear keyboard, disable keyboard clock
   838                                  					; disable IOCHCK NMI, enable MB DRAM NMI
   839                                  	out	ppi_pb_reg,al
   840                                  %endif ; MACHINE_XT
   841                                  
   842 000050DC B000                    	mov	al,00h
   843 000050DE BAD803                  	mov	dx,cga_mode_reg
   844 000050E1 EE                      	out	dx,al			; disable video output on CGA
   845 000050E2 FEC0                    	inc	al
   846 000050E4 BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
   847 000050E7 EE                      	out	dx,al			; and set MDA high-resolution mode bit
   848                                  
   849                                  ;-------------------------------------------------------------------------
   850                                  ; Initialize DMAC (8237)
   851                                   
   852 000050E8 B003                    	mov	al,e_init_dmac
   853 000050EA E680                    	out	post_reg,al
   854 000050EC E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
   855                                  %ifdef MACHINE_XT
   856                                  					; set up DRAM refresh on DMA channel 0
   857                                  	mov	al,0ffh			; 16-bit memory refresh counter = 0FFFFh
   858                                  	out	dmac_ch0_count_reg,al	; write low byte
   859                                  	nop
   860                                  	out	dmac_ch0_count_reg,al	; write high byte
   861                                  	inc	ax			; al = 0
   862                                  	out	dmac_mask_reg,al	; enable DMA channel 0
   863                                  	mov	al,58h			; single mode, auto-init, read, channel 0
   864                                  %else ; MACHINE_XT
   865 000050EE B040                     	mov	al,40h			; single mode, verify, channel 0
   866                                  %endif ; MACHINE_XT
   867 000050F0 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   868 000050F2 B041                     	mov	al,41h			; single mode, verify, channel 1
   869 000050F4 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   870 000050F6 B042                     	mov	al,42h			; single mode, verify, channel 2
   871 000050F8 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   872 000050FA B043                     	mov	al,43h			; single mode, verify, channel 3
   873 000050FC E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   874 000050FE B000                     	mov	al,0			; DMA Command register bits:
   875                                   					; DACK active low, DREQ active high,
   876                                   					; late write, fixed priority,
   877                                   					; normal timing, controller enable
   878                                   					; channel 0 addr hold disable
   879                                   					; memory to memory disable
   880 00005100 E608                     	out	08h,al			; DMA Command register
   881 00005102 E681                     	out	81h,al			; DMA Page, channel 2
   882 00005104 E682                     	out	82h,al			; DMA Page, channel 3
   883 00005106 E683                     	out	83h,al			; DMA Page, channels 0,1
   884                                  
   885                                  ;-------------------------------------------------------------------------
   886                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
   887                                  
   888 00005108 B004                    	mov	al,e_low_ram_test
   889 0000510A E680                    	out	post_reg,al
   890 0000510C 31F6                    	xor	si,si
   891 0000510E 31FF                    	xor	di,di
   892 00005110 8EDF                    	mov	ds,di
   893 00005112 8EC7                    	mov	es,di
   894 00005114 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
   895 00005118 B8AA55                  	mov	ax,55AAh		; first test pattern
   896 0000511B B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   897 0000511E F3AB                        rep	stosw				; store test pattern
   898 00005120 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   899                                  .1:
   900 00005123 AD                      	lodsw
   901 00005124 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
   902 00005127 7524                    	jne	low_ram_fail
   903 00005129 E2F8                    	loop	.1
   904 0000512B 31F6                    	xor	si,si
   905 0000512D 31FF                    	xor	di,di
   906 0000512F B855AA                  	mov	ax,0AA55h		; second test pattern
   907 00005132 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   908 00005135 F3AB                        rep stosw				; store test pattern
   909 00005137 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   910                                  .2:
   911 0000513A AD                      	lodsw
   912 0000513B 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
   913 0000513E 750D                    	jne	low_ram_fail
   914 00005140 E2F8                    	loop	.2
   915 00005142 31FF                    	xor	di,di
   916 00005144 31C0                    	xor	ax,ax			; zero
   917 00005146 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   918 00005149 F3AB                        rep stosw				; zero the memory
   919 0000514B EB29                    	jmp	low_ram_ok		; test passed
   920                                  
   921                                  low_ram_fail:
   922 0000514D B054                    	mov	al,e_low_ram_fail	; test failed
   923 0000514F E680                    	out	post_reg,al
   924                                    
   925                                  ;-------------------------------------------------------------------------
   926                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
   927                                  
   928 00005151 B0B6                    	mov	al,0B6h
   929 00005153 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   930 00005155 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   931 00005158 E642                    	out	pit_ch2_reg,al
   932 0000515A 88E0                    	mov	al,ah
   933 0000515C E642                    	out	pit_ch2_reg,al
   934 0000515E E461                    	in	al,ppi_pb_reg
   935                                  .1:
   936 00005160 0C03                    	or	al,3			; turn speaker on and enable
   937 00005162 E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   938 00005164 B90000                  	mov	cx,0
   939                                  .2:
   940 00005167 90                      	nop
   941 00005168 E2FD                    	loop	.2
   942 0000516A 24FC                    	and	al,0FCh			; turn of speaker
   943 0000516C E661                    	out	ppi_pb_reg,al
   944 0000516E B90000                  	mov	cx,0
   945                                  .3:
   946 00005171 90                      	nop
   947 00005172 E2FD                    	loop	.3
   948 00005174 EBEA                    	jmp	.1
   949                                  
   950                                  ;-------------------------------------------------------------------------
   951                                  ; Low memory test passed
   952                                  
   953                                  low_ram_ok:
   954 00005176 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
   955                                  
   956                                  ;-------------------------------------------------------------------------
   957                                  ; Set up stack - using upper 256 bytes of interrupt table
   958                                  
   959 0000517A B83000                  	mov	ax,0030h
   960 0000517D 8ED0                    	mov	ss,ax
   961 0000517F BC0001                  	mov	sp,0100h
   962                                  
   963                                  ;-------------------------------------------------------------------------
   964                                  ; Initialize interrupt table
   965                                  
   966 00005182 B005                    	mov     al,e_int_table
   967 00005184 E680                    	out	post_reg,al
   968 00005186 0E                      	push	cs
   969 00005187 1F                      	pop	ds
   970 00005188 31FF                    	xor	di,di
   971 0000518A 8EC7                    	mov	es,di
   972 0000518C BE[A329]                	mov	si,interrupt_table
   973 0000518F B92000                  	mov	cx,0020h		; 32 Interrupt vectors
   974 00005192 B800F0                  	mov	ax,bioscseg
   975                                  .1:
   976 00005195 A5                      	movsw				; copy ISR address (offset part)
   977 00005196 AB                      	stosw				; store segment part
   978 00005197 E2FC                    	loop	.1
   979                                  %ifdef SECOND_PIC
   980 00005199 BFC001                  	mov	di,70h*4		; starting from IRQ 70
   981 0000519C BE[E329]                	mov	si,interrupt_table2
   982 0000519F B90800                  	mov	cx,8			; 8 Interrupt vectors
   983                                  .2:
   984 000051A2 A5                      	movsw				; copy ISR address (offset part)
   985 000051A3 AB                      	stosw				; store segment part
   986 000051A4 E2FC                    	loop	.2
   987                                  %endif ; SECOND_PIC
   988                                  
   989                                  ; Set up Nanocomp NMI and INT3 table entries so we can debug using Nanocomp Monitor in BIOS and MS-DOS
   990                                  %define MONCODESEG 0xF000 ; Monitor Code Segment
   991                                  %define NMIVECTOR 0x0008  ; IP and CS for Non Maskable Interrupt
   992                                  %define INT3VECTOR 0x000c ; IP and CS for INT 3 Software Interrupt
   993                                  ;%define NMISR 0x815D      ; Nanocomp Monitor Interrupt Routine
   994                                  ;%define REGDISPSWI 0x8416 ; Nanocomp Monitor Software Interrupt Register display
   995                                  
   996 000051A6 31C0                      xor ax, ax  ; Clear ax
   997 000051A8 8ED8                      mov ds, ax  ; Set DS to low memory
   998 000051AA 3EC7060800[2434]          mov [ds:NMIVECTOR], word regdispswi
   999 000051B1 3EC7060A0000F0            mov [ds:NMIVECTOR+2], word MONCODESEG
  1000 000051B8 3EC7060C00[2434]          mov [ds:INT3VECTOR], word regdispswi
  1001 000051BF 3EC7060E0000F0            mov [ds:INT3VECTOR+2], word MONCODESEG
  1002                                  ;-------------------------------------------------------------------------
  1003                                  ; set DS to BIOS data area
  1004                                  
  1005 000051C6 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1006 000051C9 8ED8                    	mov	ds,ax
  1007                                  
  1008                                  ;-------------------------------------------------------------------------
  1009                                  ; Initialize PIT (8254 timer)
  1010                                  
  1011 000051CB B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
  1012 000051CD E643                    	out	pit_ctl_reg,al
  1013 000051CF B000                    	mov	al,0
  1014 000051D1 E640                    	out	pit_ch0_reg,al
  1015 000051D3 E640                    	out	pit_ch0_reg,al
  1016 000051D5 B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
  1017 000051D7 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
  1018 000051D9 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
  1019 000051DB E641                    	out	pit_ch1_reg,al		; pulse every 15us
  1020                                  
  1021                                  ;-------------------------------------------------------------------------
  1022                                  ; Play "power on" sound - also tests PIT functionality
  1023                                  
  1024 000051DD B006                    	mov     al,e_pit_init
  1025 000051DF E680                    	out	post_reg,al
  1026 000051E1 E850D5                  	call	sound
  1027                                  
  1028                                  ;-------------------------------------------------------------------------
  1029                                  ; Initialize PIC (8259)
  1030                                  
  1031 000051E4 B007                    	mov	al,e_pic_init
  1032 000051E6 E680                    	out	post_reg,al
  1033                                  %ifdef SECOND_PIC
  1034 000051E8 B011                    	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  1035 000051EA E620                    	out	pic1_reg0,al
  1036 000051EC E6A0                    	out	pic2_reg0,al
  1037 000051EE B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  1038 000051F0 E621                    	out	pic1_reg1,al
  1039 000051F2 B070                    	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  1040 000051F4 E6A1                    	out	pic2_reg1,al
  1041 000051F6 B004                    	mov	al,4			; ICW3 - slave is connected to IR2
  1042 000051F8 E621                    	out	pic1_reg1,al
  1043 000051FA B002                    	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  1044 000051FC E6A1                    	out	pic2_reg1,al
  1045 000051FE B001                    	mov	al,1			; ICW4 - 8086/8088
  1046 00005200 E621                    	out	pic1_reg1,al
  1047 00005202 E6A1                    	out	pic2_reg1,al
  1048                                  %else
  1049                                  	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  1050                                  	out	pic1_reg0,al
  1051                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  1052                                  	out	pic1_reg1,al
  1053                                  	mov	al,9			; ICW4 - buffered mode, 8086/8088
  1054                                  	out	pic1_reg1,al
  1055                                  %endif ; SECOND_PIC
  1056                                  
  1057                                  ;-------------------------------------------------------------------------
  1058                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  1059                                  
  1060 00005204 B008                    	mov	al,e_kbd_init
  1061 00005206 E680                    	out	post_reg,al
  1062                                  %ifdef AT_KEYBOARD
  1063 00005208 E82ACB                  	call	kbc_init
  1064                                  %else ; AT_KEYBOARD
  1065                                  %ifndef MACHINE_BOOK8088
  1066                                  	in	al,ppi_pb_reg
  1067                                  	and	al,00111111b		; set keyboard clock low
  1068                                  	out	ppi_pb_reg,al
  1069                                  	mov	cx,10582		; hold clock low for 20 ms
  1070                                  .kbd_reset_wait:
  1071                                  	loop	.kbd_reset_wait
  1072                                  	or	al,11000000b		; set keyboard clear bit, enable clock
  1073                                  	out	ppi_pb_reg,al
  1074                                  	and	al,01111111b		; unset keyboard clear bit
  1075                                  	out	ppi_pb_reg,al
  1076                                  %endif ; MACHINE_BOOK8088
  1077                                  	mov	cx,1000
  1078                                  .kbd_flush:
  1079                                  	mov 	ah,01h
  1080                                  	int	16h
  1081                                  	jz	.kbd_no_key
  1082                                  	mov	ah,00h
  1083                                  	int	16h
  1084                                  .kbd_no_key:
  1085                                  	loop	.kbd_flush
  1086                                  
  1087                                  %endif ; AT_KEYBOARD
  1088                                  
  1089 0000520B E8AD09                  	call	kbd_buffer_init		; setup keyboard buffer
  1090                                  
  1091                                  ;-------------------------------------------------------------------------
  1092                                  ; enable interrupts
  1093                                  
  1094 0000520E B009                    	mov	al,e_int_ena
  1095 00005210 E680                    	out	post_reg,al
  1096                                  %ifdef SECOND_PIC
  1097 00005212 B0B8                    	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  1098 00005214 E621                    	out	pic1_reg1,al
  1099                                  %ifndef PS2_MOUSE
  1100                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  1101                                  %else
  1102 00005216 B0ED                    	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  1103                                  %endif ; PS2_MOUSE
  1104 00005218 E6A1                    	out	pic2_reg1,al
  1105                                  %else
  1106                                  	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  1107                                  	out	pic1_reg1,al
  1108                                  %endif ; SECOND_PIC
  1109 0000521A FB                      	sti
  1110                                  
  1111                                  %ifdef AT_NMI
  1112                                  	mov	al,0Dh | nmi_enable
  1113                                  	out	nmi_mask_reg,al		; enable NMI
  1114                                  	jmp	$+2
  1115                                  	in	al,(nmi_mask_reg+1)	; dummy read to keep RTC happy
  1116                                  %else ; AT_NMI
  1117 0000521B B080                    	mov	al,nmi_enable
  1118 0000521D E6A0                    	out	nmi_mask_reg,al		; enable NMI
  1119                                  %endif ; AT_NMI
  1120                                  
  1121                                  %ifdef MACHINE_FE2010A or MACHINE_XT
  1122                                  ;-------------------------------------------------------------------------
  1123                                  ; Read video mode switches into equipment_list
  1124                                  	in	al,ppi_pb_reg
  1125                                  %ifdef MACHINE_FE2010A
  1126                                  	and	al,0FDh		; clear switch select bit - select SW5-SW8
  1127                                  %endif ; MACHINE_FE2010A
  1128                                  %ifdef MACHINE_XT
  1129                                  	or	al,08h		; set switch select bit - select SW5-SW8
  1130                                  %endif ; MACHINE_XT
  1131                                  	out	ppi_pb_reg,al
  1132                                  	in	al,ppi_pc_reg	; read switches SW5-SW8
  1133                                  	and	al,03h		; video mode is in SW5 and SW6
  1134                                  	mov	cl,4
  1135                                  	shl	al,cl		; move video mode to bits 5-4
  1136                                  	or	[equipment_list],al
  1137                                  %endif ; MACHINE_FE2010A or MACHINE_XT
  1138                                  %ifdef MACHINE_BOOK8088
  1139                                  	or	byte [equipment_list],equip_color_80 ; built-in CGA
  1140                                  %endif ; MACHINE_BOOK8088
  1141                                  ; 
  1142                                  ;-------------------------------------------------------------------------
  1143                                  ; look for video BIOS, initialize it if present
  1144                                  
  1145 0000521F B010                    	mov	al,e_vid_bios_scan
  1146 00005221 E680                    	out	post_reg,al
  1147 00005223 BA00C0                  	mov	dx,0C000h
  1148 00005226 BB00C8                  	mov	bx,0C800h
  1149 00005229 E83016                  	call	extension_scan
  1150 0000522C 833E670000              	cmp	word [67h],0
  1151 00005231 740F                    	jz	.no_video_bios
  1152 00005233 B011                    	mov	al,e_vid_bios_init
  1153 00005235 E680                    	out	post_reg,al
  1154 00005237 FF1E6700                	call	far [67h]
  1155 0000523B B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1156 0000523E 8ED8                    	mov	ds,ax
  1157                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  1158                                  ;	and	word [equipment_list],~equip_video
  1159 00005240 EB1F                    	jmp	.video_initialized
  1160                                  
  1161                                  .no_video_bios:
  1162 00005242 B012                    	mov	al,e_vid_no_bios
  1163 00005244 E680                    	out	post_reg,al
  1164 00005246 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  1165 0000524A 80E430                  	and	ah,equip_video		; get video adapter type
  1166 0000524D B007                    	mov	al,07h			; monochrome 80x25 mode
  1167 0000524F 80FC30                  	cmp	ah,equip_mono		; monochrome?
  1168 00005252 7409                    	jz	.set_mode
  1169 00005254 B003                    	mov	al,03h			; color 80x25 mode
  1170 00005256 80FC20                  	cmp	ah,equip_color_80	; 80x25 color?
  1171 00005259 7402                    	jz	.set_mode
  1172 0000525B B001                    	mov	al,01h			; color 40x24 mode
  1173                                  
  1174                                  .set_mode:
  1175 0000525D B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  1176 0000525F CD10                    	int	10h
  1177                                  
  1178                                  .video_initialized:
  1179                                  
  1180                                  ;-------------------------------------------------------------------------
  1181                                  ; print the copyright message
  1182                                  
  1183 00005261 BE[0000]                	mov	si,msg_copyright
  1184 00005264 E849D6                  	call	print
  1185                                  
  1186                                  %ifdef AT_RTC
  1187                                  
  1188                                  ;-------------------------------------------------------------------------
  1189                                  ; Initialize RTC / NVRAM
  1190                                  ; Read equipment byte from CMOS and set it in BIOS data area
  1191 00005267 E83DBA                  	call	rtc_init
  1192                                  
  1193                                  %endif ; AT_RTC
  1194                                  
  1195                                  %ifdef BIOS_SETUP
  1196 0000526A BE[7B04]                	mov	si,msg_setup		; print setup prompt
  1197 0000526D E840D6                  	call	print
  1198                                  %endif ; BIOS_SETUP
  1199                                  
  1200                                  
  1201                                  ;-------------------------------------------------------------------------
  1202                                  ; detect and print availability of various equipment
  1203                                  
  1204 00005270 E817D5                  	call	detect_cpu		; detect and print CPU type
  1205 00005273 E8AED5                  	call	detect_fpu		; detect and print FPU presence
  1206                                  %ifdef MACHINE_FE2010A
  1207                                  	call	detect_chipset		; detect and print chipset type
  1208                                  %endif ; MACHINE_FE2010A
  1209                                  %ifdef AT_RTC
  1210 00005276 E853BB                  	call	print_rtc		; print current RTC time
  1211                                  %endif ; AT_RTC
  1212 00005279 E8DFD6                  	call	print_display		; print display type
  1213                                  %ifdef PS2_MOUSE
  1214 0000527C E80DD7                  	call	print_mouse		; print mouse presence
  1215                                  %endif ; PS2_MOUSE
  1216 0000527F E8B7D0                  	call	detect_serial		; detect serial ports and print findings
  1217 00005282 E86AD1                  	call	detect_parallel		; detect parallel ports and print
  1218                                  					; findings
  1219 00005285 E8C5C7                  	call	detect_floppy		; detect floppy drive types
  1220 00005288 E8F9C7                  	call	print_floppy		; print floppy drive types
  1221                                  
  1222 0000528B E82C15                  	call	detect_ram		; detect RAM, get RAM size in AX
  1223 0000528E E8D216                  	call	test_ram		; test RAM, get tested RAM size in AX
  1224                                  
  1225 00005291 BE[3E03]                	mov	si,msg_ram_total
  1226 00005294 E819D6                  	call	print
  1227 00005297 E853D6                  	call	print_dec		; print RAM size
  1228 0000529A BE[9603]                	mov	si,msg_kib
  1229 0000529D E810D6                  	call	print
  1230                                  
  1231                                  ; FE2010A - Configure chipset according to detected equipment
  1232                                  %ifdef MACHINE_FE2010A
  1233                                  ; Write settings for emulated DIP switches
  1234                                  	mov	al,byte [equipment_list] ; switches are in low byte of equipment
  1235                                  	and	al,0CEh			; keep floppy, memory size, and FPU bits
  1236                                  	out	fe_control_reg,al
  1237                                  ; Enable FPU NMI if needed, and lock chipset configuration
  1238                                  	and	al,equip_fpu		; enable NMI if the FPU is installed
  1239                                  	or	al,fe_config_lock	; set lock chipset configuration bit
  1240                                  	out	fe_config_reg,al
  1241                                  %endif ; MACHINE_FE2010A
  1242                                  
  1243                                  %ifdef EBDA_SIZE
  1244 000052A0 E880D6                  	call	reserve_ebda		; reserve EBDA if needed
  1245                                  
  1246 000052A3 BE[7903]                	mov	si,msg_ram_avail
  1247 000052A6 E807D6                  	call	print
  1248 000052A9 A11300                  	mov	ax,word [memory_size]
  1249 000052AC E83ED6                  	call	print_dec		; print remaining RAM size
  1250 000052AF BE[9603]                	mov	si,msg_kib
  1251 000052B2 E8FBD5                  	call	print
  1252                                  %endif ; EBDA_SIZE
  1253                                  
  1254 000052B5 E8B014                  	call	detect_rom_ext		; detect and initialize extension ROMs
  1255                                  
  1256 000052B8 E9CBD5                  	jmp boot_os
  1257                                  
  1258                                  ;=========================================================================
  1259                                  ; int_02 - NMI
  1260                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  1261                                  ;	implemented
  1262                                  ;-------------------------------------------------------------------------
  1263 000052BB FF<rep 8h>              	setloc	0E2C3h			; NMI Entry Point
  1263          ******************       warning: Inserting 8 bytes [-w+user]
  1264                                  int_02:
  1265 000052C3 50                      	push	ax
  1266                                  %ifdef AT_NMI
  1267                                  	mov	al,0Dh & nmi_disa_mask
  1268                                  	out	nmi_mask_reg,al		; disable NMI
  1269                                  	jmp	$+2
  1270                                  	in	al,nmi_mask_reg		; read the RTC to keep it happy
  1271                                  %else
  1272 000052C4 B000                    	mov	al,nmi_disable
  1273 000052C6 E6A0                    	out	nmi_mask_reg,al
  1274                                  %endif ; AT_NMI
  1275 000052C8 E461                    	in	al,ppi_pb_reg		; read Port B
  1276 000052CA 88C4                    	mov	ah,al
  1277 000052CC 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  1278 000052CE E661                    	out	ppi_pb_reg,al
  1279 000052D0 A840                    	test	al,iochk_status
  1280 000052D2 7506                    	jnz	.iochk_nmi
  1281 000052D4 88E0                    	mov	al,ah
  1282 000052D6 E661                    	out	ppi_pb_reg,al		; restore original bits
  1283 000052D8 EB23                    	jmp	.exit
  1284                                  
  1285                                  .iochk_nmi:
  1286 000052DA 56                      	push	si
  1287 000052DB BE[FF52]                	mov	si,msg_iochk_nmi
  1288 000052DE E8CFD5                  	call	print
  1289 000052E1 5E                      	pop	si
  1290                                  .1:
  1291 000052E2 B400                    	mov	ah,0h
  1292 000052E4 CD16                    	int	16h
  1293 000052E6 0C20                    	or	al,20h			; convert to lower case
  1294 000052E8 3C64                    	cmp	al,'d'
  1295 000052EA 7411                    	je	.exit			; leave NMIs disabled and exit
  1296 000052EC 3C69                    	cmp	al,'i'
  1297 000052EE 7409                    	je	.ignore			; enable NMIs and exit
  1298 000052F0 3C72                    	cmp	al,'r'
  1299 000052F2 7503E964FD              	je	cold_start
  1300 000052F7 EBE9                    	jmp	.1
  1301                                  .ignore:
  1302                                  %ifdef AT_NMI
  1303                                  	mov	al,0Dh | nmi_enable
  1304                                  	call	rtc_read		; enable NMI
  1305                                  %else
  1306 000052F9 B080                    	mov	al,nmi_enable
  1307 000052FB E6A0                    	out	nmi_mask_reg,al
  1308                                  %endif ; AT_NMI
  1309                                  .exit:
  1310 000052FD 58                      	pop	ax
  1311 000052FE CF                      	iret
  1312                                  
  1313                                  msg_iochk_nmi:
  1314 000052FF 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore, 'd' to disable NMIs, or 'r' to reboot."
  1314 00005308 206465746563746564-
  1314 00005311 2E2054797065202769-
  1314 0000531A 2720746F2069676E6F-
  1314 00005323 72652C202764272074-
  1314 0000532C 6F2064697361626C65-
  1314 00005335 204E4D49732C206F72-
  1314 0000533E 2027722720746F2072-
  1314 00005347 65626F6F742E       
  1315 0000534D 0D0A00                  	db	0Dh, 0Ah, 00h
  1316                                  
  1317                                  ;=========================================================================
  1318                                  ; int_18 - execute ROM BASIC
  1319                                  ; Note:
  1320                                  ;	Prints an error message since we don't have ROM BASIC
  1321                                  ;-------------------------------------------------------------------------
  1322                                  int_18:
  1323 00005350 BE[CA03]                	mov	si,msg_no_basic
  1324 00005353 E85AD5                  	call	print
  1325                                  .1:
  1326 00005356 F4                      	hlt
  1327 00005357 EBFD                    	jmp	.1
  1328                                  
  1329                                  ;=========================================================================
  1330                                  ; Breadboard PC VGA Palette Register definitions
  1331                                  ; Note:
  1332                                  ;	There is a 900+ byte gap in ROM here
  1333                                  ;-------------------------------------------------------------------------
  1334                                  %ifdef MACHINE_BBPC8088
  1335                                  %include	"palette.inc"		; Needed for BB PC INT 10
     1                              <1> ; palette.inc this is only included for BB PC
     2                              <1> ; To work with MDA and CGA we need to use the saved CRTC Address Port either MDA 0x03b4 or CGA 0x03d4
     3                              <1> CRTC_DAC_ADD_WR     EQU  0x00
     4                              <1> CRTC_DAC_COL_VALUE  EQU  0x01
     5                              <1> CRTC_DAC_PIXEL_MASK EQU  0x02
     6                              <1> CRTC_DAC_PORT_MASK  EQU  0xFFF0
     7                              <1> 
     8                              <1> INITPALETTE:
     9 00005359 FA                  <1>   cli
    10 0000535A 56                  <1>   push	si
    11 0000535B 52                  <1>   push	dx
    12 0000535C 51                  <1>   push	cx
    13 0000535D 53                  <1>   push	bx
    14 0000535E 50                  <1>   push	ax
    15                              <1> ;mov	al,0x99  ; MDA Pallette Init!
    16                              <1> ;out	post_reg,al
    17                              <1> 
    18 0000535F 8B166300            <1>   mov	dx,word [video_port] ; Get current MDA/CGA CRTC port 3b4 or 3d4
    19 00005363 83E2F0              <1>   and   dx,CRTC_DAC_PORT_MASK
    20 00005366 83C202              <1>   add   dx, CRTC_DAC_PIXEL_MASK
    21                              <1> ;  mov dx, CRTC_DAC_PIXEL_MASK 
    22 00005369 B0FF                <1>   mov al, 0xFF   
    23 0000536B EE                  <1>   out dx, al                 ; Pixel mask set so disabled
    24                              <1> 
    25 0000536C 31DB                <1>   xor bx, bx
    26 0000536E BE[A053]            <1>   mov si, PALETTE
    27                              <1>   
    28                              <1> ;  mov cx, 24                 ; 24 Palette entries 16 CGA, 4 MDA Green, 4 MDA White
    29 00005371 B92000              <1>   mov cx, 32                 ; 32 Palette entries 16 CGA, 16 B&W
    30                              <1> 
    31 00005374 8B166300            <1>   mov	dx,word [video_port] ; Get current MDA/CGA CRTC port 3b4 or 3d4
    32 00005378 83E2F0              <1>   and   dx,CRTC_DAC_PORT_MASK ; dx masked will now be ADD_WR port
    33                              <1> 
    34                              <1> NEXTPALETTE:
    35                              <1> 
    36                              <1>   ;mov dx, CRTC_DAC_ADD_WR 
    37 0000537B 88D8                <1>   mov al, bl                  
    38 0000537D EE                  <1>   out dx, al                 ; Output Palette address No.
    39                              <1> 
    40 0000537E 42                  <1>   inc dx                     ; Change dx to CRTC_DAC_COL_VALUE 
    41 0000537F 2E8A04              <1>   mov al, [cs:si]
    42 00005382 46                  <1>   inc si
    43 00005383 EE                  <1>   out dx, al                 ; Output Red 
    44 00005384 90                  <1>   nop
    45 00005385 90                  <1>   nop
    46 00005386 2E8A04              <1>   mov al, [cs:si]
    47 00005389 46                  <1>   inc si
    48 0000538A EE                  <1>   out dx, al                 ; Output Green 
    49 0000538B 90                  <1>   nop
    50 0000538C 90                  <1>   nop
    51 0000538D 2E8A04              <1>   mov al, [cs:si]
    52 00005390 46                  <1>   inc si
    53 00005391 EE                  <1>   out dx, al                 ; Output Blue 
    54 00005392 90                  <1>   nop
    55 00005393 90                  <1>   nop
    56 00005394 FEC3                <1>   inc bl
    57 00005396 4A                  <1>   dec dx                     ; switch back to CRTC_DAC_ADD_WR
    58 00005397 E2E2                <1>   LOOP NEXTPALETTE
    59                              <1> 
    60                              <1> 	;mov	al,0x9A  ; MDA Palette Init finished!
    61                              <1> 	;out	post_reg,al
    62                              <1>   
    63 00005399 58                  <1> 	pop	ax
    64 0000539A 5B                  <1> 	pop	bx
    65 0000539B 59                  <1> 	pop	cx
    66 0000539C 5A                  <1> 	pop	dx
    67 0000539D 5E                  <1> 	pop	si
    68 0000539E FB                  <1>   sti
    69 0000539F C3                  <1>   ret
    70                              <1>   
    71                              <1> ; MDA and CGA Palette values for IMS176P VGA Video DAC
    72 000053A0 000000              <1> PALETTE             db      0x00, 0x00, 0x00  ; Black (#000000)
    73                              <1> ;                    db      0x3F, 0x3F, 0x3F  ; White (#FFFFFF) Comment this in for testing using P0 for fore/back, comment out blue
    74 000053A3 000031              <1>                     db      0x00, 0x00, 0x31  ; Blue (#0000C4)
    75 000053A6 003100              <1>                     db      0x00, 0x31, 0x00  ; Green (#00C400)
    76 000053A9 003131              <1>                     db      0x00, 0x31, 0x31  ; Cyan (#00C4C4)
    77 000053AC 310000              <1>                     db      0x31, 0x00, 0x00  ; Red (#C40000)
    78 000053AF 310031              <1>                     db      0x31, 0x00, 0x31  ; Magenta (#C400C4)
    79 000053B2 311F00              <1>                     db      0x31, 0x1F, 0x00  ; Brown (#C47E00)
    80 000053B5 313131              <1>                     db      0x31, 0x31, 0x31  ; Light Gray (#C4C4C4)
    81 000053B8 131313              <1>                     db      0x13, 0x13, 0x13  ; Dark Gray (#4E4E4E)
    82 000053BB 131331              <1>                     db      0x13, 0x13, 0x31  ; Light Blue (#4E4EDC)
    83 000053BE 133713              <1>                     db      0x13, 0x37, 0x13  ; Light Green (#4EDC4E)
    84 000053C1 133C3C              <1>                     db      0x13, 0x3c, 0x3c  ; Light Cyan (#4EF3F3)
    85 000053C4 371313              <1>                     db      0x37, 0x13, 0x13  ; Light Red (#DC4E4E)
    86 000053C7 3C133C              <1>                     db      0x3c, 0x13, 0x3c  ; Light Magenta (#F34EF3)
    87 000053CA 3C3C13              <1>                     db      0x3c, 0x3c, 0x13  ; Yellow  (#F3F34E)
    88 000053CD 3F3F3F              <1>                     db      0x3F, 0x3F, 0x3F  ; White (#FFFFFF)
    89                              <1> 
    90                              <1> ;                    db      0x00, 0x00, 0x00  ; MDA Green - Black (#000000) background
    91                              <1> ;                    db      0x00, 0x31, 0x00  ; Green foreground
    92                              <1> ;                    db      0x00, 0x13, 0x00  ; Dark Green - bright background
    93                              <1> ;                    db      0x00, 0x3F, 0x00  ; Bright Green - bright foreground
    94                              <1> 
    95                              <1> ;                    db      0x00, 0x00, 0x00  ; MDA White - Black (#000000) background
    96                              <1> ;                    db      0x31, 0x31, 0x31  ; Light Grey foreground
    97                              <1> ;                    db      0x13, 0x13, 0x13  ; Dark Grey - bright background
    98                              <1> ;                    db      0x3F, 0x3F, 0x3F  ; White - bright foreground
    99                              <1> 
   100                              <1>                                               ; Order of greyscale values may need adjusting
   101 000053D0 000000              <1>                     db      0x00, 0x00, 0x00  ; CGA Greyscale White - Black (#000000) background
   102 000053D3 313131              <1>                     db      0x31, 0x31, 0x31  ; Light Grey foreground
   103 000053D6 131313              <1>                     db      0x13, 0x13, 0x13  ; Dark Grey - bright background
   104 000053D9 3F3F3F              <1>                     db      0x3F, 0x3F, 0x3F  ; White - bright foreground
   105                              <1> 
   106 000053DC 000000              <1>                     db      0x00, 0x00, 0x00  ; CGA Greyscale White - Black (#000000) background
   107 000053DF 313131              <1>                     db      0x31, 0x31, 0x31  ; Light Grey foreground
   108 000053E2 131313              <1>                     db      0x13, 0x13, 0x13  ; Dark Grey - bright background
   109 000053E5 3F3F3F              <1>                     db      0x3F, 0x3F, 0x3F  ; White - bright foreground
   110                              <1> 
   111 000053E8 000000              <1>                     db      0x00, 0x00, 0x00  ; CGA Greyscale White - Black (#000000) background
   112 000053EB 313131              <1>                     db      0x31, 0x31, 0x31  ; Light Grey foreground
   113 000053EE 131313              <1>                     db      0x13, 0x13, 0x13  ; Dark Grey - bright background
   114 000053F1 3F3F3F              <1>                     db      0x3F, 0x3F, 0x3F  ; White - bright foreground
   115                              <1> 
   116 000053F4 000000              <1>                     db      0x00, 0x00, 0x00  ; CGA Greyscale White - Black (#000000) background
   117 000053F7 313131              <1>                     db      0x31, 0x31, 0x31  ; Light Grey foreground
   118 000053FA 131313              <1>                     db      0x13, 0x13, 0x13  ; Dark Grey - bright background
   119 000053FD 3F3F3F              <1>                     db      0x3F, 0x3F, 0x3F  ; White - bright foreground
  1336                                  %endif
  1337                                  ;=========================================================================
  1338                                  ; int_19 - load and execute the boot sector
  1339                                  ;-------------------------------------------------------------------------
  1340 00005400 FF<rep 2F2h>            	setloc	0E6F2h			; INT 19 Entry Point
  1340          ******************       warning: Inserting 754 bytes [-w+user]
  1341                                  int_19:
  1342 000056F2 E9B911                  	jmp	ipl
  1343                                  
  1344                                  ;=========================================================================
  1345                                  ; configuration data table
  1346                                  ;-------------------------------------------------------------------------
  1347                                  	setloc	0E6F5h
  1348                                  config_table:
  1349 000056F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  1350                                  .bytes:
  1351 000056F7 FC                      	db	MODEL_BYTE		; byte 2: model
  1352 000056F8 04                      	db	MODEL_SUB_BYTE  ; byte 3: submodel = 0 added as parameter from config.inc defaults to 00
  1353 000056F9 00                      	db	00h			    ; byte 4: release = 0
  1354                                  %ifdef SECOND_PIC
  1355                                  %ifdef AT_RTC
  1356 000056FA 74                      	db	01110100b		; byte 5: feature byte 1 Added Extended BIOS Flag with PS2_MOUSE
  1357                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1358                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1359                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1360                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1361                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1362                                  ;		||`-- real time clock installed
  1363                                  ;		|`-- 2nd interrupt controller installed
  1364                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1365                                  %else ; AT_RTC
  1366                                  	db	01010000b		; byte 5: feature byte 1
  1367                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1368                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1369                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1370                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1371                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1372                                  ;		||`-- real time clock installed
  1373                                  ;		|`-- 2nd interrupt controller installed
  1374                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1375                                  %endif ; AT_RTC
  1376                                  %else ; SECOND_PIC
  1377                                  %ifdef AT_RTC
  1378                                  	db	00100000b		; byte 5: feature byte 1
  1379                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1380                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1381                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1382                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1383                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1384                                  ;		||`-- real time clock installed
  1385                                  ;		|`-- 2nd interrupt controller installed
  1386                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1387                                  %else ; AT_RTC
  1388                                  	db	00000000b		; byte 5: feature byte 1
  1389                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1390                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1391                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1392                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1393                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1394                                  ;		||`-- real time clock installed
  1395                                  ;		|`-- 2nd interrupt controller installed
  1396                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1397                                  %endif ; AT_RTC
  1398                                  %endif ; SECOND_PIC
  1399 000056FB 00                      	db	00h			; byte 6: feature byte 2
  1400 000056FC 00                      	db	00h			; byte 7: feature byte 3
  1401 000056FD 00                      	db	00h			; byte 8: feature byte 4
  1402 000056FE 00                      	db	00h			; byte 9: feature byte 5
  1403                                  .size	equ	$-.bytes
  1404                                  
  1405                                  ;=========================================================================
  1406                                  ; Includes with fixed entry points (for IBM compatibility)
  1407                                  ;-------------------------------------------------------------------------
  1408                                  
  1409                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
     1                              <1> ;========================================================================
     2                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
     3                              <1> ;       INT 14h, function AH=00h
     4                              <1> ;       INT 14h, function AH=03h
     5                              <1> ;       INT 14h, function AH=04h
     6                              <1> ;       INT 14h, function AH=05h
     7                              <1> ;	- see serial1.inc for other INT 14h functions
     8                              <1> ;-------------------------------------------------------------------------
     9                              <1> ;
    10                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    11                              <1> ;
    12                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                              <1> ;
    15                              <1> ; This program is free software: you can redistribute it and/or modify
    16                              <1> ; it under the terms of the GNU General Public License as published by
    17                              <1> ; the Free Software Foundation, either version 3 of the License, or
    18                              <1> ; (at your option) any later version.
    19                              <1> ;
    20                              <1> ; This program is distributed in the hope that it will be useful,
    21                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                              <1> ; GNU General Public License for more details.
    24                              <1> ;
    25                              <1> ; You should have received a copy of the GNU General Public License
    26                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                              <1> ;
    28                              <1> ;=========================================================================
    29                              <1> 
    30                              <1> ;=========================================================================
    31                              <1> ; int_14 - BIOS Serial Port Communication Services
    32                              <1> ;-------------------------------------------------------------------------
    33 000056FF FF<rep 2Ah>         <1> 	setloc	0E729h			; INT 14 Entry Point
    33          ******************  <1>  warning: Inserting 42 bytes [-w+user]
    34                              <1> int_14:
    35 00005729 FB                  <1> 	sti
    36 0000572A 51                  <1> 	push	cx
    37 0000572B 52                  <1> 	push	dx
    38 0000572C 56                  <1> 	push	si
    39 0000572D 1E                  <1> 	push	ds
    40 0000572E 53                  <1> 	push	bx
    41 0000572F BB4000              <1> 	mov	bx,biosdseg
    42 00005732 8EDB                <1> 	mov	ds,bx
    43 00005734 80FC06              <1> 	cmp	ah,.max/2
    44 00005737 732B                <1> 	jae	int_14_error		; invalid function number specified
    45 00005739 83FA04              <1> 	cmp	dx,num_serial
    46 0000573C 7326                <1> 	jae	int_14_error		; invalid port number specified
    47 0000573E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
    48 00005741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
    49 00005743 89D3                <1> 	mov	bx,dx
    50 00005745 D1E3                <1> 	shl	bx,1
    51 00005747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
    52 00005749 09D2                <1> 	or	dx,dx
    53 0000574B 7417                <1> 	jz	int_14_error		; specified port is not installed
    54 0000574D B700                <1> 	mov	bh,0
    55 0000574F 88E3                <1> 	mov	bl,ah
    56 00005751 D1E3                <1> 	shl	bx,1
    57 00005753 2EFFA7[5857]        <1>     cs	jmp	near [.dispatch+bx]
    58                              <1> .dispatch:
    59 00005758 [6C57]              <1> 	dw	int_14_fn00
    60 0000575A [D422]              <1> 	dw	int_14_fn01
    61 0000575C [EF22]              <1> 	dw	int_14_fn02
    62 0000575E [A157]              <1> 	dw	int_14_fn03
    63 00005760 [AB57]              <1> 	dw	int_14_fn04
    64 00005762 [0558]              <1> 	dw	int_14_fn05
    65                              <1> .max	equ	$-.dispatch
    66                              <1> 
    67                              <1> int_14_error:
    68 00005764 31C0                <1> 	xor	ax,ax
    69                              <1> 
    70                              <1> int_14_exit:
    71 00005766 5B                  <1> 	pop	bx
    72 00005767 1F                  <1> 	pop	ds
    73 00005768 5E                  <1> 	pop	si
    74 00005769 5A                  <1> 	pop	dx
    75 0000576A 59                  <1> 	pop	cx
    76 0000576B CF                  <1> 	iret
    77                              <1> 
    78                              <1> ;=========================================================================
    79                              <1> ; int_14_fn00 - Initialize serial port
    80                              <1> ; Input:
    81                              <1> ;	AH = 0 - function 00h - initialize serial port
    82                              <1> ;	AL - initialization parameters
    83                              <1> ;		bit 1,0	= 10	- 7 data bits
    84                              <1> ;			= 11	- 8 data bits
    85                              <1> ;		bit 2	= 0	- 1 stop bit
    86                              <1> ;			= 1	- 2 stop bits
    87                              <1> ;		bit 3	= 0	- parity disable
    88                              <1> ;			= 1	- parity enable
    89                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
    90                              <1> ;			= 1	- even parity (if parity enabled)
    91                              <1> ;		bit 7-5 = 000	- 110 bps
    92                              <1> ;			= 001	- 150 bps
    93                              <1> ;			= 010	- 300 bps
    94                              <1> ;			= 011	- 600 bps
    95                              <1> ;			= 100	- 1200 bps
    96                              <1> ;			= 101	- 2400 bps
    97                              <1> ;			= 110	- 4800 bps
    98                              <1> ;			= 111	- 9600 bps
    99                              <1> ;	DX = serial port number (0-3)
   100                              <1> ; Output:
   101                              <1> ;	AL = modem status
   102                              <1> ;		bit 0	= 1	- delta clear to send
   103                              <1> ;		bit 1	= 1	- delta data set ready
   104                              <1> ;		bit 2	= 1	- trailing edge ring indicator
   105                              <1> ;		bit 3	= 1	- delta data carrier detect
   106                              <1> ;		bit 4	= 1	- clear to send
   107                              <1> ;		bit 5	= 1	- data set ready
   108                              <1> ;		bit 6	= 1	- ring indicator
   109                              <1> ;		bit 7	= 1	- data carrier detect
   110                              <1> ;	AH = line status
   111                              <1> ;		bit 0	= 1	- data ready
   112                              <1> ;		bit 1	= 1	- overrun error
   113                              <1> ;		bit 2	= 1	- parity error
   114                              <1> ;		bit 3	= 1	- framing error
   115                              <1> ;		bit 4	= 1	- break interrupt
   116                              <1> ;		bit 5	= 1	- transmitter holding register
   117                              <1> ;		bit 6	= 1	- transmitter empty
   118                              <1> ;		bit 7	= 1	- error in RCVR FIFO
   119                              <1> ;-------------------------------------------------------------------------
   120                              <1> int_14_fn00:
   121 0000576C 88C4                <1> 	mov	ah,al			; save AL to AH
   122 0000576E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
   123 00005771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
   124 00005773 EE                  <1> 	out	dx,al
   125 00005774 31DB                <1> 	xor	bx,bx
   126 00005776 88E3                <1> 	mov	bl,ah
   127 00005778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
   128 0000577B D0EB                <1> 	shr	bl,1
   129 0000577D D0EB                <1> 	shr	bl,1
   130 0000577F D0EB                <1> 	shr	bl,1
   131 00005781 D0EB                <1> 	shr	bl,1
   132 00005783 2E8B9F[C323]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
   133 00005788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
   134 0000578B 88D8                <1> 	mov	al,bl
   135 0000578D EE                  <1> 	out	dx,al			; output divisor - low byte
   136 0000578E 42                  <1> 	inc	dx			; DX = UART base address + 1
   137 0000578F 88F8                <1> 	mov	al,bh
   138 00005791 EE                  <1> 	out	dx,al			; output divisor - high byte
   139 00005792 42                  <1> 	inc	dx
   140 00005793 42                  <1> 	inc	dx			; DX = UART LCR address
   141 00005794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
   142 00005796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
   143                              <1> 					; get control bits
   144 00005798 EE                  <1> 	out	dx,al			; set LCR
   145 00005799 4A                  <1> 	dec	dx
   146 0000579A 4A                  <1> 	dec	dx			; DX = UART IER address
   147                              <1> 					; OPTIMIZATION:
   148                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
   149 0000579B B000                <1> 	mov	al,0
   150 0000579D EE                  <1> 	out	dx,al			; disable interrupts
   151 0000579E 4A                  <1> 	dec	dx			; DX = UART base address
   152                              <1> 					; OPTIMIZATION:
   153                              <1> 					; uart_base = uart_ier_reg - 1
   154 0000579F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
   155                              <1> 
   156                              <1> ;=========================================================================
   157                              <1> ; int_14_fn03 - Return serial port status
   158                              <1> ; Input:
   159                              <1> ;	AH = 03h - function 03h - return serial port status
   160                              <1> ;	DX = serial port number (0-3)
   161                              <1> ; Output:
   162                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
   163                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   164                              <1> ;-------------------------------------------------------------------------
   165                              <1> int_14_fn03:
   166 000057A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
   167 000057A4 EC                  <1> 	in	al,dx
   168 000057A5 88C4                <1> 	mov	ah,al
   169 000057A7 42                  <1> 	inc	dx			; DX = UART MSR address
   170 000057A8 EC                  <1> 	in	al,dx
   171 000057A9 EBBB                <1> 	jmp	int_14_exit
   172                              <1> 
   173                              <1> ;=========================================================================
   174                              <1> ; int_14_fn04 - Extended initialize serial port
   175                              <1> ; Input:
   176                              <1> ;	AH = 04h - function 04h - extended initialize serial port
   177                              <1> ;	AL - break status:
   178                              <1> ;		00h = no break
   179                              <1> ;		01h = break
   180                              <1> ;	BH - parity:
   181                              <1> ;		00h = no parity
   182                              <1> ;		01h = odd parity
   183                              <1> ;		02h = even parity
   184                              <1> ;		03h = stick parity odd
   185                              <1> ;		04h = stick parity even
   186                              <1> ;	BL - stop bits:
   187                              <1> ;		00h = 1 stop bit
   188                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
   189                              <1> ;	CH - word length:
   190                              <1> ;		00h = 5 bits
   191                              <1> ;		01h = 6 bits
   192                              <1> ;		02h = 7 bits
   193                              <1> ;		03h = 8 bits
   194                              <1> ;	CL - bps rate:
   195                              <1> ;		00h = 110 bps
   196                              <1> ;		01h = 150 bps
   197                              <1> ;		02h = 300 bps
   198                              <1> ;		03h = 600 bps
   199                              <1> ;		04h = 1200 bps
   200                              <1> ;		05h = 2400 bps
   201                              <1> ;		06h = 6000 bps
   202                              <1> ;		07h = 9600 bps
   203                              <1> ;		08h = 19200 bps
   204                              <1> ;		09h = 38400 bps
   205                              <1> ;		0Ah = 57600 bps
   206                              <1> ;		0Bh = 115200 bps
   207                              <1> ;	DX = serial port number (0-3)
   208                              <1> ; Output:
   209                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
   210                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   211                              <1> ;-------------------------------------------------------------------------
   212                              <1> int_14_fn04:
   213 000057AB 88C4                <1> 	mov	ah,al			; save AL to AH
   214 000057AD 80F90C              <1> 	cmp	cl,num_divisors
   215 000057B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
   216                              <1> 					; exit returning modem and line status
   217 000057B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
   218 000057B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
   219 000057B7 EE                  <1> 	out	dx,al
   220 000057B8 31DB                <1> 	xor	bx,bx
   221 000057BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
   222 000057BC D0E3                <1> 	shl	bl,1			; index to the word table
   223 000057BE 2E8B9F[C323]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
   224 000057C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
   225 000057C6 88D8                <1> 	mov	al,bl
   226 000057C8 EE                  <1> 	out	dx,al			; output divisor - low byte
   227 000057C9 42                  <1> 	inc	dx			; DX = UART base address + 1
   228 000057CA 88F8                <1> 	mov	al,bh
   229 000057CC EE                  <1> 	out	dx,al			; output divisor - high byte
   230 000057CD 42                  <1> 	inc	dx
   231 000057CE 42                  <1> 	inc	dx			; DX = UART LCR address
   232                              <1> 
   233 000057CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
   234 000057D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
   235                              <1> 
   236 000057D4 D0E0                <1> 	shl	al,1
   237 000057D6 D0E0                <1> 	shl	al,1
   238 000057D8 D0E0                <1> 	shl	al,1			; make place for parity settings
   239                              <1> 	
   240 000057DA 5B                  <1> 	pop	bx			; get original BX value from the stack
   241 000057DB 53                  <1> 	push	bx			; push it back to the stack
   242                              <1> 
   243 000057DC 80FF01              <1> 	cmp	bh,1			; parity setting
   244 000057DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
   245 000057E1 FECF                <1> 	dec	bh
   246 000057E3 80E703              <1> 	and	bh,03h			; get the valid bits only
   247 000057E6 D0E7                <1> 	shl	bh,1
   248 000057E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
   249                              <1> 
   250                              <1> .set_parity:
   251 000057EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
   252                              <1> 
   253 000057EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
   254                              <1> 	
   255 000057EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
   256 000057F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
   257                              <1> 
   258 000057F3 D0E0                <1> 	shl	al,1
   259 000057F5 D0E0                <1> 	shl	al,1			; make place for word length setting
   260                              <1> 
   261 000057F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
   262 000057FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
   263                              <1> 
   264 000057FC EE                  <1> 	out	dx,al			; set LCR
   265 000057FD 4A                  <1> 	dec	dx
   266 000057FE 4A                  <1> 	dec	dx			; DX = UART IER address
   267                              <1> 					; OPTIMIZATION:
   268                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
   269 000057FF B000                <1> 	mov	al,0
   270 00005801 EE                  <1> 	out	dx,al			; disable interrupts
   271 00005802 4A                  <1> 	dec	dx			; DX = UART base address
   272                              <1> 					; OPTIMIZATION:
   273                              <1> 					; uart_base = uart_ier_reg - 1
   274 00005803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
   275                              <1> 
   276                              <1> ;=========================================================================
   277                              <1> ; int_14_fn05 - Extended serial port control
   278                              <1> ; Input:
   279                              <1> ;	AH = 05h - function 05h - extended serial port control
   280                              <1> ;	AL - sub-function:
   281                              <1> ;		00h = read modem control register
   282                              <1> ;		01h = write modem control register
   283                              <1> ;			BL = modem control register
   284                              <1> ;	DX = serial port number (0-3)
   285                              <1> ; Output:
   286                              <1> ;	AX = status	
   287                              <1> ;	sub-function AL = 00h:
   288                              <1> ;		BL = modem control register
   289                              <1> ;-------------------------------------------------------------------------
   290                              <1> int_14_fn05:
   291 00005805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
   292 00005807 750D                <1> 	jnz	int_14_fn05_01
   293                              <1> 
   294                              <1> ;-------------------------------------------------------------------------
   295                              <1> ; sub-function 00h - read modem control register
   296                              <1> ; int_14_fn05_00:
   297 00005809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
   298 0000580C EC                  <1> 	in	al,dx
   299 0000580D 5B                  <1> 	pop	bx			; get BX from the stack
   300 0000580E 88C3                <1> 	mov	bl,al			; BL = MCR content
   301 00005810 53                  <1> 	push	bx			; put BX back to the stack
   302 00005811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
   303 00005814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
   304                              <1> 
   305                              <1> ;-------------------------------------------------------------------------
   306                              <1> ; sub-function 01h - write modem control register
   307                              <1> int_14_fn05_01:
   308 00005816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
   309 00005819 5B                  <1> 	pop	bx			; get BX from the stack
   310 0000581A 53                  <1> 	push	bx			; put BX back to the stack
   311 0000581B 88D8                <1> 	mov	al,bl			; BL = new MCR content
   312 0000581D EE                  <1> 	out	dx,al
   313 0000581E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
   314 00005821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1410                                  %include	"keyboard.inc"		; INT 16, INT 09
     1                              <1> ;=========================================================================
     2                              <1> ; keyboard.inc - Keyboard support
     3                              <1> ;       INT 16h - BIOS Keyboard Services
     4                              <1> ;		- function AH=02h
     5                              <1> ;		- function AH=03h
     6                              <1> ;		- function AH=05h
     7                              <1> ;		- function AH=12h
     8                              <1> ;		- see scancode.inc for other (scancode related)
     9                              <1> ;                 INT 16h functions
    10                              <1> ;       INT 09h - IRQ1 interrupt handler
    11                              <1> ;-------------------------------------------------------------------------
    12                              <1> ;
    13                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    14                              <1> ;
    15                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    16                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    17                              <1> ;
    18                              <1> ; This program is free software: you can redistribute it and/or modify
    19                              <1> ; it under the terms of the GNU General Public License as published by
    20                              <1> ; the Free Software Foundation, either version 3 of the License, or
    21                              <1> ; (at your option) any later version.
    22                              <1> ;
    23                              <1> ; This program is distributed in the hope that it will be useful,
    24                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    25                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    26                              <1> ; GNU General Public License for more details.
    27                              <1> ;
    28                              <1> ; You should have received a copy of the GNU General Public License
    29                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    30                              <1> ;
    31                              <1> ;=========================================================================
    32                              <1> 
    33                              <1> ;=========================================================================
    34                              <1> ; Scan codes and keyboard flags
    35                              <1> ;-------------------------------------------------------------------------
    36                              <1> 
    37                              <1> ; scancodes for special keys
    38                              <1> 
    39                              <1> kbd_num_code	equ	45h
    40                              <1> kbd_scroll_code	equ	46h
    41                              <1> kbd_caps_code	equ	3ah
    42                              <1> kbd_ctrl_code	equ	1dh
    43                              <1> kbd_alt_code	equ	38h
    44                              <1> kbd_rshift_code	equ	36h
    45                              <1> kbd_prtsc_code	equ	37h
    46                              <1> kbd_lshift_code	equ	2ah
    47                              <1> kbd_ins_code	equ	52h
    48                              <1> kbd_del_code	equ	53h
    49                              <1> 
    50                              <1> ; Bits for the various modifier keys
    51                              <1> 
    52                              <1> kbd_rshft_bit	equ	1
    53                              <1> kbd_lshft_bit	equ	2
    54                              <1> kbd_ctrl_bit	equ	4
    55                              <1> kbd_alt_bit	equ	8
    56                              <1> kbd_scroll_bit	equ	10h
    57                              <1> kbd_num_bit	equ	20h
    58                              <1> kbd_caps_bit	equ	40h
    59                              <1> kbd_ins_bit	equ	80h
    60                              <1> 
    61                              <1> ;=========================================================================
    62                              <1> ; int_16 - BIOS keyboard functions
    63                              <1> ;-------------------------------------------------------------------------
    64 00005824 FF<rep Ah>          <1> 	setloc	0E82Eh
    64          ******************  <1>  warning: Inserting 10 bytes [-w+user]
    65                              <1> int_16:
    66                              <1> ;	call	int_trace		; DEBUG
    67 0000582E 53                  <1> 	push	bx
    68 0000582F 1E                  <1> 	push	ds
    69 00005830 BB4000              <1> 	mov	bx,biosdseg
    70 00005833 8EDB                <1> 	mov	ds,bx
    71 00005835 80FC13              <1> 	cmp	ah,.num_func
    72 00005838 7331                <1> 	jae	int_16_exit
    73 0000583A B700                <1> 	mov	bh,0
    74 0000583C 88E3                <1> 	mov	bl,ah
    75 0000583E D1E3                <1> 	shl	bx,1
    76 00005840 2EFFA7[4558]        <1>     cs	jmp	near [.dispatch+bx]
    77                              <1> 
    78                              <1> .dispatch:
    79 00005845 [E421]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
    80 00005847 [3922]              <1> 	dw	int_16_fn01		; check buffer, do not clear
    81 00005849 [7458]              <1> 	dw	int_16_fn02		; get shift status
    82                              <1> %ifdef AT_KEYBOARD
    83 0000584B [7958]              <1> 	dw	int_16_fn03		; set delays
    84                              <1> %else ; AT_KEYBOARD
    85                              <1> 	dw	int_16_exit		; not implemented on XT
    86                              <1> %endif ; AT_KEYBOARD
    87 0000584D [6B58]              <1> 	dw	int_16_exit		; keyclick
    88 0000584F [A658]              <1> 	dw	int_16_fn05		; write to keyboard buffer
    89 00005851 [6B58]              <1> 	dw	int_16_exit		; 06
    90 00005853 [6B58]              <1> 	dw	int_16_exit		; 07
    91 00005855 [6B58]              <1> 	dw	int_16_exit		; 08
    92 00005857 [6B58]              <1> 	dw	int_16_exit		; 09
    93 00005859 [6B58]              <1> 	dw	int_16_exit		; 0A
    94 0000585B [6B58]              <1> 	dw	int_16_exit		; 0B
    95 0000585D [6B58]              <1> 	dw	int_16_exit		; 0C
    96 0000585F [6B58]              <1> 	dw	int_16_exit		; 0D
    97 00005861 [6B58]              <1> 	dw	int_16_exit		; 0E
    98 00005863 [6B58]              <1> 	dw	int_16_exit		; 0F
    99 00005865 [9122]              <1> 	dw	int_16_fn10		; get enhanced keystroke
   100 00005867 [BD22]              <1> 	dw	int_16_fn11		; check enhanced keystroke
   101 00005869 [CF58]              <1> 	dw	int_16_fn12		; get enhanced shift flags
   102                              <1> .num_func	equ	($-.dispatch)/2
   103                              <1> 
   104                              <1> int_16_exit:
   105 0000586B 1F                  <1> 	pop	ds
   106 0000586C 5B                  <1> 	pop	bx
   107 0000586D CF                  <1> 	iret
   108                              <1> 
   109                              <1> int_16_exitf:
   110 0000586E 1F                  <1> 	pop	ds
   111 0000586F 5B                  <1> 	pop	bx
   112 00005870 FB                  <1> 	sti
   113 00005871 CA0200              <1> 	retf	2
   114                              <1> 
   115                              <1> ;=========================================================================
   116                              <1> ; int_16_fn02 - get shift flags
   117                              <1> ; Input:
   118                              <1> ;	AH = 02h
   119                              <1> ; Output:
   120                              <1> ;	AL - shift flags
   121                              <1> ;            AL bits:
   122                              <1> ;		7 - Insert active
   123                              <1> ;		6 - Caps Lock active
   124                              <1> ;		5 - Num Lock active
   125                              <1> ;		4 - Scroll Lock active
   126                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
   127                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
   128                              <1> ;		1 - left shift key pressed
   129                              <1> ;		0 - right shift key pressed
   130                              <1> ;-------------------------------------------------------------------------
   131                              <1> int_16_fn02:
   132 00005874 A01700              <1> 	mov	al,byte [kbd_flags_1]
   133 00005877 EBF2                <1> 	jmp	int_16_exit
   134                              <1> 
   135                              <1> %ifdef AT_KEYBOARD
   136                              <1> 
   137                              <1> ;=========================================================================
   138                              <1> ; int_16_fn03 - set keyboard typematic rate
   139                              <1> ; Input:
   140                              <1> ;	AH = 03
   141                              <1> ;	AL - subfunction
   142                              <1> ;	     00 - set typematic rate to default
   143                              <1> ;	     01 - increase initial delay
   144                              <1> ;	     02 - slow typematic rate by 1/2
   145                              <1> ;	     04 - turn off typematic chars
   146                              <1> ;	     05 - set typematic rate/delay
   147                              <1> ;	BH - repeat delay (AL=5)
   148                              <1> ;		0 - 250ms	2 - 750ms
   149                              <1> ;		1 - 500ms	3 - 1000ms
   150                              <1> ;	BL - typematic rate, one of the following  (AL=5)
   151                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
   152                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
   153                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
   154                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
   155                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
   156                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
   157                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
   158                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
   159                              <1> ; Output:
   160                              <1> ;	none
   161                              <1> ;-------------------------------------------------------------------------
   162                              <1> int_16_fn03:
   163 00005879 3C05                <1> 	cmp	al,05
   164 0000587B 7527                <1> 	jne	.exit			; only AL = 5 implemented
   165 0000587D 53                  <1> 	push	bx
   166 0000587E 51                  <1> 	push	cx
   167 0000587F B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
   168 00005881 E8FEC3              <1> 	call	kbc_write_command
   169 00005884 80E703              <1> 	and	bh,3			; legal BH values from 0 to 3
   170 00005887 B105                <1> 	mov	cl,5
   171 00005889 D2E7                <1> 	shl	bh,cl
   172 0000588B 80E31F              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
   173 0000588E B0F3                <1> 	mov	al,dev_cmd_rate
   174 00005890 E8B1C3              <1> 	call	kbc_kb_send
   175 00005893 88F8                <1> 	mov	al,bh
   176 00005895 E8ACC3              <1> 	call	kbc_kb_send
   177 00005898 B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
   178 0000589A E8E5C3              <1> 	call	kbc_write_command
   179 0000589D B004                <1> 	mov	al,04h			; FIXME: Use dev_cmd_enable instead?
   180 0000589F E8A2C3              <1> 	call	kbc_kb_send
   181 000058A2 59                  <1> 	pop	cx
   182 000058A3 5B                  <1> 	pop	bx
   183                              <1> .exit:
   184 000058A4 EBC5                <1> 	jmp	int_16_exit
   185                              <1> 
   186                              <1> %endif ; AT_KEYBOARD
   187                              <1> 
   188                              <1> ;=========================================================================
   189                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
   190                              <1> ; Input:
   191                              <1> ;	AH = 05h
   192                              <1> ;	CH = BIOS scan code
   193                              <1> ;	CL = ACII character
   194                              <1> ; Output:
   195                              <1> ;	AL - status
   196                              <1> ;	     00h - success
   197                              <1> ;	     01h - keyboard buffer full
   198                              <1> ;-------------------------------------------------------------------------
   199                              <1> int_16_fn05:
   200 000058A6 56                  <1> 	push	si
   201 000058A7 B001                <1> 	mov	al,1			; assume no space
   202 000058A9 FA                  <1> 	cli				; critical section
   203 000058AA 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
   204 000058AE 89DE                <1> 	mov	si,bx
   205 000058B0 83C302              <1> 	add	bx,2
   206 000058B3 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   207 000058B7 7504                <1> 	jne	.1
   208 000058B9 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   209                              <1> .1:
   210 000058BD 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
   211 000058C1 7408                <1> 	je	.no_space		; no space in buffer
   212 000058C3 890C                <1> 	mov	word [si],cx
   213 000058C5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
   214 000058C9 B000                <1> 	mov	al,0			; stored successfully
   215                              <1> .no_space:
   216 000058CB FB                  <1> 	sti
   217 000058CC 5E                  <1> 	pop	si
   218 000058CD EB9C                <1> 	jmp	int_16_exit
   219                              <1> 
   220                              <1> ;=========================================================================
   221                              <1> ; int_16_fn12 - get extended shift flags
   222                              <1> ; Input:
   223                              <1> ;	AH = 12h
   224                              <1> ; Output:
   225                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
   226                              <1> ;	AH - shift flags 2
   227                              <1> ;            AH bits:
   228                              <1> ;		7 - SysRq key pressed
   229                              <1> ;		6 - Caps Lock pressed
   230                              <1> ;		5 - Num Lock pressed
   231                              <1> ;		4 - Scroll Lock pressed
   232                              <1> ;		3 - right Alt key pressed
   233                              <1> ;		2 - right Ctrl key pressed
   234                              <1> ;		1 - left Alt key pressed
   235                              <1> ;		0 - left Ctrl key pressed
   236                              <1> ;-------------------------------------------------------------------------
   237                              <1> int_16_fn12:
   238 000058CF 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
   239 000058D3 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
   240 000058D6 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
   241 000058D9 7403                <1> 	je	.1
   242 000058DB 80CC80              <1> 	or	ah,80h			; set final SysRq bit
   243                              <1> .1:
   244 000058DE 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
   245 000058E1 A09600              <1> 	mov	al,byte [kbd_flags_3]
   246 000058E4 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
   247 000058E6 08C4                <1> 	or	ah,al			; copy to AH
   248 000058E8 A01700              <1> 	mov	al,byte [kbd_flags_1]
   249 000058EB E97DFF              <1> 	jmp	int_16_exit
   250                              <1> 
   251                              <1> ;=========================================================================
   252                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
   253                              <1> ;-------------------------------------------------------------------------
   254 000058EE FF<rep 99h>         <1> 	setloc	0E987h			; INT 09 Entry Point
   254          ******************  <1>  warning: Inserting 153 bytes [-w+user]
   255                              <1> int_09:
   256 00005987 50                  <1> 	push	ax
   257 00005988 53                  <1> 	push	bx
   258 00005989 1E                  <1> 	push	ds
   259                              <1> 
   260 0000598A B84000              <1> 	mov	ax,biosdseg
   261 0000598D 8ED8                <1> 	mov	ds,ax
   262                              <1> 
   263                              <1> %ifdef AT_KEYBOARD
   264                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
   265                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
   266                              <1> 	call    kbc_write_command
   267                              <1> %endif
   268                              <1> %endif ; AT_KEYBOARD
   269 0000598F E460                <1> 	in	al,ppi_pa_reg		; get keyboard data / scancode
   270                              <1> %ifndef MACHINE_BOOK8088
   271 00005991 88C4                <1> 	mov	ah,al			; save it in AH
   272 00005993 E461                <1> 	in	al,ppi_pb_reg		; read PPI port B, control
   273 00005995 0C80                <1> 	or	al,10000000b		; set keyboard clear bit
   274 00005997 E661                <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
   275 00005999 247F                <1> 	and	al,01111111b		; unset keyboard clear bit
   276 0000599B E661                <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
   277 0000599D 88E0                <1> 	mov	al,ah			; restore AL / scancode
   278                              <1> %endif ; MACHINE_BOOK8088
   279 0000599F FB                  <1> 	sti
   280                              <1> %ifdef AT_KEYBOARD
   281 000059A0 B44F                <1> 	mov	ah,4Fh
   282 000059A2 F9                  <1> 	stc
   283 000059A3 CD15                <1> 	int	15h			; keyboard intercept
   284 000059A5 7203E9B101          <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
   285                              <1> %else ; AT_KEYBOARD
   286                              <1> 	cmp	al,0FFh			; check for overrun
   287                              <1> 	jz	keyboard_int_exit
   288                              <1> %endif ; AT_KEYBOARD
   289                              <1> ; check for KBC response codes
   290                              <1> 
   291 000059AA 3CEE                <1> 	cmp	al,0EEh			; echo response?
   292 000059AC 7503E9AA01          <1> 	je      keyboard_int_exit
   293 000059B1 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
   294 000059B3 7508                <1> 	jne     .2
   295 000059B5 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
   296 000059BA E99E01              <1> 	jmp	keyboard_int_exit
   297                              <1> .2:
   298 000059BD 3CFE                <1> 	cmp	al,0FEh			; resend command?
   299 000059BF 7508                <1> 	jne	.3
   300 000059C1 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
   301 000059C6 E99201              <1> 	jmp	keyboard_int_exit
   302                              <1> 
   303                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
   304                              <1> 
   305                              <1> .3:
   306                              <1> 
   307                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
   308                              <1> 
   309 000059C9 3CE0                <1> 	cmp	al,0E0h
   310 000059CB 750D                <1> 	jne	.4
   311 000059CD 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
   312 000059D2 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
   313 000059D7 E98101              <1> 	jmp	keyboard_int_exit
   314                              <1> .4:
   315 000059DA 3CE1                <1> 	cmp	al,0E1h
   316 000059DC 750D                <1> 	jne	.5
   317 000059DE 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
   318 000059E3 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
   319 000059E8 E97001              <1> 	jmp	keyboard_int_exit
   320                              <1> 
   321                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
   322                              <1> 
   323                              <1> .5:
   324 000059EB 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
   325 000059EF 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
   326 000059F2 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
   327 000059F5 750F                <1> 	jne	.6
   328 000059F7 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
   329 000059F9 750B                <1> 	jne	.check_turbo_off
   330 000059FB C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
   331 00005A01 EA[6650]00F0        <1> 	jmp	0F000h:warm_start	; reboot
   332                              <1> 
   333                              <1> ; handle turbo mode switch combinations
   334                              <1> .check_turbo_off:
   335                              <1> 
   336                              <1> %ifdef TURBO_MODE
   337                              <1> 	cmp	al,4Ah			; gray - scancode
   338                              <1> 	jne	.check_turbo_mid
   339                              <1> 
   340                              <1> 	call	set_cpu_clk_4_77mhz
   341                              <1> 	jmp	keyboard_int_exit
   342                              <1> 
   343                              <1> .check_turbo_mid:
   344                              <1> %ifdef MACHINE_FE2010A
   345                              <1> 	cmp	al,37h			; * scancode
   346                              <1> 	jne	.check_turbo_hi
   347                              <1> 
   348                              <1> 	call	set_cpu_clk_7_16mhz
   349                              <1> 	jmp	keyboard_int_exit
   350                              <1> %endif ; MACHINE_FE2010A
   351                              <1> 
   352                              <1> .check_turbo_hi:
   353                              <1> 	cmp	al,4Eh			; gray + scancode
   354                              <1> 	jne	.6
   355                              <1> 
   356                              <1> %ifdef MACHINE_FE2010A
   357                              <1> 	call	set_cpu_clk_9_55mhz
   358                              <1> %else ; MACHINE_FE2010A
   359                              <1> 	call	set_cpu_clk_turbo
   360                              <1> %endif ; MACHINE_FE2010A
   361                              <1> 	jmp	keyboard_int_exit
   362                              <1> 
   363                              <1> %endif ; TURBO_MODE
   364                              <1> 
   365                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
   366                              <1> ; in the keyboard flags variables.
   367                              <1> 
   368                              <1> .6:
   369 00005A06 3C52                <1> 	cmp	al,kbd_ins_code
   370 00005A08 7508                <1> 	jne	.7
   371 00005A0A 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
   372 00005A0F E90A01              <1> 	jmp	.translate	   	; pass on INS key
   373                              <1> 
   374                              <1> .7:
   375 00005A12 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
   376 00005A14 750D                <1> 	jne     .8
   377 00005A16 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
   378 00005A1B 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
   379 00005A20 E93301              <1> 	jmp     .no_buffer
   380                              <1> 
   381                              <1> ; handle the left and right Shift keys
   382                              <1> 
   383                              <1> .8:
   384 00005A23 3C2A                <1> 	cmp	al,kbd_lshift_code
   385 00005A25 7508                <1> 	jne	.9
   386 00005A27 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
   387 00005A2C E92701              <1> 	jmp	.no_buffer
   388                              <1> .9:
   389 00005A2F 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
   390 00005A31 7508                <1> 	jne     .10
   391 00005A33 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
   392 00005A38 E91B01              <1> 	jmp     .no_buffer
   393                              <1> .10:
   394 00005A3B 3C36                <1> 	cmp	al,kbd_rshift_code
   395 00005A3D 7508                <1> 	jne	.11
   396 00005A3F 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
   397 00005A44 E90F01              <1> 	jmp	.no_buffer
   398                              <1> .11:
   399 00005A47 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
   400 00005A49 7508                <1> 	jne     .12
   401 00005A4B 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
   402 00005A50 E90301              <1> 	jmp	.no_buffer
   403                              <1> 
   404                              <1> ; handle the Alt key
   405                              <1> 
   406                              <1> .12:
   407 00005A53 3C38                <1> 	cmp	al,kbd_alt_code
   408 00005A55 7508                <1> 	jne	.13
   409 00005A57 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
   410 00005A5C E9F700              <1> 	jmp	.no_buffer
   411                              <1> .13:
   412 00005A5F 3CB8                <1> 	cmp	al,kbd_alt_code+80h
   413 00005A61 751C                <1> 	jne	.14
   414 00005A63 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
   415 00005A68 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
   416 00005A6D 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
   417 00005A72 A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
   418 00005A75 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
   419 00005A7A B400                <1> 	mov	ah,0
   420 00005A7C E9B600              <1> 	jmp	.put_in_buffer
   421                              <1> 
   422                              <1> ; handle the Ctrl key
   423                              <1> 
   424                              <1> .14:
   425 00005A7F 3C1D                <1> 	cmp	al,kbd_ctrl_code
   426 00005A81 7508                <1> 	jne	.15
   427 00005A83 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
   428 00005A88 E9CB00              <1> 	jmp	.no_buffer
   429                              <1> .15:
   430 00005A8B 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
   431 00005A8D 7508                <1> 	jne	.16
   432 00005A8F 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
   433 00005A94 E9BF00              <1> 	jmp	.no_buffer
   434                              <1> 
   435                              <1> ; handle the Caps Lock key
   436                              <1> 
   437                              <1> .16:
   438 00005A97 3C3A                <1> 	cmp	al,kbd_caps_code
   439 00005A99 750D                <1> 	jne	.17
   440 00005A9B 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
   441 00005AA0 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
   442 00005AA5 E9AE00              <1> 	jmp	.no_buffer
   443                              <1> .17:
   444 00005AA8 3CBA                <1> 	cmp	al,kbd_caps_code+80h
   445 00005AAA 7508                <1> 	jne	.18
   446 00005AAC 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
   447 00005AB1 E9D000              <1> 	jmp	set_LEDs
   448                              <1> 
   449                              <1> ; check if print screen key was pressed
   450                              <1> 
   451                              <1> .18:
   452 00005AB4 3C37                <1> 	cmp	al,kbd_prtsc_code
   453 00005AB6 750A                <1> 	jne	.test_scroll_loc
   454 00005AB8 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
   455 00005ABD 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
   456 00005ABF E9B500              <1> 	jmp	print_screen
   457                              <1> 
   458                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
   459                              <1> 
   460                              <1> .test_scroll_loc:
   461 00005AC2 3C46                <1> 	cmp	al,kbd_scroll_code
   462 00005AC4 7528                <1> 	jne	.19
   463 00005AC6 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
   464 00005ACB 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
   465                              <1> 
   466                              <1> ; handle Ctrl-Break
   467                              <1> 
   468 00005ACD 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
   469 00005AD1 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   470 00005AD5 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
   471 00005AD9 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
   472 00005ADE CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
   473 00005AE0 EB74                <1> 	jmp	.no_buffer
   474                              <1> 
   475                              <1> ; handle Scroll Lock
   476                              <1> 
   477                              <1> .scroll_lock:
   478 00005AE2 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
   479 00005AE7 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
   480 00005AEC EB68                <1> 	jmp	.no_buffer
   481                              <1> .19:
   482 00005AEE 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
   483 00005AF0 7508                <1> 	jne	.20
   484 00005AF2 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
   485 00005AF7 E98A00              <1> 	jmp	set_LEDs
   486                              <1> 
   487                              <1> ; handle the Num Lock
   488                              <1> 
   489                              <1> .20:
   490 00005AFA 3C45                <1> 	cmp	al,kbd_num_code
   491 00005AFC 7513                <1> 	jne	.21
   492 00005AFE F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
   493 00005B03 755E                <1> 	jnz	pause			; jump if pause
   494 00005B05 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
   495 00005B0A 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
   496 00005B0F EB45                <1> 	jmp	.no_buffer
   497                              <1> .21:
   498 00005B11 3CC5                <1> 	cmp	al,kbd_num_code+80h
   499 00005B13 7507                <1> 	jne	.translate
   500 00005B15 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
   501 00005B1A EB68                <1> 	jmp	set_LEDs
   502                              <1> 
   503                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
   504                              <1> 
   505                              <1> .translate:
   506 00005B1C F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
   507 00005B21 7407                <1> 	jz	.check_release
   508 00005B23 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
   509 00005B28 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
   510                              <1> .check_release:
   511 00005B2A A880                <1> 	test	al,80h			; ignore key release and KBC responses
   512 00005B2C 7528                <1> 	jnz	.no_buffer
   513                              <1> 
   514 00005B2E E8FAC5              <1> 	call	scan_xlat
   515 00005B31 85C0                <1> 	test	ax,ax		 	; check for bad code
   516 00005B33 7421                <1> 	je	.no_buffer
   517                              <1> 
   518                              <1> .put_in_buffer:
   519 00005B35 56                  <1> 	push	si			; FIXME: Use Int 16h/05 instead?
   520 00005B36 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
   521 00005B3A 89DE                <1> 	mov	si,bx
   522 00005B3C 83C302              <1> 	add	bx,2
   523 00005B3F 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   524 00005B43 7504                <1> 	jne	.1
   525 00005B45 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   526                              <1> .1:
   527 00005B49 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
   528 00005B4D 7406                <1> 	je	.no_space		; no space in buffer
   529 00005B4F 8904                <1> 	mov	word [si],ax
   530 00005B51 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
   531                              <1> 
   532                              <1> .no_space:
   533 00005B55 5E                  <1> 	pop	si
   534                              <1> 
   535                              <1> .no_buffer:
   536 00005B56 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
   537                              <1> 
   538                              <1> keyboard_int_exit:
   539                              <1> %ifdef AT_KEYBOARD
   540                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
   541                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
   542                              <1> 	call	kbc_write_command
   543                              <1> %endif
   544                              <1> %endif ; AT_KEYBOARD
   545 00005B5B B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
   546 00005B5D E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
   547                              <1> 
   548                              <1> keyboard_int_exit1:
   549 00005B5F 1F                  <1> 	pop	ds
   550 00005B60 5B                  <1> 	pop	bx
   551 00005B61 58                  <1> 	pop	ax
   552 00005B62 CF                  <1> 	iret
   553                              <1> 
   554                              <1> pause:
   555 00005B63 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
   556 00005B68 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
   557                              <1> 
   558 00005B6A B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
   559 00005B6C E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
   560                              <1> 
   561                              <1> .pause_loop:
   562 00005B6E F606180008          <1> 	test	byte [kbd_flags_2],08h
   563 00005B73 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
   564 00005B75 EBE8                <1> 	jmp	keyboard_int_exit1
   565                              <1> 
   566                              <1> print_screen:
   567 00005B77 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
   568 00005B79 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
   569 00005B7B CD05                <1> 	int	5h			; INT 5 - print screen
   570 00005B7D 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
   571 00005B82 EBDB                <1> 	jmp	keyboard_int_exit1
   572                              <1> 
   573                              <1> ;=========================================================================
   574                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
   575                              <1> ; 	     variable and update LEDs on the keyboard
   576                              <1> ;-------------------------------------------------------------------------
   577                              <1> set_LEDs:
   578 00005B84 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
   579 00005B86 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
   580                              <1> 
   581 00005B88 A01700              <1> 	mov	al,byte [kbd_flags_1]
   582 00005B8B D0E8                <1> 	shr	al,1
   583 00005B8D D0E8                <1> 	shr	al,1
   584 00005B8F D0E8                <1> 	shr	al,1
   585 00005B91 D0E8                <1> 	shr	al,1
   586 00005B93 2407                <1> 	and	al,111b
   587 00005B95 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
   588 00005B9A 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
   589                              <1> %ifdef AT_KEYBOARD
   590                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
   591                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
   592                              <1> 	call	kbc_write_command
   593                              <1> %endif
   594 00005B9E 88C4                <1> 	mov	ah,al			; save LED bits
   595                              <1> 
   596 00005BA0 B0AD                <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
   597 00005BA2 E8DDC0              <1> 	call	kbc_write_command
   598                              <1> 
   599 00005BA5 B0ED                <1> 	mov	al,kbd_cmd_leds		; set LEDs command
   600 00005BA7 E89AC0              <1> 	call	kbc_kb_send		; send the command to the keyboard
   601 00005BAA 88E0                <1> 	mov	al,ah			; get parameter byte
   602 00005BAC E895C0              <1> 	call	kbc_kb_send		; send parameter to the keyboard
   603                              <1> 
   604 00005BAF B0AE                <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
   605 00005BB1 E8CEC0              <1> 	call	kbc_write_command
   606 00005BB4 B0F4                <1> 	mov	al,dev_cmd_enable	; restart keyboard scanning
   607 00005BB6 E88BC0              <1> 	call	kbc_kb_send
   608                              <1> %endif ; AT_KEYBOARD
   609 00005BB9 EBA4                <1> 	jmp	keyboard_int_exit1
   610                              <1> 
   611                              <1> ;=========================================================================
   612                              <1> ; kbd_buffer_init - Setup keyboard buffer
   613                              <1> ;-------------------------------------------------------------------------
   614                              <1> kbd_buffer_init:
   615 00005BBB B81E00              <1> 	mov	ax,kbd_buffer		; setup keyboard buffer
   616 00005BBE A38000              <1> 	mov	word [kbd_buffer_start],ax
   617 00005BC1 A31A00              <1> 	mov	word [kbd_buffer_head],ax
   618 00005BC4 A31C00              <1> 	mov	word [kbd_buffer_tail],ax
   619 00005BC7 83C020              <1> 	add	ax,20h			; size of the keyboard buffer
   620 00005BCA A38200              <1> 	mov	word [kbd_buffer_end],ax
   621 00005BCD 31C0                <1> 	xor	ax,ax			; clear keyboard flags
   622 00005BCF A31700              <1> 	mov	word [kbd_flags_1],ax
   623 00005BD2 A31800              <1> 	mov	word [kbd_flags_2],ax
   624 00005BD5 A39600              <1> 	mov	word [kbd_flags_3],ax
   625 00005BD8 A39700              <1> 	mov	word [kbd_flags_4],ax
   626 00005BDB C3                  <1> 	ret
  1411                                  %include	"floppy2.inc"		; INT 13
     1                              <1> ;=========================================================================
     2                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
     3                              <1> ;	INT 13h, function AH=02h
     4                              <1> ;	INT 13h, function AH=03h
     5                              <1> ;	INT 13h, function AH=04h
     6                              <1> ;	INT 13h, function AH=05h
     7                              <1> ;	- see floppy1.inc for other INT 13h functions
     8                              <1> ;-------------------------------------------------------------------------
     9                              <1> ;
    10                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    11                              <1> ;
    12                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                              <1> ;
    15                              <1> ; This program is free software: you can redistribute it and/or modify
    16                              <1> ; it under the terms of the GNU General Public License as published by
    17                              <1> ; the Free Software Foundation, either version 3 of the License, or
    18                              <1> ; (at your option) any later version.
    19                              <1> ;
    20                              <1> ; This program is distributed in the hope that it will be useful,
    21                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                              <1> ; GNU General Public License for more details.
    24                              <1> ;
    25                              <1> ; You should have received a copy of the GNU General Public License
    26                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                              <1> ;
    28                              <1> ;=========================================================================
    29                              <1> 
    30                              <1> ;-------------------------------------------------------------------------
    31                              <1> ; offsets for registers on stack
    32                              <1> int_13_bp	equ	0
    33                              <1> int_13_ds	equ	int_13_bp+2
    34                              <1> int_13_di	equ	int_13_ds+2
    35                              <1> int_13_si	equ	int_13_di+2
    36                              <1> int_13_dx	equ	int_13_si+2
    37                              <1> int_13_dl	equ	int_13_dx
    38                              <1> int_13_dh	equ	int_13_dx+1
    39                              <1> int_13_cx	equ	int_13_dx+2
    40                              <1> int_13_cl	equ	int_13_cx
    41                              <1> int_13_ch	equ	int_13_cx+1
    42                              <1> int_13_bx	equ	int_13_cx+2
    43                              <1> int_13_bl	equ	int_13_bx
    44                              <1> int_13_bh	equ	int_13_bx+1
    45                              <1> int_13_ax	equ	int_13_bx+2
    46                              <1> int_13_al	equ	int_13_ax
    47                              <1> int_13_ah	equ	int_13_ax+1
    48                              <1> int_13_ip	equ	int_13_ax+2
    49                              <1> int_13_cs	equ	int_13_ip+2
    50                              <1> int_13_flags	equ	int_13_cs+2
    51                              <1> int_13_flags_l	equ	int_13_flags
    52                              <1> 
    53                              <1> ;=========================================================================
    54                              <1> ; int_13 - BIOS floppy disk services
    55                              <1> ; Input:
    56                              <1> ;	AH = function
    57                              <1> ;		00h - Reset disk system
    58                              <1> ;		01h - Get status of last operation
    59                              <1> ;		02h - Read disk sectors
    60                              <1> ;		03h - Write disk sectors
    61                              <1> ;		04h - Verify disk sectors
    62                              <1> ;		05h - Format track
    63                              <1> ;		08h - Get drive parameters
    64                              <1> ;		15h - Get disk type
    65                              <1> ;		16h - Detect disk change
    66                              <1> ;		17h - Set disk type for format
    67                              <1> ;		18h - Set media type for format
    68                              <1> ; Output:
    69                              <1> ;	- depends on function
    70                              <1> ;	- for most functions:
    71                              <1> ;		CF clear if successful
    72                              <1> ;			AH = 00h - successful completion
    73                              <1> ;		CF set on error
    74                              <1> ;			AH = error code
    75                              <1> ;-------------------------------------------------------------------------
    76 00005BDC FF<rep 7Dh>         <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
    76          ******************  <1>  warning: Inserting 125 bytes [-w+user]
    77                              <1> int_13:
    78 00005C59 FB                  <1> 	sti
    79 00005C5A 50                  <1> 	push	ax
    80 00005C5B 53                  <1> 	push	bx
    81 00005C5C 51                  <1> 	push	cx
    82 00005C5D 52                  <1> 	push	dx
    83 00005C5E 56                  <1> 	push	si
    84 00005C5F 57                  <1> 	push	di
    85 00005C60 1E                  <1> 	push	ds
    86 00005C61 55                  <1> 	push	bp
    87 00005C62 89E5                <1> 	mov	bp,sp
    88                              <1> 
    89 00005C64 BB4000              <1> 	mov	bx,biosdseg
    90 00005C67 8EDB                <1> 	mov	ds,bx
    91                              <1> 
    92                              <1> ; fn01 doesn't need drive type
    93                              <1> 
    94 00005C69 80FC01              <1> 	cmp	ah,01h
    95 00005C6C 7503E98EB7          <1> 	je	int_13_fn01		; Get status of last operation
    96                              <1> 
    97                              <1> 
    98 00005C71 80FA01              <1> 	cmp	dl,1
    99 00005C74 7703                <1> 	ja	.try_fn08		; invalid drive number, but try fn08
   100                              <1> 
   101                              <1> ; get drive type
   102                              <1> 
   103 00005C76 E8EABD              <1> 	call	get_drive_type		; AL = drive type
   104                              <1> 
   105                              <1> ; fn08 needs physical drive information, but can accept drive numbers 0 - 7Fh
   106                              <1> 
   107                              <1> .try_fn08:
   108 00005C79 80FC08              <1> 	cmp	ah,08h
   109 00005C7C 7503E98AB7          <1> 	je	int_13_fn08		; Get drive parameters
   110                              <1> 
   111 00005C81 80FA01              <1> 	cmp	dl,1
   112 00005C84 7743                <1> 	ja	.invalid_parameters	; invalid drive number (> 1)
   113                              <1> 
   114                              <1> ; fn15 accepts not existing drive numbers (and returns status 00h for them)
   115                              <1> 
   116 00005C86 80FC15              <1> 	cmp	ah,15h
   117 00005C89 7503E929B8          <1> 	je	int_13_fn15		; Get disk type
   118                              <1> 
   119                              <1> ; all other functions require an existing drive number
   120                              <1> 
   121 00005C8E 3C00                <1> 	cmp	al,type_none
   122 00005C90 7437                <1> 	je	.invalid_parameters	; drive not present or not configured
   123                              <1> 
   124                              <1> ; dispatch
   125                              <1> 
   126 00005C92 80FC00              <1> 	cmp	ah,00h
   127 00005C95 7503E910B7          <1> 	je	int_13_fn00		; Reset disk system
   128 00005C9A 80FC02              <1> 	cmp	ah,02h
   129 00005C9D 746B                <1> 	je	int_13_fn02		; Read disk sectors
   130 00005C9F 80FC03              <1> 	cmp	ah,03h
   131 00005CA2 7466                <1> 	je	int_13_fn03		; Write disk sectors
   132 00005CA4 80FC04              <1> 	cmp	ah,04h
   133 00005CA7 7461                <1> 	je	int_13_fn04		; Verify disk sectors
   134 00005CA9 80FC05              <1> 	cmp	ah,05h
   135 00005CAC 7503E9EB01          <1> 	je	int_13_fn05		; Format track
   136 00005CB1 80FC16              <1> 	cmp	ah,16h
   137 00005CB4 7503E919B8          <1> 	je	int_13_fn16		; Detect disk change
   138 00005CB9 80FC17              <1> 	cmp	ah,17h
   139 00005CBC 7503E955B8          <1> 	je	int_13_fn17		; Set disk type for format
   140 00005CC1 80FC18              <1> 	cmp	ah,18h
   141 00005CC4 7503E9A8B8          <1> 	je	int_13_fn18		; Set media type for format
   142                              <1> 
   143                              <1> .invalid_parameters:
   144 00005CC9 B401                <1> 	mov	ah,fdc_e_invalid
   145 00005CCB 88264100            <1> 	mov	byte [fdc_last_error],ah
   146 00005CCF F9                  <1> 	stc				; error condition
   147 00005CD0 EB1F                <1> 	jmp	int_13_exit
   148                              <1> 
   149                              <1> ;-------------------------------------------------------------------------
   150                              <1> ; int_13_upd_exit - Update diskette change flag and exit
   151                              <1> ; FIXME: what uses this (fdc_info) flag?
   152                              <1> 
   153                              <1> int_13_upd_exit:
   154 00005CD2 9C                  <1> 	pushf
   155 00005CD3 50                  <1> 	push	ax
   156 00005CD4 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; AL = drive number
   157 00005CD7 3C01                <1> 	cmp	al,1
   158 00005CD9 7714                <1> 	ja	.no_update		; skip if drive number > 1
   159 00005CDB E825BD              <1> 	call	get_media_state		; BL = drive media state
   160 00005CDE F6C310              <1> 	test	bl,fdc_m_established
   161 00005CE1 740C                <1> 	jz	.no_update		; skip if media type not established
   162 00005CE3 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
   163 00005CE5 08C0                <1> 	or	al,al
   164 00005CE7 7402                <1> 	jz	.drive_0
   165 00005CE9 B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
   166                              <1> 
   167                              <1> .drive_0:
   168 00005CEB 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
   169                              <1> 
   170                              <1> .no_update:
   171 00005CEF 58                  <1> 	pop	ax
   172 00005CF0 9D                  <1> 	popf
   173                              <1> 
   174                              <1> int_13_exit:
   175 00005CF1 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
   176 00005CF4 B80102              <1> 	mov	ax,201h			; set IF and CF
   177 00005CF7 7205                <1> 	jc	.set_error		; there is an error
   178 00005CF9 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
   179 00005CFD 48                  <1> 	dec	ax			; clear CF in AX too
   180                              <1> 
   181                              <1> .set_error:
   182 00005CFE 094614              <1> 	or	word [bp+int_13_flags],ax
   183 00005D01 5D                  <1> 	pop	bp
   184 00005D02 1F                  <1> 	pop	ds
   185 00005D03 5F                  <1> 	pop	di
   186 00005D04 5E                  <1> 	pop	si
   187 00005D05 5A                  <1> 	pop	dx
   188 00005D06 59                  <1> 	pop	cx
   189 00005D07 5B                  <1> 	pop	bx
   190 00005D08 58                  <1> 	pop	ax
   191 00005D09 CF                  <1> 	iret
   192                              <1> 
   193                              <1> ;=========================================================================
   194                              <1> ; int_13_fn02 - Read disk sectors
   195                              <1> ; int_13_fn03 - Write disk sectors
   196                              <1> ; int_13_fn04 - Verify disk sectors
   197                              <1> ; Input:
   198                              <1> ;	AH = function
   199                              <1> ;		02h - read
   200                              <1> ;		03h - write
   201                              <1> ;		04h - verify
   202                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
   203                              <1> ;	CH = cylinder number
   204                              <1> ;	CL = sector number
   205                              <1> ;	DH = head number (0 or 1)
   206                              <1> ;	DL = drive number (0 or 1)
   207                              <1> ;	ES:BX -> data buffer
   208                              <1> ; Output:
   209                              <1> ;	CF clear if successful
   210                              <1> ;		AH = 00h - successful completion
   211                              <1> ;		AL = number of sectors transferred or verified
   212                              <1> ;	CF set on error
   213                              <1> ;		AH = error code
   214                              <1> ;-------------------------------------------------------------------------
   215                              <1> int_13_fn02:
   216                              <1> int_13_fn03:
   217                              <1> int_13_fn04:
   218 00005D0A 807E0E00            <1> 	cmp	byte [bp+int_13_al],0	; number of sectors must be non zero
   219 00005D0E 7503E98401          <1> 	je	.invalid_request
   220 00005D13 50                  <1>   push ax ; al has drive type at entry!
   221 00005D14 B0EE                <1> 	mov	al, 0xEE		; Send Read disk command and Cylinder, Sector, Head, Sector Count
   222 00005D16 E680                <1> 	out	post_reg,al
   223 00005D18 88E8                <1>   mov al, ch
   224 00005D1A E680                <1> 	out	post_reg,al
   225 00005D1C 88C8                <1>   mov al, cl
   226 00005D1E E680                <1> 	out	post_reg,al
   227 00005D20 88F0                <1>   mov al, dh
   228 00005D22 E680                <1> 	out	post_reg,al
   229 00005D24 8A460E              <1>   mov al, byte [bp+int_13_al] ; restore al sector count
   230 00005D27 E680                <1> 	out	post_reg,al
   231 00005D29 58                  <1>   pop ax  ; restore drive type to al
   232                              <1> 
   233 00005D2A E8D6BC              <1> 	call	get_media_state		; BL = media state
   234                              <1> 
   235 00005D2D 80FC03              <1> 	cmp	ah,03h			; write function
   236 00005D30 7407                <1> 	je	.set_write
   237 00005D32 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
   238 00005D37 EB05                <1> 	jmp	.motor_on
   239                              <1> 
   240                              <1> .set_write:
   241 00005D39 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
   242                              <1> 
   243                              <1> .motor_on:
   244 00005D3E E89CB9              <1> 	call	fdc_motor_on
   245                              <1> 
   246 00005D41 3C01                <1> 	cmp	al,type_360
   247 00005D43 7420                <1> 	je	.set_media_360		; set media type for 360K drive
   248 00005D45 3C03                <1> 	cmp	al,type_720
   249 00005D47 7420                <1> 	je	.set_media_720		; set media type for 720K drive
   250                              <1> 
   251 00005D49 E836BA              <1> 	call	fdc_disk_change
   252 00005D4C 80FC06              <1> 	cmp	ah,fdc_e_changed
   253 00005D4F 7425                <1> 	je	.establish_media	; disk changed - establish media
   254 00005D51 80FC00              <1> 	cmp	ah,fdc_e_success
   255 00005D54 7403E93101          <1> 	jne	.error_end_io		; fdc_disk_change failed
   256                              <1> 
   257 00005D59 F6C310              <1> 	test	bl,fdc_m_established
   258 00005D5C 7418                <1> 	jz	.establish_media	; jump if media type is not established
   259                              <1> 
   260 00005D5E 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
   261 00005D60 E878BC              <1> 	call	fdc_set_rate		; select transfer rate
   262 00005D63 EB19                <1> 	jmp	.fdc_send_specify
   263                              <1> 
   264                              <1> ; 360K and 720K drives don't support change line, and only support
   265                              <1> ; one media type - set it here
   266                              <1> 
   267                              <1> .set_media_360:
   268 00005D65 B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
   269 00005D67 EB02                <1> 	jmp	.set_media
   270                              <1> 
   271                              <1> .set_media_720:
   272 00005D69 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
   273                              <1> 
   274                              <1> .set_media:
   275 00005D6B E89FBC              <1> 	call	set_media_state		; save media state (AL) to the data area
   276 00005D6E E86ABC              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
   277 00005D71 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
   278 00005D74 EB08                <1> 	jmp	.fdc_send_specify
   279                              <1> 
   280                              <1> .establish_media:
   281 00005D76 E897BB              <1> 	call	fdc_detect_media	; detect media type
   282 00005D79 7303E90C01          <1> 	jc	.error_end_io
   283                              <1> 	
   284                              <1> .fdc_send_specify:
   285 00005D7E B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
   286                              <1> 					; 0BFh - specify byte 0 for 1.44M
   287 00005D81 80FB17              <1> 	cmp	bl,fdc_m_1440		; 1.44M?
   288 00005D84 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
   289 00005D86 B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
   290 00005D88 80FBD7              <1> 	cmp	bl,fdc_m_2880		; 2.88M?
   291 00005D8B 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
   292 00005D8D B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
   293                              <1> 
   294                              <1> .fdc_send_specify_cmd:
   295 00005D8F BE0300              <1> 	mov	si,0x03			; specify byte 1 updated to 03 to disable DMA, values above not used!
   296 00005D92 B103                <1> 	mov	cl,3			; 3 bytes command
   297 00005D94 E840BA              <1> 	call	fdc_send_cmd
   298 00005D97 7303E9EE00          <1> 	jc	.error_end_io		; jump if failed to send command
   299 00005D9C 1E                  <1> 	push	ds
   300 00005D9D 31F6                <1> 	xor	si,si
   301 00005D9F 8EDE                <1> 	mov	ds,si
   302 00005DA1 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   303 00005DA5 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
   304 00005DA8 B400                <1> 	mov	ah,00h
   305 00005DAA 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
   306 00005DAC 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
   307 00005DAF FEC9                <1> 	dec	cl			; minus 1 - last sector to access
   308 00005DB1 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
   309 00005DB4 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
   310 00005DB6 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
   311                              <1> 
   312                              <1> .calc_dma_count:
   313 00005DB9 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
   314 00005DBC 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
   315 00005DBF D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
   316 00005DC1 1F                  <1> 	pop	ds
   317 00005DC2 48                  <1> 	dec	ax			; minus one byte
   318 00005DC3 89C1                <1> 	mov	cx,ax			; ...count for DMA
   319                              <1> 
   320                              <1> ;	AH = function
   321                              <1> ;		02h - read
   322                              <1> ;		03h - write
   323                              <1> ;		04h - verify
   324                              <1> ; Note Read Floppy disk via I/O requires DMA Write to RAM!
   325 00005DC5 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
   326 00005DC8 B046                <1> 	mov	al,46h			; DMA mode byte for read, channel 2 - Actually 01 Single Mode 00  Inc Auto Disable 01 Write 10 Channel 2
   327 00005DCA 80FC02              <1> 	cmp	ah,02h			; read function?
   328 00005DCD 7409                <1> 	je	.configure_dma		; jump if read function
   329 00005DCF B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2 - Actually 01 Single Mode 00  Inc Auto Disable 10 Read 10 Channel 2
   330 00005DD1 80FC03              <1> 	cmp	ah,03h			; write function?
   331 00005DD4 7402                <1> 	je	.configure_dma		; jump if write function
   332 00005DD6 B042                <1> 	mov	al,42h			; DMA mode byte for verify, channel 2 - Actually 01 Single Mode 00  Inc Auto Disable 00 Verify 10 Channel 2
   333                              <1> 
   334                              <1> .configure_dma:
   335                              <1> 	;call	fdc_configure_dma   ; Disable DMA for BBPC
   336 00005DD8 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
   337 00005DDB 7303E9AA00          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
   338                              <1> 
   339 00005DE0 E842B8              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
   340 00005DE3 7303E99300          <1> 	jc	.error_fdc_get_result	; jump if seek failed
   341                              <1> 
   342 00005DE8 B0D6                <1> 	mov	al, 0xD6		; Returned from Seek
   343 00005DEA E680                <1> 	out	post_reg,al
   344                              <1> 
   345 00005DEC 1E                  <1> 	push	ds
   346 00005DED 31F6                <1> 	xor	si,si
   347 00005DEF 8EDE                <1> 	mov	ds,si
   348 00005DF1 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   349 00005DF5 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
   350 00005DF8 88C8                <1> 	mov	al,cl			; AL = first sector number
   351 00005DFA 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
   352 00005DFC 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
   353 00005DFF 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
   354 00005E02 1F                  <1> 	pop	ds
   355                              <1> 
   356 00005E03 53                  <1> 	push	bx
   357 00005E04 E8FCBB              <1> 	call	get_media_state
   358 00005E07 88DA                <1> 	mov	dl,bl			; DL = drive media state
   359 00005E09 5B                  <1> 	pop	bx
   360 00005E0A B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
   361 00005E0C 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
   362 00005E0F 7413                <1> 	je	.gap_set		; jump if 1.44M media
   363 00005E11 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
   364 00005E14 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
   365 00005E16 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
   366 00005E19 7409                <1> 	je	.gap_set		; jump if 2.88M media
   367 00005E1B B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
   368 00005E1D 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
   369 00005E20 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
   370 00005E22 B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
   371                              <1> 	
   372                              <1> .gap_set:
   373 00005E24 B0D7                <1> 	mov	al, 0xD7		; About to send command
   374 00005E26 E680                <1> 	out	post_reg,al
   375                              <1> 
   376 00005E28 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; restore DH
   377 00005E2B 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
   378 00005E2E 88F4                <1> 	mov	ah,dh			; head
   379                              <1> 					; replace with mov ah,byte[bp+int_13_dh]
   380 00005E30 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
   381 00005E32 D0E4                <1> 	shl	ah,1
   382 00005E34 D0E4                <1> 	shl	ah,1
   383 00005E36 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
   384                              <1> ;	mov	al,0E6h			; FDC Read command  D7-MT D6-MF D5-SK D4-0 MultiTrack MFM Skip deleted
   385 00005E39 B046                <1> 	mov	al,046h			; FDC Read command  D7-MT=0 D6-MF=1 D5-SK=0 D4-0 No MultiTrack, MFM No Skip deleted like PCJr
   386 00005E3B 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
   387 00005E3F 7502                <1> 	jne	.send_command		; jump if not write 
   388                              <1> ;	mov	al,0C5h			; FDC Write command D7-MT D6-MF D5-0 D4-0 MultiTrack MFM 
   389 00005E41 B045                <1> 	mov	al,045h			; FDC Write command D7-MT=0 D6-MF D5-0 D4-0 No MultiTrack MFM for Non DMA
   390                              <1> 
   391                              <1> 
   392                              <1> .send_command:
   393                              <1> ;	Since the DMA controller is not stopping the FDC via TC/EOP
   394                              <1> ;	Then we need to set the End of Track EOT to the last sector requested
   395                              <1> ;	By default this would be 0x12 (18 dec) for 1.44MB drives
   396                              <1> ;	We then have to handle the expected EOT error later
   397                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
   398                              <1> ;	CL = sector number
   399                              <1> ;   BL is Sectors Per Track for EOT Parameter
   400                              <1> ;   This needs to be sector + number sectors - 1 as per PCJr for Non DMA Operation
   401 00005E43 88CB                <1> 	mov bl, cl          ; cl was copy of first sector No above before saving in di
   402 00005E45 025E0E              <1> 	add bl, byte [bp+int_13_al] ; Add number of sectors requested
   403 00005E48 FECB                <1> 	dec bl              ; Subtract 1 for example request boot sector 1 length 1 results in EOT of 1
   404                              <1> 	
   405 00005E4A B109                <1> 	mov	cl,9			; 9 bytes command
   406 00005E4C 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
   407 00005E51 E883B9              <1> 	call	fdc_send_cmd
   408 00005E54 7225                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
   409                              <1> 
   410                              <1> 	; The largest changes for BBPC to disable DMA are here
   411                              <1> 	; Rather than poll IRQ6 waiting for DMA and FD controllers to finish
   412                              <1> 	; We need to use Programmed IO to poll the FDC and read/write data to RAM via CPU
   413                              <1> 	; Based on parts of the PC-Jr rw_opn routine which performs read/write/verify operation
   414                              <1> 	; We are assuming we are not using timer for missing system clock interrupts and no watchdog hardware
   415                              <1> 	
   416                              <1> ;	call	fdc_wait_irq ; This trashes al, Carry Set if no Interrrupt and timed out, ah=80
   417 00005E56 E8F3BC              <1>     call rw_opn  ; Calls a heavily modified version of PC-Jr rw_opn procedure and calls fdc_get_result and does similar to fdc_get_error error in ah
   418                              <1> 	
   419                              <1> 	;jc	.error_fdc_get_result
   420                              <1>   
   421                              <1> 	;mov	cl,7
   422                              <1> 	;call	fdc_get_result		; read result bytes
   423 00005E59 722F                <1> 	jc	.error_end_io
   424                              <1> 
   425                              <1> 	;call	fdc_get_error
   426                              <1> 
   427 00005E5B 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
   428                              <1> ;	mov	dh,byte [bp+int_13_dh]	; DH = head
   429                              <1> 					; Optimization: DH is preserved
   430 00005E5E E8F6B8              <1> 	call	fdc_end_io		; return number of last sector in BL
   431 00005E61 B0D9                <1> 	mov	al, 0xD9		; rw_opn returned and last sector
   432 00005E63 E680                <1> 	out	post_reg,al
   433                              <1> 
   434 00005E65 88D8                <1> 	mov	al,bl			; AL = last transferred sector
   435 00005E67 E680                <1> 	out	post_reg,al ; Output to POST last sector transferred
   436                              <1> 
   437 00005E69 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
   438                              <1> 
   439                              <1> .zero_sectors:
   440 00005E6C 08E4                <1> 	or	ah,ah
   441 00005E6E 7401                <1> 	jz	.exit			; jump if no errors
   442                              <1> 
   443                              <1> .error:
   444 00005E70 F9                  <1> 	stc				; indicate error
   445                              <1> 
   446                              <1> .exit:
   447 00005E71 88264100            <1> 	mov	byte [fdc_last_error],ah
   448 00005E75 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
   449 00005E78 E957FE              <1> 	jmp	int_13_upd_exit
   450                              <1> 
   451                              <1> .error_fdc_get_result:
   452 00005E7B B107                <1> 	mov	cl,7
   453 00005E7D 50                  <1> 	push	ax
   454 00005E7E B0DE                <1> 	mov	al, 0xDE		; Error get result (seek Failed?)
   455 00005E80 E680                <1> 	out	post_reg,al
   456 00005E82 E8C4B9              <1> 	call	fdc_get_result		; read result bytes
   457 00005E85 88E0                <1> 	mov	al, ah		; Get error 20 or 80 from get result
   458 00005E87 E680                <1> 	out	post_reg,al
   459 00005E89 58                  <1> 	pop	ax
   460                              <1> 
   461                              <1> .error_end_io:
   462 00005E8A 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
   463 00005E8D 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; DH = head
   464 00005E90 E8C4B8              <1> 	call	fdc_end_io		; return number of last sector in BL
   465 00005E93 B000                <1> 	mov	al,00h			; failure, no sectors transferred
   466 00005E95 EBD5                <1> 	jmp	.zero_sectors
   467                              <1> 
   468                              <1> .invalid_request:
   469 00005E97 B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
   470 00005E9A EBD4                <1> 	jmp	.error
   471                              <1> 
   472                              <1> ;=========================================================================
   473                              <1> ; int_13_fn05 - Format track
   474                              <1> ; Input:
   475                              <1> ;	AH = 05h
   476                              <1> ;	CH = track number
   477                              <1> ;	DH = head number (0 or 1)
   478                              <1> ;	DL = drive number (0 or 1)
   479                              <1> ;	ES:BX -> address field buffer
   480                              <1> ; Output:
   481                              <1> ;	CF clear if successful
   482                              <1> ;		AH = 00h - successful completion
   483                              <1> ;	CF set on error
   484                              <1> ;		AH = error code 
   485                              <1> ;-------------------------------------------------------------------------
   486                              <1> int_13_fn05:
   487 00005E9C E864BB              <1> 	call	get_media_state		; BL = drive media state
   488 00005E9F F6C310              <1> 	test	bl,fdc_m_established
   489 00005EA2 7472                <1> 	jz	.timeout		; jump if media type is not established
   490 00005EA4 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
   491 00005EA9 E831B8              <1> 	call	fdc_motor_on
   492 00005EAC E8D3B8              <1> 	call	fdc_disk_change		; read disk change line
   493 00005EAF 7260                <1> 	jc	.error_end_io		; jump if disk change check failed
   494 00005EB1 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
   495 00005EB3 E825BB              <1> 	call	fdc_set_rate		; select transfer rate
   496 00005EB6 E820B5              <1> 	call	fdc_send_specify	; send FDC Specify command
   497                              <1> 
   498 00005EB9 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
   499 00005EBC E866B7              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
   500 00005EBF 7247                <1> 	jc	.error_fdc_get_result	; jump if seek failed
   501                              <1> 
   502 00005EC1 1E                  <1> 	push	ds
   503 00005EC2 31F6                <1> 	xor	si,si
   504 00005EC4 8EDE                <1> 	mov	ds,si
   505 00005EC6 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   506 00005ECA 8A4C04              <1> 	mov	cl,byte [si+4]		; sectors per track
   507 00005ECD 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
   508 00005ED0 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
   509 00005ED3 1F                  <1> 	pop	ds
   510                              <1> 
   511 00005ED4 B500                <1> 	mov	ch,00h			; CX = sectors per track
   512 00005ED6 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
   513 00005ED8 D1E1                <1> 	shl	cx,1
   514 00005EDA 49                  <1> 	dec	cx	 		; minus one byte...
   515 00005EDB B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2
   516                              <1> 	;call	fdc_configure_dma
   517                              <1> 	;jc	.error_end_io		; DMA boundry crossed
   518                              <1> 
   519 00005EDD 88F4                <1> 	mov	ah,dh
   520 00005EDF D0E4                <1> 	shl	ah,1
   521 00005EE1 D0E4                <1> 	shl	ah,1
   522 00005EE3 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
   523 00005EE6 B04D                <1> 	mov	al,4Dh			; FDC Format command
   524 00005EE8 B106                <1> 	mov	cl,6			; 6 byte command
   525 00005EEA 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
   526 00005EEF E8E5B8              <1> 	call	fdc_send_cmd
   527 00005EF2 7205                <1> 	jc	.exit_end_io		; jump if failed to send command
   528                              <1> 
   529                              <1> ;	call	fdc_wait_irq
   530 00005EF4 E855BC              <1>     call rw_opn                 ; Need to check 
   531 00005EF7 7200                <1> 	jc	.exit_end_io
   532                              <1> 
   533                              <1> 	;mov	cl,7                ; rw_opn does calls to fdc_get_result and does same as fdc_get_error, leave error in ah
   534                              <1> 	;call	fdc_get_result		; read result bytes
   535                              <1> 	;jc	.exit_end_io
   536                              <1> 	;call	fdc_get_error		; get error code
   537                              <1> 
   538                              <1> .exit_end_io:
   539 00005EF9 E85BB8              <1> 	call	fdc_end_io
   540 00005EFC 08E4                <1> 	or	ah,ah
   541 00005EFE 7401                <1> 	jz	.exit			; jump if no errors
   542                              <1> 
   543                              <1> .error:
   544 00005F00 F9                  <1> 	stc				; indicate error
   545                              <1> 
   546                              <1> .exit:
   547 00005F01 88264100            <1> 	mov	byte [fdc_last_error],ah
   548 00005F05 E9CAFD              <1> 	jmp	int_13_upd_exit
   549                              <1> 
   550                              <1> .error_fdc_get_result:
   551 00005F08 B107                <1> 	mov	cl,7
   552 00005F0A 50                  <1> 	push	ax
   553 00005F0B E83BB9              <1> 	call	fdc_get_result		; read result bytes
   554 00005F0E 58                  <1> 	pop	ax
   555 00005F0F EBE8                <1> 	jmp	.exit_end_io
   556                              <1> 
   557                              <1> .error_end_io:
   558 00005F11 E843B8              <1> 	call	fdc_end_io
   559 00005F14 EBEA                <1> 	jmp	.error
   560                              <1> 
   561                              <1> .timeout:
   562 00005F16 B480                <1> 	mov	ah,fdc_e_timeout
   563 00005F18 EBE6                <1> 	jmp	.error
   564                              <1> 
   565                              <1> .invalid_request:
   566 00005F1A B401                <1> 	mov	ah,fdc_e_invalid
   567 00005F1C EBE2                <1> 	jmp	.error
   568                              <1> 
   569                              <1> ;=========================================================================
   570                              <1> ; int_0E - IRQ6 (FDC) service routine
   571                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
   572                              <1> ;-------------------------------------------------------------------------
   573 00005F1E FF<rep 39h>         <1> 	setloc	0EF57h
   573          ******************  <1>  warning: Inserting 57 bytes [-w+user]
   574                              <1> 
   575                              <1> int_0E:
   576 00005F57 50                  <1> 	push	ax
   577 00005F58 1E                  <1> 	push	ds
   578 00005F59 B84000              <1> 	mov	ax,biosdseg
   579 00005F5C 8ED8                <1> 	mov	ds,ax
   580 00005F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
   581 00005F63 1F                  <1> 	pop	ds
   582 00005F64 B020                <1> 	mov	al,20h			; send EOI to PIC
   583 00005F66 E620                <1> 	out	pic1_reg0,al
   584 00005F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
   585 00005F6B CD15                <1> 	int	15h
   586 00005F6D 58                  <1> 	pop	ax
   587 00005F6E CF                  <1> 	iret
   588                              <1> 
   589                              <1> ;=========================================================================
   590                              <1> ; Disk parameter tables in INT 1Eh format
   591                              <1> ; Byte 0: First byte for specify command:
   592                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
   593                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
   594                              <1> ; Byte 1: Second byte for specify command:
   595                              <1> ;	bits 7-1: head load time (1 = 4 ms)
   596                              <1> ;	bit 0: non-DMA mode (always 0)
   597                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
   598                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
   599                              <1> ; Byte 4: sectors per track
   600                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
   601                              <1> ; Byte 6: special sector size (0FFh - not used)
   602                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
   603                              <1> ; Byte 8: format filler byte (default 0F6h)
   604                              <1> ; Byte 9: head settle time in milliseconds
   605                              <1> ; Byte A: motor start time, in 1/8 seconds
   606                              <1> ; Byte B: number of cylinders minus one
   607                              <1> ; Byte C: transfer rate (in bits 7 - 6)
   608                              <1> ;-------------------------------------------------------------------------
   609                              <1> ; BBPC disable DMA, Note the Byte 1 of Specify (02h) should be 03h to disable DMA
   610                              <1> ; BUT we overrride this in the Send-Specify routine so disks should still be compatible 
   611                              <1> ; on other PCs. No need to change here with the change above
   612                              <1> 
   613                              <1> media_360_in_360:
   614 00005F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
   614 00005F78 0F08                <1>
   615 00005F7A 2780                <1> 	db	27h, 80h
   616                              <1> media_1200:
   617 00005F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
   617 00005F85 0F08                <1>
   618 00005F87 4F00                <1> 	db	4Fh, 00h
   619                              <1> media_720:
   620 00005F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
   620 00005F92 0F08                <1>
   621 00005F94 4F80                <1> 	db	4Fh, 80h
   622                              <1> media_1440:
   623 00005F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
   623 00005F9F 0F08                <1>
   624 00005FA1 4F00                <1> 	db	4Fh, 00h
   625                              <1> media_360_in_1200:
   626 00005FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
   626 00005FAC 0F08                <1>
   627 00005FAE 2740                <1> 	db	27h, 40h
   628                              <1> media_2880:
   629 00005FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
   629 00005FB9 0F08                <1>
   630 00005FBB 4FC0                <1> 	db	4Fh, 0C0h
   631                              <1> 
   632                              <1> ;=========================================================================
   633                              <1> ; Disk parameter table for IBM compatibility
   634                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
   635                              <1> ; DH Now uses 1440 values
   636                              <1> ;-------------------------------------------------------------------------
   637 00005FBD FF<rep Ah>          <1> 	setloc	0EFC7h
   637          ******************  <1>  warning: Inserting 10 bytes [-w+user]
   638                              <1> int_1E:
   639                              <1> ;	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
   640                              <1> ; db	4Fh, 0C0h
   641 00005FC7 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
   641 00005FD0 0F08                <1>
   642 00005FD2 4F00                <1> 	db	4Fh, 00h
  1412                                  %include	"printer2.inc"		; INT 17
     1                              <1> ;=========================================================================
     2                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
     3                              <1> ;       INT 17h, function AH=00h
     4                              <1> ;	INT 17h, function AH=02h
     5                              <1> ;	- see printer1.inc for other INT 17h functions
     6                              <1> ;-------------------------------------------------------------------------
     7                              <1> ;
     8                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     9                              <1> ;
    10                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    11                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    12                              <1> ;
    13                              <1> ; This program is free software: you can redistribute it and/or modify
    14                              <1> ; it under the terms of the GNU General Public License as published by
    15                              <1> ; the Free Software Foundation, either version 3 of the License, or
    16                              <1> ; (at your option) any later version.
    17                              <1> ;
    18                              <1> ; This program is distributed in the hope that it will be useful,
    19                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                              <1> ; GNU General Public License for more details.
    22                              <1> ;
    23                              <1> ; You should have received a copy of the GNU General Public License
    24                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    25                              <1> ;
    26                              <1> ;=========================================================================
    27                              <1> 
    28                              <1> ;=========================================================================
    29                              <1> ; int_17  - BIOS Printer Services
    30                              <1> ;-------------------------------------------------------------------------
    31                              <1> ;	setloc	0EFD2h			; INT 17 Entry Point
    32                              <1> 	setloc	0EFD4h			; INT 17 Entry Point
    33                              <1> int_17:
    34 00005FD4 FB                  <1> 	sti
    35 00005FD5 53                  <1> 	push	bx
    36 00005FD6 52                  <1> 	push	dx
    37 00005FD7 56                  <1> 	push	si
    38 00005FD8 1E                  <1> 	push	ds
    39 00005FD9 BB4000              <1> 	mov	bx,biosdseg
    40 00005FDC 8EDB                <1> 	mov	ds,bx
    41 00005FDE 83FA03              <1> 	cmp	dx,num_parallel
    42 00005FE1 7326                <1> 	jae	int_17_error		; invalid port number specified
    43 00005FE3 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
    44 00005FE6 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
    45 00005FE8 89D3                <1> 	mov	bx,dx
    46 00005FEA D1E3                <1> 	shl	bx,1
    47 00005FEC 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
    48 00005FEF 09D2                <1> 	or	dx,dx
    49 00005FF1 7416                <1> 	jz	int_17_error		; specified port is not installed
    50                              <1> 
    51 00005FF3 88C3                <1> 	mov	bl,al			; save AL to BL
    52                              <1> 
    53 00005FF5 08E4                <1> 	or	ah,ah
    54 00005FF7 7415                <1> 	jz	int_17_fn00		; AH = 00h
    55 00005FF9 FECC                <1> 	dec	ah
    56 00005FFB 7503E9DBC3          <1> 	jz	int_17_fn01		; AH = 01h
    57 00006000 FECC                <1> 	dec	ah
    58 00006002 7436                <1> 	jz	int_17_fn02		; AH = 02h
    59                              <1> 
    60                              <1> int_17_exit:
    61 00006004 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
    62 00006007 88D8                <1> 	mov	al,bl			; restore AL
    63                              <1> 
    64                              <1> int_17_error:
    65 00006009 1F                  <1> 	pop	ds
    66 0000600A 5E                  <1> 	pop	si
    67 0000600B 5A                  <1> 	pop	dx
    68 0000600C 5B                  <1> 	pop	bx
    69 0000600D CF                  <1> 	iret
    70                              <1> 
    71                              <1> ;=========================================================================
    72                              <1> ; int_17_fn00 - Print character
    73                              <1> ; Input:
    74                              <1> ;	AH = 0 - function 00h - print character
    75                              <1> ;	AL = character to print
    76                              <1> ;	DX = printer port number (0-2)
    77                              <1> ; Output:
    78                              <1> ;	AH = printer status:
    79                              <1> ;		bit 0	= 1	- timeout error
    80                              <1> ;		bit 1,2		- reserved
    81                              <1> ;		bit 3	= 1	- I/O error
    82                              <1> ;		bit 4	= 1	- printed selected
    83                              <1> ;		bit 5	= 1	- out of paper
    84                              <1> ;		bit 6	= 1	- acknowledge from printer
    85                              <1> ;		bit 7	= 1	- printer not busy
    86                              <1> ;-------------------------------------------------------------------------
    87                              <1> int_17_fn00:
    88 0000600E EE                  <1> 	out	dx,al			; output the character to the data port
    89 0000600F 42                  <1> 	inc	dx			; DX = prn_stat_reg
    90                              <1> 					; OPTIMIZATION:
    91                              <1> 					; prn_stat_reg = prn_data_reg + 1
    92 00006010 EC                  <1> 	in	al,dx			; read status
    93 00006011 88C4                <1> 	mov	ah,al			; AH = printer status
    94 00006013 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
    95 00006016 750C                <1>         jnz     .not_busy
    96                              <1> 
    97 00006018 B8FE90              <1> 	mov	ax,90FEh		; printer busy
    98 0000601B CD15                <1> 	int	15h			; call OS hook
    99                              <1> 
   100 0000601D B780                <1> 	mov	bh,prn_stat_busy
   101 0000601F E8F2C2              <1> 	call	wait_for_port		; wait for printer to be ready
   102 00006022 750E                <1> 	jnz	.timeout		; timeout had occured
   103                              <1> 
   104                              <1> .not_busy:
   105 00006024 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
   106                              <1> 					; OPTIMIZATION:
   107                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
   108 00006025 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
   109 00006027 EE                  <1> 	out	dx,al			; activate strobe
   110 00006028 E6C0                <1> 	out	unused_reg,al		; I/O delay
   111 0000602A B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
   112 0000602C EE                  <1> 	out	dx,al			; de-activate strobe
   113 0000602D 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
   114 00006030 EBD2                <1> 	jmp	int_17_exit
   115                              <1> 
   116                              <1> .timeout:
   117 00006032 80E4F8              <1> 	and	ah,prn_stat_bits
   118 00006035 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
   119 00006038 EBCA                <1> 	jmp	int_17_exit
   120                              <1> 
   121                              <1> ;=========================================================================
   122                              <1> ; int_17_fn02 - Return printer status
   123                              <1> ; Input:
   124                              <1> ;	AH = 2 - function 02h - return printer status
   125                              <1> ;	DX = printer port number (0-2)
   126                              <1> ; Output:
   127                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
   128                              <1> ;-------------------------------------------------------------------------
   129                              <1> int_17_fn02:
   130 0000603A 42                  <1> 	inc	dx			; DX = prn_stat_reg
   131                              <1> 					; OPTIMIZATION:
   132                              <1> 					; prn_stat_reg = prn_data_reg + 1
   133                              <1> int_17_status:
   134 0000603B EC                  <1> 	in	al,dx			; read the status
   135 0000603C 88C4                <1> 	mov	ah,al			; move status to AH
   136 0000603E 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
   137 00006041 EBC1                <1> 	jmp	int_17_exit
  1413                                  %include	"video.inc"		; INT 10
     1                              <1> ;=========================================================================
     2                              <1> ; video.inc - BIOS video services
     3                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
     4                              <1> ;-------------------------------------------------------------------------
     5                              <1> ;
     6                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     7                              <1> ;
     8                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24                              <1> 
    25                              <1> ;-------------------------------------------------------------------------
    26                              <1> ; CRTC registers
    27                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
    28                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
    29                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
    30                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
    31                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
    32                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
    33                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
    34                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
    35                              <1> 
    36                              <1> ;-------------------------------------------------------------------------
    37                              <1> ; control characters
    38                              <1> bel	equ	07h
    39                              <1> bs	equ	08h
    40                              <1> lf	equ	0Ah
    41                              <1> cr	equ	0Dh
    42                              <1> 
    43 00006043 FF<rep 2h>          <1> 	setloc	0F045h			; int 10 functions table
    43          ******************  <1>  warning: Inserting 2 bytes [-w+user]
    44                              <1> 
    45                              <1> int_10_dispatch:
    46 00006045 [0461]              <1> 	dw	int_10_fn00		; Set video mode
    47 00006047 [BC61]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
    48 00006049 [D161]              <1> 	dw	int_10_fn02		; Set cursor position
    49 0000604B [F461]              <1> 	dw	int_10_fn03		; Get cursor position and shape
    50 0000604D [0862]              <1> 	dw	int_10_fn04		; Read light pen position
    51 0000604F [3762]              <1> 	dw	int_10_fn05		; Set active display page
    52 00006051 [6262]              <1> 	dw	int_10_fn06		; Scroll up window
    53 00006053 [6262]              <1> 	dw	int_10_fn07		; Scroll down window
    54 00006055 [EF63]              <1> 	dw	int_10_fn08		; Read character and attribute
    55 00006057 [EF63]              <1> 	dw	int_10_fn09		; Write character and attribute
    56 00006059 [EF63]              <1> 	dw	int_10_fn0A		; Write character only
    57 0000605B [E265]              <1> 	dw	int_10_fn0B		; Set background color or palette
    58 0000605D [0C66]              <1> 	dw	int_10_fn0C		; Write graphics pixel
    59 0000605F [4466]              <1> 	dw	int_10_fn0D		; Read graphics pixel
    60 00006061 [6266]              <1> 	dw	int_10_fn0E		; Teletype output
    61 00006063 [D766]              <1> 	dw	int_10_fn0F		; Get current video mode
    62                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
    63                              <1> 
    64                              <1> 
    65                              <1> ;-------------------------------------------------------------------------
    66                              <1> ; offsets for registers on stack
    67                              <1> 
    68                              <1> int_10_ax	equ	0
    69                              <1> int_10_al	equ	int_10_ax
    70                              <1> int_10_ah	equ	int_10_ax+1
    71                              <1> int_10_bx	equ	int_10_ax+2
    72                              <1> int_10_bl	equ	int_10_bx
    73                              <1> int_10_bh	equ	int_10_bx+1
    74                              <1> int_10_cx	equ	int_10_bx+2
    75                              <1> int_10_ch	equ	int_10_cx+1
    76                              <1> int_10_dx	equ	int_10_cx+2
    77                              <1> 
    78                              <1> ;=========================================================================
    79                              <1> ; int_10 - BIOS video services
    80                              <1> ; Input:
    81                              <1> ;	AH - Function
    82                              <1> ;		00h - Set video mode
    83                              <1> ;		01h - Set text mode cursor shape
    84                              <1> ;		02h - Set cursor position
    85                              <1> ;		03h - Get cursor position and shape
    86                              <1> ;		04h - Read light pen position
    87                              <1> ;		05h - Select active display page
    88                              <1> ;		06h - Scroll up window
    89                              <1> ;		07h - Scroll down window
    90                              <1> ;		08h - Read character and attribute at cursor position
    91                              <1> ;		09h - Write character and attribute at cursor position
    92                              <1> ;		0Ah - Write character only at cursor position
    93                              <1> ;		0Bh -
    94                              <1> ;			BH = 00h - Set background/border color
    95                              <1> ;			BH = 01h - Set palette
    96                              <1> ;		0Ch - Write graphics pixel
    97                              <1> ;		0Dh - Read graphics pixel
    98                              <1> ;		0Eh - Teletype output
    99                              <1> ;		0Fh - Get current video mode
   100                              <1> ;-------------------------------------------------------------------------
   101                              <1> 	setloc	0F065h			; int 10 Entry Point
   102                              <1> int_10:
   103 00006065 FB                  <1> 	sti
   104 00006066 FC                  <1> 	cld				;  ...strings auto-increment
   105 00006067 55                  <1> 	push	bp
   106 00006068 06                  <1> 	push	es
   107 00006069 1E                  <1> 	push	ds
   108 0000606A 56                  <1> 	push	si
   109 0000606B 57                  <1> 	push	di
   110 0000606C 52                  <1> 	push	dx
   111 0000606D 51                  <1> 	push	cx
   112 0000606E 53                  <1> 	push	bx
   113 0000606F 50                  <1> 	push	ax
   114 00006070 BB4000              <1> 	mov	bx,biosdseg
   115 00006073 8EDB                <1> 	mov	ds,bx
   116 00006075 8A1E4900            <1> 	mov	bl,byte [video_mode]
   117 00006079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
   118 0000607C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
   119 0000607F 7202                <1> 	jb	.color			; it is CGA
   120 00006081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
   121                              <1> 	;mov	al,0x98   ; MDA Init to POST!
   122                              <1> 	;out	post_reg,al
   123                              <1>   
   124                              <1> .color:
   125 00006083 8EC3                <1> 	mov	es,bx			; load video segment to ES
   126 00006085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
   127 00006087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
   128 0000608A 730B                <1> 	jae	.exit			; invalid function
   129 0000608C B700                <1> 	mov	bh,0
   130 0000608E 88E3                <1> 	mov	bl,ah
   131 00006090 D1E3                <1> 	shl	bx,1
   132 00006092 2EFF97[4560]        <1>     cs	call	near [int_10_dispatch+bx]
   133                              <1> 
   134                              <1> .exit:
   135 00006097 58                  <1> 	pop	ax
   136 00006098 5B                  <1> 	pop	bx
   137 00006099 59                  <1> 	pop	cx
   138 0000609A 5A                  <1> 	pop	dx
   139 0000609B 5F                  <1> 	pop	di
   140 0000609C 5E                  <1> 	pop	si
   141 0000609D 1F                  <1> 	pop	ds
   142 0000609E 07                  <1> 	pop	es
   143 0000609F 5D                  <1> 	pop	bp
   144 000060A0 CF                  <1> 	iret
   145                              <1> 
   146                              <1> 
   147                              <1> ;=========================================================================
   148                              <1> ; int_1D - Video parameters tables
   149                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
   150                              <1> ; video mode initialization
   151                              <1> ;-------------------------------------------------------------------------
   152 000060A1 FF<rep 3h>          <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
   152          ******************  <1>  warning: Inserting 3 bytes [-w+user]
   153                              <1> int_1D:
   154                              <1> %ifndef MACHINE_BBPC8088
   155                              <1> 
   156                              <1> 	; CGA test 40x25 modes
   157                              <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
   158                              <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
   159                              <1> 
   160                              <1> 	; CGA text 80x25 modes
   161                              <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
   162                              <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
   163                              <1> 
   164                              <1> 	; CGA graphics modes
   165                              <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
   166                              <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
   167                              <1> 
   168                              <1> 	; MDA text 80x25 mode
   169                              <1>     db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
   170                              <1>     db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
   171                              <1> %endif
   172                              <1> %ifdef MACHINE_BBPC8088
   173                              <1>         ; CGA test 40x25 modes 
   174 000060A4 31282A061B03191A    <1>         db	31h, 28h, 2Ah, 06h, 1Bh, 03h, 19h, 1Ah
   175 000060AC 500F0D0F00000000    <1>         db	50h, 0Fh, 0Dh, 0Fh, 00h, 00h, 00h, 00h
   176                              <1> 
   177                              <1>         ; CGA text 80x25 modes
   178 000060B4 6350540C1B03191A    <1>         db	63h, 50h, 54h, 0Ch, 1Bh, 03h, 19h, 1Ah
   179 000060BC 500F0D0F00000000    <1>         db	50h, 0Fh, 0Dh, 0Fh, 00h, 00h, 00h, 00h
   180                              <1> 
   181                              <1>         ; CGA graphics modes - cursor off 20h
   182 000060C4 6350540C6C146468    <1>         db	63h, 50h, 54h, 0Ch, 6Ch, 14h, 64h, 68h
   183 000060CC 5003200F00000000    <1>         db	50h, 03h, 20h, 0Fh, 00h, 00h, 00h, 00h
   184                              <1> 
   185                              <1> 	; BB PC MDA text 80x25 mode VGA compatible Output
   186 000060D4 6350540C1B03191A    <1>         db	63h, 50h, 54h, 0Ch, 1Bh, 03h, 19h, 1Ah
   187 000060DC 500F0D0F00000000    <1>         db	50h, 0Fh, 0Dh, 0Fh, 00h, 00h, 00h, 00h
   188                              <1> %endif
   189                              <1> 
   190                              <1> page_size:
   191 000060E4 0008                <1> 	dw	0800h			; text 40x25 mode
   192 000060E6 0010                <1> 	dw	1000h			; text 80x25 mode
   193 000060E8 0040                <1> 	dw	4000h			; graphics modes
   194 000060EA 0040                <1> 	dw	4000h
   195                              <1> 
   196                              <1> columns:
   197 000060EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
   198 000060EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
   199 000060F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
   200 000060F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
   201                              <1> 
   202                              <1> ; MODES   Blink - bit 5
   203                              <1>         ; |640x200 2 Col - bit 4
   204                              <1>         ; || Video Enable - bit 3
   205                              <1>         ; || |B&W - bit 2
   206                              <1>         ; || ||Graphics - bit 1
   207                              <1>         ; || |||HiRes - bit 0        
   208                              <1>         ; || |||| 
   209                              <1> ; 0 2Ch 0010 1100 40 x 25 Alphanumeric Black-and-White
   210                              <1> ; 1 28h 0010 1000 40 x 25 Alphanumeric Color
   211                              <1> ; 2 2Dh 0010 1101 80 x 25 Alphanumeric Black-and-White
   212                              <1> ; 3 29h 0010 1001 80 x 25 Alphanumeric Color
   213                              <1> ; 4 0Fh 0000 1111 320 x 200 Black-and-White Graphics Blink off Hires on BW on
   214                              <1> ; 5 0Bh 0000 1011 320 x 200 Color Graphics           Blink off Hires on BW off
   215                              <1> ; 6 1Fh 0001 1111 640 x 200 Black-and-White Graphics Hires on
   216                              <1> ; 7 29h 0010 1001 80 x 25 Alphanumeric Monochrome Display Adapter
   217                              <1> 
   218                              <1> ;MODES is used to set the Control/Mode register 0x03D8
   219                              <1> %ifndef MACHINE_BBPC8088
   220                              <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
   221                              <1> %endif
   222                              <1> %ifdef MACHINE_BBPC8088
   223 000060F4 2C282D290F0B1F29    <1> MODES	db	2Ch,28h,2Dh,29h,0Fh,0Bh,1Fh,29h ; Table of mode sets modified for BBPC CGA/VGA hybrid
   224                              <1> %endif
   225                              <1> 
   226 000060FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
   227                              <1> 
   228                              <1> ;=========================================================================
   229                              <1> ; int_10_fn00 - Set video mode
   230                              <1> ; Input:
   231                              <1> ;	AH = 00h
   232                              <1> ;	AL = video mode
   233                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
   234                              <1> ;		01h - CGA - text 40x25, 16 colors
   235                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
   236                              <1> ;		03h - CGA - text 80x25, 16 colors
   237                              <1> ;		04h - CGA - graphics 320x200, 4 colors
   238                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
   239                              <1> ;		06h - CGA - graphics 640x200, monochrome
   240                              <1> ;		07h - MDA - text 80x25, monochrome
   241                              <1> ;-------------------------------------------------------------------------
   242                              <1> int_10_fn00:
   243 00006104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
   244                              <1> 					; assume CGA mode
   245 00006107 B900B8              <1> 	mov	cx,0B800h		; CGA video memory segment
   246 0000610A BAD403              <1> 	mov	dx,3D4h			; port for MC6845 CRTC address register
   247 0000610D A01000              <1> 	mov	al,byte [equipment_list] ; get equipment - low byte
   248 00006110 2430                <1> 	and	al,equip_video		; get video adapter type
   249 00006112 3C30                <1> 	cmp	al,equip_mono		; monochrome?
   250 00006114 B000                <1> 	mov	al,0
   251 00006116 7507                <1> 	jne	.color			; jump if CGA/color mode
   252                              <1> 					; set MDA mode
   253 00006118 B307                <1> 	mov	bl,07h			; MDA can only be 7
   254 0000611A B5B0                <1> 	mov	ch,0B0h			; MDA video memory segment
   255 0000611C B2B4                <1> 	mov	dl,0B4h 		; port for MC6845 CRTC address register
   256 0000611E 40                  <1> 	inc	ax
   257                              <1> 
   258                              <1> .color:
   259 0000611F 8EC1                <1> 	mov	es,cx			; ES = video memory segment
   260 00006121 89166300            <1> 	mov	word [video_port],dx	; Save current CRTC display port
   261 00006125 80C204              <1> 	add	dl,4
   262 00006128 EE                  <1> 	out	dx,al			; Reset the video
   263 00006129 881E4900            <1> 	mov	byte [video_mode],bl	; Save current CRTC mode
   264 0000612D B700                <1> 	mov	bh,0
   265 0000612F 53                  <1> 	push	bx
   266 00006130 06                  <1> 	push	es
   267 00006131 31C0                <1> 	xor	ax,ax
   268 00006133 8EC0                <1> 	mov	es,ax			; Load interrupt table segment to ES
   269 00006135 26C4367400          <1>     es	les	si,[1Dh*4]		; Load video parameters table
   270                              <1> 					; (INT 1Dh vector) to ES:SI
   271 0000613A 2E8A9F[FC60]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get BL for indexing into int_1D
   272 0000613F 01DE                <1> 	add	si,bx
   273                              <1> 
   274 00006141 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
   275 00006145 86CD                <1> 	xchg	cl,ch			; convert to LSB format
   276 00006147 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
   277                              <1> 
   278 0000614B B91000              <1> 	mov	cx,10h			; Sixteen values to send
   279                              <1> 
   280                              <1> .setup_crt_loop:
   281 0000614E 268A04              <1>     es	mov	al,byte [si]		; Value to send in SI
   282 00006151 E8B105              <1> 	call	vid_crtc_writeb			;  ...send it
   283 00006154 FEC4                <1> 	inc	ah			;  ...bump count
   284 00006156 46                  <1> 	inc	si			;  ...point to next
   285 00006157 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
   286 00006159 07                  <1> 	pop	es
   287 0000615A 31FF                <1> 	xor	di,di
   288 0000615C B90020              <1> 	mov	cx,2000h		; video memory size for CGA
   289 0000615F 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
   290 00006161 E88605              <1> 	call	vid_check_mode		; Set flags according to mode
   291 00006164 7208                <1> 	jc	.clear_screen		; jump if graphics mode
   292 00006166 7503                <1> 	jnz	.text_fill		; jump if CGA mode
   293 00006168 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
   294                              <1> 
   295                              <1> .text_fill:
   296 0000616B B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
   297                              <1> 
   298                              <1> .clear_screen:
   299 0000616E F3AB                <1> 	repz	stosw			; clear screen with fill word
   300                              <1> 
   301 00006170 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
   302 00006174 80C204              <1> 	add	dl,4
   303 00006177 5B                  <1> 	pop	bx
   304 00006178 2E8A87[F460]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
   305 0000617D EE                  <1> 	out	dx,al			;  ...and send it
   306 0000617E A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
   307 00006181 42                  <1> 	inc	dx
   308 00006182 B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w colour set 1, intensity 1 and black background
   309 00006184 80FB06              <1> 	cmp	bl,6			;  ...correct?
   310 00006187 7502                <1> 	jnz	.set_palette
   311 00006189 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w colour set 1 and intensity on, white foreground
   312                              <1> 
   313                              <1> .set_palette:
   314 0000618B A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
   315 0000618E EE                  <1> 	out	dx,al			;  ...send palette
   316                              <1> 
   317 0000618F 8CD8                <1> 	mov	ax,ds
   318 00006191 8EC0                <1> 	mov	es,ax
   319 00006193 31C0                <1> 	xor	ax,ax
   320 00006195 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
   321 00006198 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
   322 0000619B BF4E00              <1> 	mov	di,video_page_offt
   323 0000619E F3AB                <1>  	rep	stosw			; zero page offset and cursor position
   324                              <1> 
   325 000061A0 2E8A87[EC60]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
   326 000061A5 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
   327 000061A8 B018                <1> 	mov	al,24			; All supported modes have 25 rows
   328 000061AA A28400              <1> 	mov	byte [video_rows],al	;  ... the value saved uses one less
   329 000061AD 80E3FE              <1> 	and	bl,0FEh			; Clear the LSB to get an index
   330                              <1> 					; to 16-bit word page_size table
   331                              <1> 					; FIXME: It returns graphics mode page
   332                              <1> 					; size for mode 7. Probably not
   333                              <1> 					; critical, as MDA has only one page
   334 000061B0 2E8B87[E460]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
   335 000061B5 A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
   336                              <1> %ifdef MACHINE_BBPC8088
   337 000061B8 E89EF1              <1>   call INITPALETTE
   338                              <1> %endif  
   339                              <1>   
   340 000061BB C3                  <1> 	ret
   341                              <1> 
   342                              <1> ;=========================================================================
   343                              <1> ; int_10_fn01 - Set text-mode cursor shape
   344                              <1> ; Input:
   345                              <1> ;	AH = 01h
   346                              <1> ;	CH = cursor scan line start
   347                              <1> ;	CL = cursor scan line end
   348                              <1> ; Output:
   349                              <1> ;	none
   350                              <1> ; Modified for BBPC CGA/VGA as characters are rows 0-15 NOT 0-7
   351                              <1> ; Multiply CH by 2 (rotate left), CL by 2 (rotate left) leaves 1 blank line at row 15
   352                              <1> ; Note stored shape in video_cur_shape is in original format
   353                              <1> ;-------------------------------------------------------------------------
   354                              <1> int_10_fn01:
   355 000061BC 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
   356                              <1> %ifdef MACHINE_BBPC8088
   357 000061C0 803E490007          <1> 	cmp	byte [video_mode],7     ; MDA Don't wait for retrace
   358 000061C5 7404                <1>     jz      .nocursorfix
   359                              <1> 
   360 000061C7 D0C5                <1> 	rol ch, 1               ; Multiply start row by 2
   361 000061C9 D0C1                <1> 	rol cl, 1               ; Multiply finish row by 2
   362                              <1> .nocursorfix:
   363                              <1> %endif
   364 000061CB B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
   365 000061CD E82C05              <1> 	call	vid_crtc_writew		; write it to CRTC
   366 000061D0 C3                  <1> 	ret
   367                              <1> 
   368                              <1> ;=========================================================================
   369                              <1> ; int_10_fn02 - Set cursor position
   370                              <1> ; Input:
   371                              <1> ;	AH = 02h
   372                              <1> ;	BH = page number
   373                              <1> ;	DH = cursor row (00h is top)
   374                              <1> ;	DL = cursor column (00h is left)
   375                              <1> ; Output:
   376                              <1> ;	none
   377                              <1> ;-------------------------------------------------------------------------
   378                              <1> int_10_fn02:
   379 000061D1 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
   380 000061D4 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
   381 000061D8 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
   382                              <1> 
   383                              <1> ;=========================================================================
   384                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
   385                              <1> ;	BL = page
   386                              <1> ;	DH = cursor row (00h is top)
   387                              <1> ;	DL = cursor column (00h is left)
   388                              <1> ;-------------------------------------------------------------------------
   389                              <1> set_cur_pos:
   390 000061DA 89D0                <1> 	mov	ax,dx			; AX = cursor position
   391 000061DC E86505              <1> 	call	vid_position_to_offset			; AX - offset
   392 000061DF 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
   393 000061E3 D1E8                <1> 	shr	ax,1
   394 000061E5 89C1                <1> 	mov	cx,ax
   395 000061E7 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
   396 000061E9 E81005              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
   397                              <1> bios_set_cur_pos:
   398 000061EC B700                <1> 	mov	bh,0
   399 000061EE D0E3                <1> 	shl	bl,1			; index to words table
   400 000061F0 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
   401 000061F3 C3                  <1> 	ret
   402                              <1> 
   403                              <1> ;=========================================================================
   404                              <1> ; int_10_fn03 - Get cursor position and shape
   405                              <1> ; Input:
   406                              <1> ;	AH = 03h
   407                              <1> ;	BH = page number
   408                              <1> ; Output:
   409                              <1> ;	CH = cursor start scan line
   410                              <1> ;	CL = cursor end scan line
   411                              <1> ;	DH = cursor row (00h is top)
   412                              <1> ;	DL = cursor column (00h is left)
   413                              <1> ;-------------------------------------------------------------------------
   414                              <1> int_10_fn03:
   415 000061F4 B700                <1> 	mov	bh,0
   416 000061F6 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
   417 000061F9 D0E3                <1> 	shl	bl,1
   418 000061FB 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
   419 000061FE 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
   420 00006201 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
   421 00006204 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
   422 00006207 C3                  <1> 	ret
   423                              <1> 
   424                              <1> ;=========================================================================
   425                              <1> ; int_10_fn04 - Read light pen position
   426                              <1> ; Input:
   427                              <1> ;	AH = 04h
   428                              <1> ; Output:
   429                              <1> ;	AH - light pen trigger flag
   430                              <1> ;		00h not down/triggered
   431                              <1> ;		01h down/triggered
   432                              <1> ;	If light pen is triggered:
   433                              <1> ;		DH = character row
   434                              <1> ;		DL = character column
   435                              <1> ;		CH = pixel row
   436                              <1> ;		BX = pixel column
   437                              <1> ; Note in BBPC design Light pen is disabled and register values indicate no action needed
   438                              <1> ; Comment out the reading code to free space to allow correct BIOS locations to be used.
   439                              <1> ;-------------------------------------------------------------------------
   440                              <1> int_10_fn04:
   441 00006208 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
   442 0000620C 8B166300            <1> 	mov	dx,word [video_port]
   443 00006210 80C206              <1> 	add	dl,6			; CRTC status register
   444 00006213 EC                  <1> 	in	al,dx			; read it
   445 00006214 A804                <1> 	test	al,4			; test light pen switch bit
   446 00006216 7410                <1> 	jz	.reset_pen		; reset pen and return if switch is off
   447 00006218 A802                <1> 	test	al,2			; test light pen tigger bit
   448                              <1> ;	jnz	.read_pen		; continue if triggered
   449 0000621A C3                  <1> 	ret				; not triggered - return
   450                              <1> 
   451                              <1> ; .read_pen:
   452                              <1> 	; mov	dx,word [video_port]	; CRTC index register
   453                              <1> 	; mov	al,crtc_pen_hi		; CRTC pen position high byte register
   454                              <1> 	; out	dx,al			; select it
   455                              <1> 	; inc	dx			; CRTC data register
   456                              <1> 	; in	al,dx			; read high byte of pen position
   457                              <1> 	; mov	ah,al
   458                              <1> 	; dec	dx			; CRTC index register
   459                              <1> 	; mov	al,crtc_pen_lo		; CRTC pen position low byte register
   460                              <1> 	; out	dx,al			; select it
   461                              <1> 	; inc	dx			; CRTC data register
   462                              <1> 	; in	al,dx			; read low byte of pen position
   463                              <1> 
   464                              <1> 	; mov	bh,0
   465                              <1> 	; mov	bl,byte [video_mode]	; get current video mode
   466                              <1>     ; cs	mov	bl,byte [bx+.correction] ; light pen correction factor
   467                              <1> 	; sub	ax,bx
   468                              <1> 	; jns	.1
   469                              <1> 	; xor	ax,ax			; set to zero if negative result
   470                              <1> 
   471                              <1> ; .1:
   472                              <1> 	; call	vid_check_mode			; check video mode
   473                              <1> 	; jnc	.text			; calculate character position if text
   474                              <1> 	; mov	dl,40			; divide by 40
   475                              <1> 	; div	dl			; AL = row, AH = column (reminder)
   476                              <1> 	; mov	bh,0
   477                              <1> 	; mov	bl,ah
   478                              <1> 	; mov	cl,3
   479                              <1> 	; shl	bx,cl			; BX = AH * 8 - pixel column
   480                              <1> 	; mov	ch,al
   481                              <1> 	; shl	ch,1			; CH = AL * 2 - pixel row
   482                              <1> 	; mov	dl,ah			; DL = AH - character column
   483                              <1> 	; mov	dh,al
   484                              <1> 	; shr	dh,1
   485                              <1> 	; shr	dh,1			; DH = AL / 4 - character row
   486                              <1> 	; cmp	byte [video_mode],6	; check for 640x200 mode
   487                              <1> 	; jnz	.exit
   488                              <1> 	; shl	bx,1			; adjust pixel column (double it)
   489                              <1> 	; shl	dl,1			; same or character column
   490                              <1> 	; jmp	.exit
   491                              <1> 
   492                              <1> ; .text:
   493                              <1> 	; div	byte [video_columns] 	; divide by number of columns
   494                              <1> 	; xchg	al,ah			; AL = column, AH = row
   495                              <1> 	; mov	dx,ax			; save characer row,column to DH,AL
   496                              <1> 	; mov	cl,3
   497                              <1> 	; shl	ah,cl
   498                              <1> 	; mov	ch,ah			; CH = AH * 8 - pixel row
   499                              <1> 	; mov	bh,0
   500                              <1> 	; mov	bl,al
   501                              <1> 	; shl	bx,cl			; BX = AL * 8 - pixel column
   502                              <1> 
   503                              <1> .exit:
   504 0000621B C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
   505 0000621F 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
   506 00006222 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
   507 00006225 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
   508                              <1> 
   509                              <1> .reset_pen:
   510 00006228 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
   511 0000622C 80C207              <1> 	add	dl,7			; clear light pen strobe reg
   512 0000622F EE                  <1> 	out	dx,al			; reset it
   513 00006230 C3                  <1> 	ret
   514                              <1> 
   515                              <1> .correction:
   516                              <1> ;	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
   517 00006231 030305050303        <1> 	db	3, 3, 5, 5, 3, 3	; light pen correction, remove 2 bytes to correct setloc
   518                              <1> 
   519                              <1> ;=========================================================================
   520                              <1> ; int_10_fn05 - Select active display page
   521                              <1> ; Input:
   522                              <1> ;	AH = 05h
   523                              <1> ;	AL - new page number (00h is the first page)
   524                              <1> ; Output:
   525                              <1> ;	none
   526                              <1> ;-------------------------------------------------------------------------
   527                              <1> int_10_fn05:
   528 00006237 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
   529 0000623A 88C3                <1> 	mov	bl,al			; also copy it to BL
   530 0000623C B400                <1> 	mov	ah,0
   531 0000623E F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
   532 00006242 A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
   533 00006245 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
   534 00006247 89C1                <1> 	mov	cx,ax			; save a copy to CX
   535 00006249 B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
   536 0000624B E8AE04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
   537                              <1> 
   538 0000624E B700                <1> 	mov	bh,0
   539 00006250 D1E3                <1> 	shl	bx,1
   540 00006252 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
   541 00006255 E8EC04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
   542 00006258 D1E8                <1> 	shr	ax,1
   543 0000625A 01C1                <1> 	add	cx,ax			; add to the page offset
   544 0000625C B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
   545 0000625E E89B04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
   546 00006261 C3                  <1> 	ret
   547                              <1> 
   548                              <1> ;=========================================================================
   549                              <1> ; int_10_fn06 - scroll up window
   550                              <1> ; int_10_fn07 - scroll down window
   551                              <1> ; Input:
   552                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
   553                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
   554                              <1> ;	BH = attribute used to write blank rows at bottom of window
   555                              <1> ;	CH,CL = row,column of window's upper left corner
   556                              <1> ;	DH,DL = row,column of window's lower right corner
   557                              <1> ; Output:
   558                              <1> ;	none
   559                              <1> ; TODO:
   560                              <1> ;	optimize graphics fill
   561                              <1> ;-------------------------------------------------------------------------
   562                              <1> int_10_fn06:
   563                              <1> int_10_fn07:
   564 00006262 E88504              <1> 	call	vid_check_mode
   565 00006265 7303E9E000          <1> 	jc	.graphics_scroll
   566                              <1> 
   567 0000626A 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
   568 0000626C 803E490002          <1> 	cmp	byte [video_mode],2
   569 00006271 720A                <1> 	jb	.no_snow
   570 00006273 803E490003          <1> 	cmp	byte [video_mode],3
   571 00006278 7703                <1> 	ja	.no_snow
   572 0000627A BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
   573                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
   574                              <1> .no_snow:
   575 0000627D 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
   576 00006280 50                  <1> 	push	ax
   577 00006281 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
   578 00006285 7403                <1> 	jz	.1			; jump if scroll down
   579 00006287 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
   580                              <1> 
   581                              <1> .1:
   582 0000628A E8B704              <1> 	call	vid_position_to_offset
   583 0000628D 03064E00            <1> 	add	ax,word [video_page_offt]
   584 00006291 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
   585                              <1> 
   586                              <1> ; calculate scroll window size (DX)
   587                              <1> 
   588 00006293 5A                  <1> 	pop	dx			; DX = window's lower right corner
   589 00006294 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
   590 00006297 81C20101            <1> 	add	dx,101h 		; add 1x1
   591                              <1> 
   592                              <1> ; calculate offset between the source and the destination (AX)
   593                              <1> 
   594 0000629B 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
   595 0000629F D1E3                <1> 	shl	bx,1			; each character takes two bytes
   596 000062A1 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
   597 000062A4 52                  <1> 	push    dx
   598 000062A5 B400                <1>         mov     ah,0
   599 000062A7 F7E3                <1>         mul     bx
   600 000062A9 5A                  <1>         pop     dx
   601                              <1> 
   602 000062AA 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
   603 000062AC 28D3                <1> 	sub	bl,dl			;   row and beggining of another
   604 000062AE 1E                  <1> 	push	ds
   605 000062AF 8CC1                <1> 	mov	cx,es
   606 000062B1 8ED9                <1> 	mov	ds,cx			; load video segment to DS
   607 000062B3 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
   608 000062B7 7405                <1> 	jz	.2			; jump if scroll up
   609 000062B9 F7D8                <1> 	neg	ax			; negate offset
   610 000062BB F7DB                <1> 	neg	bx			; negate distance
   611 000062BD FD                  <1> 	std				; copy backwards
   612                              <1> 
   613                              <1> .2:
   614 000062BE 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
   615 000062C1 08C9                <1> 	or	cl,cl
   616 000062C3 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
   617 000062C5 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
   618 000062C6 01FE                <1> 	add	si,di			; SI = scroll copy source address
   619 000062C8 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
   620                              <1> 
   621 000062CA 09DB                <1> 	or	bx,bx
   622 000062CC 7434                <1> 	jz	.text_full_row_scroll
   623                              <1> 
   624                              <1> .text_scroll_loop:
   625 000062CE B500                <1> 	mov	ch,0
   626 000062D0 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
   627                              <1> 
   628 000062D2 D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
   629 000062D4 7303                <1> 	jnc	.text_scroll_no_retrace
   630 000062D6 E85800              <1> 	call	.retrace_wait
   631                              <1> 
   632                              <1> .text_scroll_no_retrace:
   633 000062D9 F3A5                <1> 	repz	movsw			; copy one row
   634                              <1> 
   635                              <1> ;.text_scroll_next_row:
   636 000062DB 01DE                <1> 	add	si,bx			; SI = next row to copy source address
   637 000062DD 01DF                <1> 	add	di,bx			; DI = next row to copy destination
   638 000062DF FECE                <1> 	dec	dh			; decrement row counter
   639 000062E1 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
   640                              <1> 
   641                              <1> .text_fill:
   642 000062E3 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
   643 000062E6 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
   644                              <1> 
   645                              <1> .text_fill_only:
   646 000062E8 B500                <1> 	mov	ch,0
   647 000062EA 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
   648 000062ED B020                <1> 	mov	al,' '			; AL = blank character
   649                              <1> 
   650                              <1> .text_fill_loop:
   651 000062EF 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
   652 000062F1 D1CE                <1> 	ror	si,1			; rotate snow workaround flag
   653 000062F3 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
   654 000062F5 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
   655                              <1> 
   656                              <1> .text_fill_no_retrace:
   657 000062F8 F3AB                <1> 	repz	stosw			; fill one row
   658 000062FA 01DF                <1> 	add	di,bx			; DI = next row to fill destination
   659 000062FC FECE                <1> 	dec	dh			; decrement row counter
   660 000062FE 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
   661                              <1> 
   662 00006300 1F                  <1> 	pop	ds
   663 00006301 C3                  <1> 	ret
   664                              <1> 
   665                              <1> .text_full_row_scroll:
   666 00006302 09C0                <1> 	or	ax,ax
   667 00006304 741F                <1> 	jz	.text_full_row_no_snow
   668 00006306 50                  <1> 	push	ax
   669 00006307 88D0                <1> 	mov	al,dl
   670 00006309 F6E6                <1> 	mul	dh
   671                              <1> 
   672                              <1> .text_full_row_loop:
   673 0000630B B9F000              <1> 	mov	cx,240
   674 0000630E 39C8                <1> 	cmp	ax,cx
   675 00006310 7705                <1> 	ja	.copy_chunk
   676 00006312 91                  <1> 	xchg	ax,cx
   677 00006313 31C0                <1> 	xor	ax,ax
   678 00006315 EB02                <1> 	jmp	.do_copy
   679                              <1> 
   680                              <1> .copy_chunk:
   681 00006317 29C8                <1> 	sub	ax,cx
   682                              <1> 
   683                              <1> .do_copy:
   684 00006319 E81500              <1> 	call	.retrace_wait
   685 0000631C F3A5                <1> 	rep	movsw
   686 0000631E 09C0                <1> 	or	ax,ax
   687 00006320 75E9                <1> 	jnz	.text_full_row_loop
   688 00006322 58                  <1> 	pop	ax
   689 00006323 EBBE                <1> 	jmp	.text_fill
   690                              <1> 
   691                              <1> .text_full_row_no_snow:
   692 00006325 50                  <1> 	push	ax
   693 00006326 88D0                <1> 	mov	al,dl
   694 00006328 F6E6                <1> 	mul	dh
   695 0000632A 89C1                <1> 	mov	cx,ax
   696 0000632C F3A5                <1> 	rep	movsw
   697 0000632E 58                  <1> 	pop	ax
   698 0000632F EBB2                <1> 	jmp	.text_fill
   699                              <1> 
   700                              <1> ;-------------------------------------------------------------------------
   701                              <1> ; .retrace_wait - next till the next vertical retrace
   702                              <1> ; This is called for MDA as well as CGA BUT uses CGA Status register, MDA will hang for ever!
   703                              <1> ; May have worked if have both MDA and CGA installed!
   704                              <1> 
   705                              <1> .retrace_wait:
   706 00006331 803E490007          <1> 	cmp	byte [video_mode],7     ; MDA Don't wait for retrace
   707 00006336 7411                <1>     jz      .retrace_exit
   708                              <1> 
   709 00006338 50                  <1> 	push	ax
   710 00006339 52                  <1> 	push	dx
   711 0000633A BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
   712                              <1> 
   713                              <1> .retrace_wait_not_set:
   714 0000633D EC                  <1> 	in	al,dx
   715 0000633E A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
   716 00006340 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
   717                              <1> 
   718                              <1> .retrace_wait_set:
   719 00006342 EC                  <1> 	in	al,dx
   720 00006343 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
   721 00006345 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
   722 00006347 5A                  <1> 	pop	dx
   723 00006348 58                  <1> 	pop	ax
   724                              <1> 
   725                              <1> .retrace_exit:
   726 00006349 C3                  <1> 	ret
   727                              <1> 
   728                              <1> ;-------------------------------------------------------------------------
   729                              <1> ; .graphics_scroll - scroll for graphics modes
   730                              <1> 
   731                              <1> .graphics_scroll:
   732 0000634A 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
   733 0000634D 50                  <1> 	push	ax
   734 0000634E 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
   735 00006352 7403                <1> 	jz	.3			; jump if scroll down
   736 00006354 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
   737                              <1> 
   738                              <1> .3:
   739 00006357 E8FB03              <1> 	call	vid_gfx_pos_to_offset	
   740 0000635A 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
   741                              <1> 
   742                              <1> ; calculate scroll windows size (DX)
   743                              <1> 
   744 0000635C 5A                  <1> 	pop	dx			; DX = window's lower right corner
   745 0000635D 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
   746 00006360 81C20101            <1> 	add	dx,101h 		; add 1x1
   747 00006364 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
   748 00006366 D0E6                <1> 	shl	dh,1			;   four bytes in each plane
   749 00006368 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
   750 0000636B 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
   751 00006370 7409                <1> 	jz	.4			; jump if 640x200 mode
   752 00006372 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
   753 00006374 D1E7                <1> 	shl	di,1			; double character width for 320x200
   754 00006376 3C07                <1> 	cmp	al,07h			; check for scroll down function
   755 00006378 7509                <1> 	jnz	.5			; jump if scroll down
   756 0000637A 47                  <1> 	inc	di			; scroll up - adjust source address
   757                              <1> 
   758                              <1> .4:
   759 0000637B 3C07                <1> 	cmp	al,07h			; check for scroll down function
   760 0000637D 7504                <1> 	jnz	.5			; jump if not scroll down
   761 0000637F 81C7F000            <1> 	add	di,0F0h			; adjust destination address
   762                              <1> 					;   for copying backwards
   763                              <1> 
   764                              <1> .5:
   765 00006383 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
   766 00006386 D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
   767 00006388 D0E3                <1> 	shl	bl,1			;   four bytes in each plane
   768 0000638A 53                  <1> 	push	bx
   769 0000638B 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
   770 0000638D B050                <1> 	mov	al,50h
   771 0000638F F6E3                <1> 	mul	bl
   772 00006391 BBB01F              <1> 	mov	bx,1FB0h
   773 00006394 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
   774 00006398 7406                <1> 	jz	.6			; jump if scroll up
   775 0000639A F7D8                <1> 	neg	ax			; negate offset for scroll down
   776 0000639C BB5020              <1> 	mov	bx,2050h
   777 0000639F FD                  <1> 	std				; copy backwards
   778                              <1> 
   779                              <1> .6:
   780 000063A0 89FE                <1> 	mov	si,di
   781 000063A2 01C6                <1> 	add	si,ax			; SI = scroll copy source address
   782 000063A4 58                  <1> 	pop	ax
   783 000063A5 8CC1                <1> 	mov	cx,es
   784 000063A7 8ED9                <1> 	mov	ds,cx			; load video segment to DS
   785 000063A9 08C0                <1> 	or	al,al
   786 000063AB 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
   787 000063AD 50                  <1> 	push	ax
   788                              <1> 
   789                              <1> .graphics_scroll_loop:
   790 000063AE B500                <1> 	mov	ch,0
   791 000063B0 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
   792 000063B2 56                  <1> 	push	si
   793 000063B3 57                  <1> 	push	di
   794 000063B4 F3A4                <1> 	repz	movsb			; copy one row in the first plane
   795 000063B6 5F                  <1> 	pop	di
   796 000063B7 5E                  <1> 	pop	si
   797 000063B8 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
   798 000063BC 81C70020            <1> 	add	di,2000h
   799 000063C0 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
   800 000063C2 56                  <1> 	push	si
   801 000063C3 57                  <1> 	push	di
   802 000063C4 F3A4                <1> 	repz	movsb			; copy one row in the second plane
   803 000063C6 5F                  <1> 	pop	di
   804 000063C7 5E                  <1> 	pop	si
   805 000063C8 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
   806 000063CA 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
   807 000063CC FECE                <1> 	dec	dh			; decrement row counter
   808 000063CE 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
   809                              <1> 
   810 000063D0 58                  <1> 	pop	ax
   811 000063D1 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
   812                              <1> 
   813                              <1> .graphics_fill:
   814 000063D3 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
   815 000063D6 B500                <1> 	mov	ch,0
   816                              <1> 
   817                              <1> .graphics_fill_loop:
   818 000063D8 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
   819 000063DA 57                  <1> 	push	di
   820 000063DB F3AA                <1> 	repz	stosb			; fill one row in the first plane
   821 000063DD 5F                  <1> 	pop	di
   822 000063DE 81C70020            <1> 	add	di,2000h		; point DI to the second plane
   823 000063E2 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
   824 000063E4 57                  <1> 	push	di
   825 000063E5 F3AA                <1> 	repz	stosb			; fill one row in the second plane
   826 000063E7 5F                  <1> 	pop	di
   827 000063E8 29DF                <1> 	sub	di,bx
   828 000063EA FECE                <1> 	dec	dh			; decrement row counter
   829 000063EC 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
   830 000063EE C3                  <1> 	ret
   831                              <1> 
   832                              <1> ;=========================================================================
   833                              <1> ; int_10_fn08 - Read character and attribute
   834                              <1> ; Input:
   835                              <1> ;	AH = 08h
   836                              <1> ; Output:
   837                              <1> ;	AL - character read
   838                              <1> ;	BH - video attribute (text modes only)
   839                              <1> ; int_10_fn09 - Write character and attribute
   840                              <1> ; Input:
   841                              <1> ;	AH = 09h
   842                              <1> ;	AL - character to write
   843                              <1> ;	BH - page number
   844                              <1> ;	BL - attribute (text modes) or color (graphics modes)
   845                              <1> ;	CX - number of times to write character
   846                              <1> ; Output:
   847                              <1> ;	none
   848                              <1> ; int_10_fn0A - Write character only
   849                              <1> ; Input:
   850                              <1> ;	AH = 0Ah
   851                              <1> ;	AL - character to write
   852                              <1> ;	BH - page number
   853                              <1> ;	CX - repeat count
   854                              <1> ; Output:
   855                              <1> ;	none
   856                              <1> ;-------------------------------------------------------------------------
   857                              <1> int_10_fn08:
   858                              <1> int_10_fn09:
   859                              <1> int_10_fn0A:
   860 000063EF E8F802              <1> 	call	vid_check_mode
   861 000063F2 7303E98C00          <1> 	jc	.graphics		; jump if graphics mode
   862 000063F7 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
   863 000063FA B700                <1> 	mov	bh,0
   864 000063FC 53                  <1> 	push	bx
   865 000063FD E83D03              <1> 	call	vid_current_offset
   866 00006400 89C7                <1> 	mov	di,ax			; DI = character offset in the page
   867 00006402 58                  <1> 	pop	ax			; AX = page number
   868 00006403 F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
   869 00006407 01C7                <1> 	add	di,ax			; DI = character offset
   870 00006409 89FE                <1> 	mov	si,di			; SI = character offset
   871 0000640B 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
   872 0000640F 83C206              <1> 	add	dx,6			; DX = CGA status register
   873 00006412 1E                  <1> 	push	ds
   874 00006413 8CC3                <1> 	mov	bx,es
   875 00006415 8EDB                <1> 	mov	ds,bx			; load video segment to DS
   876 00006417 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
   877 0000641A 3C08                <1> 	cmp	al,08h			; check for read character function
   878 0000641C 7519                <1> 	jnz	.text_write		; jump if not read char (write char)
   879                              <1> 
   880                              <1> .read_retrace_wait:
   881 0000641E 803E490007          <1> 	cmp	byte [video_mode],7     ; MDA Don't wait for retrace
   882 00006423 740B                <1>         jz      .read_no_wait
   883                              <1> 
   884 00006425 EC                  <1> 	in	al,dx
   885 00006426 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
   886 00006428 75F4                <1> 	jnz	.read_retrace_wait	; jump if retrace
   887 0000642A FA                  <1> 	cli
   888                              <1> 
   889                              <1> .read_no_retrace_wait:
   890 0000642B EC                  <1> 	in	al,dx
   891 0000642C A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
   892 0000642E 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
   893                              <1> 
   894                              <1> .read_no_wait:
   895 00006430 AD                  <1> 	lodsw				; read character and attribute
   896 00006431 FB                  <1> 	sti
   897 00006432 1F                  <1> 	pop	ds
   898 00006433 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
   899 00006436 C3                  <1> 	ret
   900                              <1> 
   901                              <1> .text_write:
   902 00006437 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
   903 0000643A 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
   904 0000643D 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
   905 00006440 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
   906 00006442 741F                <1> 	jz	.text_write_char_only	; jump if write char only
   907                              <1> 
   908                              <1> .write_char_retrace:
   909 00006444 803E490007          <1> 	cmp	byte [video_mode],7     ; MDA Don't wait for retrace
   910 00006449 7410                <1>     jz      .do_write_char_attr
   911                              <1> 
   912 0000644B EC                  <1> 	in	al,dx
   913 0000644C A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
   914 0000644E 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
   915                              <1> 
   916                              <1> .write_retrace_wait1:
   917 00006450 EC                  <1> 	in	al,dx
   918 00006451 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
   919 00006453 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
   920 00006455 FA                  <1> 	cli
   921                              <1> 
   922                              <1> .write_no_retrace_wait1:
   923 00006456 EC                  <1> 	in	al,dx
   924 00006457 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
   925 00006459 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
   926                              <1> 
   927                              <1> .do_write_char_attr:
   928 0000645B 89D8                <1> 	mov	ax,bx			; AX = character / attribute
   929 0000645D AB                  <1> 	stosw				; write it to video memory
   930 0000645E FB                  <1> 	sti
   931 0000645F E2E3                <1> 	loop	.write_char_retrace	; repeat CX times
   932 00006461 1F                  <1> 	pop	ds
   933 00006462 C3                  <1> 	ret
   934                              <1> 
   935                              <1> .text_write_char_only:
   936 00006463 803E490007          <1> 	cmp	byte [video_mode],7     ; MDA Don't wait for retrace
   937 00006468 7410                <1>     jz      .do_write_char_only
   938                              <1> 
   939 0000646A EC                  <1> 	in	al,dx
   940 0000646B A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
   941 0000646D 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
   942                              <1> 
   943                              <1> .write_retrace_wait2:
   944 0000646F EC                  <1> 	in	al,dx
   945 00006470 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
   946 00006472 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
   947 00006474 FA                  <1> 	cli
   948                              <1> 
   949                              <1> .write_no_retrace_wait2:
   950 00006475 EC                  <1> 	in	al,dx
   951 00006476 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
   952 00006478 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
   953                              <1> 
   954                              <1> .do_write_char_only:
   955 0000647A 88D8                <1> 	mov	al,bl			; AL = character to write
   956 0000647C AA                  <1> 	stosb				; write it to video memory
   957 0000647D FB                  <1> 	sti
   958 0000647E 47                  <1> 	inc	di			; skip attribute
   959 0000647F E2E2                <1> 	loop	.text_write_char_only	; repeat CX times
   960 00006481 1F                  <1> 	pop	ds
   961 00006482 C3                  <1> 	ret
   962                              <1> 
   963                              <1> .graphics:
   964 00006483 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
   965 00006487 7503E9B300          <1> 	jz	.graphics_read
   966                              <1> 
   967 0000648C A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
   968 0000648F E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
   969 00006492 89C7                <1> 	mov	di,ax			; Save in displacement register
   970 00006494 1E                  <1> 	push	ds
   971 00006495 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
   972 00006498 B400                <1> 	mov	ah,0
   973 0000649A 08C0                <1> 	or	al,al			; Is it user character set?
   974 0000649C 7807                <1> 	js	.CG9_02			;  ...skip if so
   975 0000649E 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
   976 000064A0 BE[6E6A]            <1> 	mov	si,gfx_font		; load graphics font offset
   977 000064A3 EB0C                <1> 	jmp	.CG9_03
   978                              <1> 
   979                              <1> .CG9_02:
   980 000064A5 247F                <1> 	and	al,7Fh			; Origin to zero
   981 000064A7 31DB                <1> 	xor	bx,bx			;  ...then go load
   982 000064A9 8EDB                <1> 	mov	ds,bx			;  ...user graphics
   983 000064AB C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
   984 000064AF 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
   985                              <1> 
   986                              <1> .CG9_03:
   987 000064B1 1F                  <1> 	pop	ds			; Restore data segment
   988 000064B2 B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
   989 000064B4 D3E0                <1> 	shl	ax,cl
   990 000064B6 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
   991 000064B8 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
   992 000064BB 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
   993 000064C0 1E                  <1> 	push	ds
   994 000064C1 8EDA                <1> 	mov	ds,dx
   995 000064C3 7451                <1> 	jz	.CG8_02			;  ...skip if so
   996 000064C5 D1E7                <1> 	shl	di,1
   997 000064C7 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get character attribute
   998 000064CA 83E003              <1> 	and	ax,3
   999 000064CD BB5555              <1> 	mov	bx,5555h
  1000 000064D0 F7E3                <1> 	mul	bx
  1001 000064D2 89C2                <1> 	mov	dx,ax
  1002 000064D4 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Restore BL (character attribute)
  1003                              <1> 
  1004                              <1> .CG9_04:
  1005 000064D7 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  1006 000064D9 57                  <1> 	push	di
  1007 000064DA 56                  <1> 	push	si
  1008                              <1> 
  1009                              <1> .CG9_05:
  1010 000064DB AC                  <1> 	lodsb				; Read the screen
  1011 000064DC 51                  <1> 	push	cx
  1012 000064DD 53                  <1> 	push	bx
  1013 000064DE 31DB                <1> 	xor	bx,bx
  1014 000064E0 B90800              <1> 	mov	cx,8
  1015                              <1> 
  1016                              <1> .CG9_06:
  1017 000064E3 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  1018 000064E5 D1DB                <1> 	rcr	bx,1
  1019 000064E7 D1FB                <1> 	sar	bx,1
  1020 000064E9 E2F8                <1> 	loop	.CG9_06
  1021                              <1> 
  1022 000064EB 89D8                <1> 	mov	ax,bx			; Result into ax
  1023 000064ED 5B                  <1> 	pop	bx
  1024 000064EE 59                  <1> 	pop	cx
  1025 000064EF 21D0                <1> 	and	ax,dx
  1026 000064F1 86E0                <1> 	xchg	ah,al
  1027 000064F3 08DB                <1> 	or	bl,bl
  1028 000064F5 7903                <1> 	jns	.CG9_07
  1029 000064F7 263305              <1>     es	xor	ax,word [di]
  1030                              <1> 
  1031                              <1> .CG9_07:
  1032 000064FA 268905              <1>     es	mov	word [di],ax		; Write new word
  1033 000064FD 81F70020            <1> 	xor	di,2000h
  1034 00006501 F7C70020            <1> 	test	di,2000h		; Is this other plane?
  1035 00006505 7503                <1> 	jnz	.CG9_08			;  ...nope
  1036 00006507 83C750              <1> 	add	di,50h			; Else advance character
  1037                              <1> 
  1038                              <1> .CG9_08:
  1039 0000650A FECF                <1> 	dec	bh			; Show another char written
  1040 0000650C 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  1041 0000650E 5E                  <1> 	pop	si
  1042 0000650F 5F                  <1> 	pop	di
  1043 00006510 47                  <1> 	inc	di
  1044 00006511 47                  <1> 	inc	di
  1045 00006512 E2C3                <1> 	loop	.CG9_04
  1046 00006514 1F                  <1> 	pop	ds
  1047 00006515 C3                  <1> 	ret
  1048                              <1> 
  1049                              <1> .CG8_02:
  1050 00006516 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  1051 00006519 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  1052                              <1> 
  1053                              <1> .CG8_03:
  1054 0000651C B708                <1> 	mov	bh,8			; Pixel count to write
  1055 0000651E 57                  <1> 	push	di
  1056 0000651F 56                  <1> 	push	si
  1057                              <1> 
  1058                              <1> .CG8_04:
  1059 00006520 AC                  <1> 	lodsb				; Read from one plane
  1060 00006521 08DB                <1> 	or	bl,bl			;  ...done both planes?
  1061 00006523 7903                <1> 	jns	.CG8_05			;  ...skip if not
  1062 00006525 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  1063                              <1> 
  1064                              <1> .CG8_05:
  1065 00006528 268805              <1>     es	mov	byte [di],al		; Write out attribute
  1066 0000652B 31D7                <1> 	xor	di,dx			;  ...get other plane
  1067 0000652D 85D7                <1> 	test	di,dx			; Done both planes?
  1068 0000652F 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  1069 00006531 83C750              <1> 	add	di,50h			; Else position for now char
  1070                              <1> 
  1071                              <1> .CG8_06:
  1072 00006534 FECF                <1> 	dec	bh			; Show row of pixels read
  1073 00006536 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  1074 00006538 5E                  <1> 	pop	si
  1075 00006539 5F                  <1> 	pop	di
  1076 0000653A 47                  <1> 	inc	di
  1077 0000653B E2DF                <1> 	loop	.CG8_03
  1078 0000653D 1F                  <1> 	pop	ds
  1079 0000653E C3                  <1> 	ret
  1080                              <1> 
  1081                              <1> .graphics_read:
  1082 0000653F FC                  <1> 	cld				; Increment upwards
  1083 00006540 A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  1084 00006543 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  1085 00006546 89C6                <1> 	mov	si,ax			;  ...save in si
  1086 00006548 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  1087 0000654B 89E7                <1> 	mov	di,sp			;  ...save base in di
  1088 0000654D 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  1089 00006552 8CC0                <1> 	mov	ax,es
  1090 00006554 1E                  <1> 	push	ds
  1091 00006555 57                  <1> 	push	di
  1092 00006556 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  1093 00006558 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  1094 0000655A B608                <1> 	mov	dh,8			; Eight pixels high/char
  1095 0000655C D1E6                <1> 	shl	si,1
  1096 0000655E BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  1097                              <1> 
  1098                              <1> CGR_02:
  1099 00006561 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  1100 00006563 86E0                <1> 	xchg	ah,al
  1101 00006565 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  1102 00006568 B200                <1> 	mov	dl,0
  1103                              <1> 
  1104                              <1> CGR_03:
  1105 0000656A 85C8                <1> 	test	ax,cx			; Look for attributes
  1106 0000656C F8                  <1> 	clc
  1107 0000656D 7401                <1> 	jz	CGR_04			;  ...set, skip
  1108 0000656F F9                  <1> 	stc				; Else show not set
  1109                              <1> 
  1110                              <1> CGR_04:
  1111 00006570 D0D2                <1> 	rcl	dl,1
  1112 00006572 D1E9                <1> 	shr	cx,1
  1113 00006574 D1E9                <1> 	shr	cx,1
  1114 00006576 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  1115 00006578 368815              <1>     ss	mov	byte [di],dl
  1116 0000657B 47                  <1> 	inc	di
  1117 0000657C 31DE                <1> 	xor	si,bx			; Do other video plane
  1118 0000657E 85DE                <1> 	test	si,bx			;  ...done both planes?
  1119 00006580 7503                <1> 	jnz	CGR_05			;  ...no, skip
  1120 00006582 83C650              <1> 	add	si,50h			; Else advance pointer
  1121                              <1> 
  1122                              <1> CGR_05:
  1123 00006585 FECE                <1> 	dec	dh			; Show another pixel row done
  1124 00006587 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  1125 00006589 EB17                <1> 	jmp	short	CGR_08
  1126                              <1> 
  1127                              <1> CGR_06:
  1128 0000658B B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  1129                              <1> 
  1130                              <1> CGR_07:
  1131 0000658D 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  1132 0000658F 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  1133 00006592 47                  <1> 	inc	di			;  ...advance
  1134 00006593 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  1135 00006597 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  1136 0000659A 47                  <1> 	inc	di			;  ...advance
  1137 0000659B 83C650              <1> 	add	si,50h			; Total pixels in char
  1138 0000659E FECE                <1> 	dec	dh			;  ...another row processed
  1139 000065A0 75EB                <1> 	jnz	CGR_07			;  ...more to do
  1140                              <1> 
  1141                              <1> CGR_08:
  1142 000065A2 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  1143 000065A4 BF[6E6A]            <1> 	mov	di,gfx_font		;  ...and offset
  1144 000065A7 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  1145 000065A9 8CD2                <1> 	mov	dx,ss
  1146 000065AB 8EDA                <1> 	mov	ds,dx
  1147 000065AD 5E                  <1> 	pop	si
  1148 000065AE B000                <1> 	mov	al,0
  1149                              <1> 
  1150                              <1> CGR_09:
  1151 000065B0 BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  1152                              <1> 
  1153                              <1> CGR_10:
  1154 000065B3 56                  <1> 	push	si
  1155 000065B4 57                  <1> 	push	di
  1156 000065B5 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  1157 000065B8 F3A6                <1> 	repz	cmpsb			;  ...do compare
  1158 000065BA 5F                  <1> 	pop	di
  1159 000065BB 5E                  <1> 	pop	si
  1160 000065BC 741C                <1> 	jz	CGR_11			; Found graphics character
  1161 000065BE FEC0                <1> 	inc	al			;  ...else show another char
  1162 000065C0 83C708              <1> 	add	di,8			;  ...advance one row
  1163 000065C3 4A                  <1> 	dec	dx			;  ...one less char  to scan
  1164 000065C4 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  1165                              <1> 
  1166 000065C6 08C0                <1> 	or	al,al			; User graphics character set?
  1167 000065C8 7410                <1> 	jz	CGR_11			;  ...no, not found
  1168 000065CA 31DB                <1> 	xor	bx,bx			; 
  1169 000065CC 8EDB                <1> 	mov	ds,bx			; Load interrupt table segment to ES
  1170 000065CE C43E7C00            <1> 	les	di,[1Fh*4]		; Load user font for graphics 
  1171                              <1> 					; (INT 1Fh vector) to ES:SI
  1172 000065D2 8CC3                <1> 	mov	bx,es
  1173 000065D4 09FB                <1> 	or	bx,di
  1174 000065D6 7402                <1> 	jz	CGR_11			;  ...not found
  1175 000065D8 EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  1176                              <1> 
  1177                              <1> CGR_11:
  1178 000065DA 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  1179 000065DD 1F                  <1> 	pop	ds
  1180 000065DE 83C408              <1> 	add	sp,8			;  ...return temp storage
  1181 000065E1 C3                  <1> 	ret
  1182                              <1> 
  1183                              <1> ;=========================================================================
  1184                              <1> ; int_10_fn0B - Set background color or palette
  1185                              <1> ; Input:
  1186                              <1> ; 	AH - 0Bh
  1187                              <1> ;	BH = 00h - set background / border color
  1188                              <1> ;		BL - background (graphics modes) or border (text modes)
  1189                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  1190                              <1> ;		BL - palette ID:
  1191                              <1> ;			00h - background, green, red, and yellow (brown)
  1192                              <1> ;			01h - background, cyan, magenta, and white
  1193                              <1> ; Output:
  1194                              <1> ;	none
  1195                              <1> ;-------------------------------------------------------------------------
  1196                              <1> int_10_fn0B:
  1197 000065E2 A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  1198 000065E5 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  1199 000065E8 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  1200 000065EC 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  1201                              <1> 
  1202 000065EE 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  1203 000065F0 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  1204 000065F3 08E0                <1> 	or	al,ah			; apply new color
  1205 000065F5 EB09                <1> 	jmp	.write_palet_reg
  1206                              <1> 
  1207                              <1> .set_palette:
  1208 000065F7 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  1209 000065F9 F6C401              <1> 	test	ah,01h
  1210 000065FC 7402                <1> 	jz	.write_palet_reg
  1211 000065FE 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  1212                              <1> 
  1213                              <1> .write_palet_reg:
  1214 00006600 A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  1215 00006603 8B166300            <1> 	mov	dx,word [video_port]
  1216 00006607 83C205              <1> 	add	dx,5			; CRTC color select register
  1217 0000660A EE                  <1> 	out	dx,al			; send it to CRTC
  1218 0000660B C3                  <1> 	ret
  1219                              <1> 
  1220                              <1> ;=========================================================================
  1221                              <1> ; int_10_fn0C - Write graphics pixel
  1222                              <1> ; Input:
  1223                              <1> ;	AH = 0Ch
  1224                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  1225                              <1> ;	CX = column
  1226                              <1> ;	DX = row
  1227                              <1> ; Output:
  1228                              <1> ;	none
  1229                              <1> ;-------------------------------------------------------------------------
  1230                              <1> int_10_fn0C:
  1231 0000660C E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  1232 0000660F 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  1233 00006611 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  1234 00006614 88C3                <1> 	mov	bl,al			; copy color to BL
  1235 00006616 2401                <1> 	and	al,1			; one bit per pixel
  1236 00006618 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  1237 0000661A B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  1238 0000661C EB0F                <1> 	jmp	.prepare_mask
  1239                              <1> 
  1240                              <1> .mode_320x200:
  1241 0000661E D0E1                <1> 	shl	cl,1
  1242 00006620 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  1243 00006623 88C3                <1> 	mov	bl,al			; copy color to BL
  1244 00006625 2403                <1> 	and	al,3			; two bit per pixel
  1245 00006627 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  1246 00006629 D0C8                <1> 	ror	al,1
  1247 0000662B B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  1248                              <1> 
  1249                              <1> .prepare_mask:
  1250 0000662D D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  1251 0000662F D2E8                <1> 	shr	al,cl			; position color bits correctly
  1252 00006631 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  1253 00006634 08DB                <1> 	or	bl,bl			; check if bit 7 set
  1254 00006636 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  1255 00006638 30C1                <1> 	xor	cl,al			; else XOR with existing color
  1256 0000663A EB04                <1> 	jmp	.write_pixel
  1257                              <1> 
  1258                              <1> .set_color:
  1259 0000663C 20E1                <1> 	and	cl,ah			; clear existing color bits
  1260 0000663E 08C1                <1> 	or	cl,al			; set new color bits
  1261                              <1> 
  1262                              <1> .write_pixel:
  1263 00006640 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  1264 00006643 C3                  <1> 	ret
  1265                              <1> 
  1266                              <1> ;=========================================================================
  1267                              <1> ; int_10_fn0D - Read graphics pixel
  1268                              <1> ; Input:
  1269                              <1> ;	AH = 0Dh
  1270                              <1> ;	CX = column
  1271                              <1> ;	DX = row
  1272                              <1> ; Output:
  1273                              <1> ;	AL = pixel color 
  1274                              <1> ;-------------------------------------------------------------------------
  1275                              <1> int_10_fn0D:
  1276 00006644 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  1277 00006647 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  1278 0000664A 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  1279 0000664C D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  1280 0000664E D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  1281 00006650 2401                <1> 	and	al,1			; one bit per pixel
  1282 00006652 EB0A                <1> 	jmp	.exit
  1283                              <1> 
  1284                              <1> .mode_320x200:
  1285 00006654 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  1286 00006656 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  1287 00006658 D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  1288 0000665A D0C0                <1> 	rol	al,1
  1289 0000665C 2403                <1> 	and	al,3			; two bits per pixel
  1290                              <1> 
  1291                              <1> .exit:
  1292 0000665E 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  1293 00006661 C3                  <1> 	ret
  1294                              <1> 
  1295                              <1> ;=========================================================================
  1296                              <1> ; int_10_fn0E - Teletype output
  1297                              <1> ; Input:
  1298                              <1> ;	AH = 0Eh
  1299                              <1> ;	AL = character to write
  1300                              <1> ;	BL = foreground color (graphics modes only)
  1301                              <1> ; Output:
  1302                              <1> ;	none
  1303                              <1> ; Notes:
  1304                              <1> ;	- writes character to the active video page
  1305                              <1> ;	- support following control characters: BEL, BS, LF, CR
  1306                              <1> ; NOTE Doesn't work with MDA when CGA not installed, CGA SNOW check waits for sync for ever!
  1307                              <1> ;-------------------------------------------------------------------------
  1308                              <1> int_10_fn0E:
  1309 00006662 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  1310 00006666 B700                <1> 	mov	bh,0
  1311 00006668 D0E3                <1> 	shl	bl,1			; word index
  1312 0000666A 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  1313                              <1> 
  1314 0000666D 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  1315 00006670 3C08                <1> 	cmp	al,bs
  1316 00006672 7429                <1> 	jz	.bs			; jump if backspace (BS)
  1317 00006674 3C0A                <1> 	cmp	al,lf
  1318 00006676 741C                <1> 	jz	.lf			; jump if line feed (LF)
  1319 00006678 3C07                <1> 	cmp	al,bel
  1320 0000667A 7433                <1> 	jz	.bel			; jump if beep (BEL)
  1321 0000667C 3C0D                <1> 	cmp	al,cr
  1322 0000667E 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  1323 00006680 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  1324 00006683 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  1325 00006685 B90100              <1> 	mov	cx,1			; one character
  1326 00006688 CD10                <1> 	int	10h			; write character
  1327 0000668A FEC2                <1> 	inc	dl			; move cursor to the next column
  1328 0000668C 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  1329 00006690 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  1330 00006692 B200                <1> 	mov	dl,0			; move to the first position
  1331                              <1> 
  1332                              <1> .lf:
  1333 00006694 80FE18              <1> 	cmp	dh,24			; on the last row?
  1334 00006697 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  1335 00006699 FEC6                <1> 	inc	dh			; move cursor to the next row
  1336 0000669B 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  1337                              <1> 
  1338                              <1> .bs:
  1339 0000669D 80FA00              <1> 	cmp	dl,0			; on the first column?
  1340 000066A0 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  1341 000066A2 FECA                <1> 	dec	dl			; move cursor to the previous position
  1342 000066A4 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  1343                              <1> 
  1344                              <1> .cr:
  1345 000066A6 B200                <1> 	mov	dl,0			; set cursor to the first column
  1346                              <1> 
  1347                              <1> .set_cursor_pos:
  1348 000066A8 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  1349 000066AC E92BFB              <1> 	jmp	set_cur_pos		; set new cursor position
  1350                              <1> 
  1351                              <1> .bel:
  1352 000066AF B302                <1> 	mov	bl,2			; 0.2 second beep
  1353 000066B1 E8B2C0              <1> 	call	beep
  1354 000066B4 C3                  <1> 	ret
  1355                              <1> 
  1356                              <1> .scroll:
  1357 000066B5 B402                <1> 	mov	ah,02h
  1358 000066B7 CD10                <1> 	int	10h			; set new cursor position
  1359 000066B9 E82E00              <1> 	call	vid_check_mode          ; CF Graphics Text, ZF MDA
  1360 000066BC B700                <1> 	mov	bh,0
  1361 000066BE 7206                <1> 	jc	.do_scroll		; jump if text (actually graphics) mode - do scroll
  1362 000066C0 B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  1363 000066C2 CD10                <1> 	int	10h			; read attirbute at current position
  1364 000066C4 88E7                <1> 	mov	bh,ah                   ; bh now has text attribute for new row
  1365                              <1> 
  1366                              <1> .do_scroll:
  1367 000066C6 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  1368 000066C8 B001                <1> 	mov	al,1			; scroll one line
  1369 000066CA 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  1370 000066CC B618                <1> 	mov	dh,24			; bottom row is 24
  1371 000066CE 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  1372 000066D2 FECA                <1> 	dec	dl
  1373 000066D4 CD10                <1> 	int	10h			; scroll page up
  1374 000066D6 C3                  <1> 	ret
  1375                              <1> 
  1376                              <1> ;=========================================================================
  1377                              <1> ; int_10_fn0F - Get current video mode
  1378                              <1> ; Input:
  1379                              <1> ;	AH = 0Fh
  1380                              <1> ; Output:
  1381                              <1> ;	AL = video mode
  1382                              <1> ;	AH = characters per column
  1383                              <1> ;	BH = active video page
  1384                              <1> ;-------------------------------------------------------------------------
  1385                              <1> int_10_fn0F:
  1386 000066D7 A04A00              <1> 	mov	al,byte [video_columns]
  1387 000066DA 884601              <1> 	mov	byte [bp+int_10_ah],al
  1388 000066DD A04900              <1> 	mov	al,byte [video_mode]
  1389 000066E0 884600              <1> 	mov	byte [bp+int_10_al],al
  1390 000066E3 A06200              <1> 	mov	al,byte [video_page]
  1391 000066E6 884603              <1> 	mov	byte [bp+int_10_bh],al
  1392 000066E9 C3                  <1> 	ret
  1393                              <1> 
  1394                              <1> ;=========================================================================
  1395                              <1> ; vid_check_mode - Check current video mode
  1396                              <1> ; Input:
  1397                              <1> ;	none
  1398                              <1> ; Output:
  1399                              <1> ;	ZF set if monochrome mode (mode 07h)
  1400                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  1401                              <1> ;-------------------------------------------------------------------------
  1402                              <1> vid_check_mode:
  1403 000066EA 50                  <1> 	push	ax
  1404 000066EB A04900              <1> 	mov	al,byte [video_mode]
  1405 000066EE 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  1406 000066F0 7408                <1> 	jz	.exit			; jump if monochrome
  1407 000066F2 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  1408 000066F4 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  1409 000066F5 7303                <1> 	jnc	.exit			; jump if not graphics (CF = 0, ZF = 0)
  1410 000066F7 18C0                <1> 	sbb	al,al			; AL=AL-(AL+CF) set CF and clear ZF?
  1411 000066F9 F9                  <1> 	stc				; set CF back
  1412                              <1> 
  1413                              <1> .exit:
  1414 000066FA 58                  <1> 	pop	ax
  1415 000066FB C3                  <1> 	ret
  1416                              <1> 
  1417                              <1> ;=========================================================================
  1418                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  1419                              <1> ; Input:
  1420                              <1> ;	AH = register number
  1421                              <1> ;	CX = word to write
  1422                              <1> ; Output:
  1423                              <1> ;	AX trashed
  1424                              <1> ; Note:
  1425                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  1426                              <1> ;-------------------------------------------------------------------------
  1427                              <1> vid_crtc_writew:
  1428 000066FC 88E8                <1> 	mov	al,ch
  1429 000066FE E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  1430 00006701 FEC4                <1> 	inc	ah			; point AH to the next register
  1431 00006703 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  1432                              <1> 
  1433                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  1434                              <1> 
  1435                              <1> ;=========================================================================
  1436                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  1437                              <1> ; Input:
  1438                              <1> ;	AH = register number
  1439                              <1> ;	AL = byte to write
  1440                              <1> ; Output:
  1441                              <1> ;	none
  1442                              <1> ;-------------------------------------------------------------------------
  1443                              <1> vid_crtc_writeb:
  1444 00006705 52                  <1> 	push	dx
  1445 00006706 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
  1446 0000670A 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  1447 0000670C EE                  <1> 	out	dx,al			; write register number
  1448 0000670D 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  1449 0000670F FEC2                <1> 	inc	dl			; DX = CRTC data port
  1450 00006711 EE                  <1> 	out	dx,al			; write byte
  1451 00006712 5A                  <1> 	pop	dx
  1452 00006713 C3                  <1> 	ret
  1453                              <1> 
  1454                              <1> ;=========================================================================
  1455                              <1> ; vid_pixel_address - calculate pixel address and mask
  1456                              <1> ; Input:
  1457                              <1> ;	CX - column
  1458                              <1> ;	DX - row
  1459                              <1> ; Output:
  1460                              <1> ;	SI - pixel address
  1461                              <1> ;	CH - pixel mask
  1462                              <1> ;	CL - pixel position in the byte
  1463                              <1> ;	ZF - mode
  1464                              <1> ;		0 = 320x200
  1465                              <1> ;		1 = 640x200
  1466                              <1> ;-------------------------------------------------------------------------
  1467                              <1> vid_pixel_address:
  1468 00006714 31F6                <1> 	xor	si,si			; SI = 0
  1469 00006716 D0EA                <1> 	shr	dl,1			; divide row by two
  1470 00006718 7303                <1> 	jnb	.even			; jump if on even row 
  1471 0000671A BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  1472                              <1> 
  1473                              <1> .even:
  1474 0000671D B050                <1> 	mov	al,50h			; bytes in each row
  1475 0000671F F6E2                <1> 	mul	dl			; AX - address of the row
  1476                              <1> 
  1477 00006721 01C6                <1> 	add	si,ax			; add row address to SI
  1478 00006723 89CA                <1> 	mov	dx,cx			; DX - column
  1479 00006725 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  1480 00006728 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  1481 0000672D 9C                  <1> 	pushf				; save ZF (and other flags
  1482 0000672E 7503                <1> 	jnz	.1			; skip if not 640x200
  1483 00006730 B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  1484                              <1> 
  1485                              <1> .1:
  1486 00006733 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  1487 00006735 D3EA                <1> 	shr	dx,cl			; DX = address of the column
  1488 00006737 01D6                <1> 	add	si,dx			; add column address to SI
  1489 00006739 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  1490 0000673B 9D                  <1> 	popf
  1491 0000673C C3                  <1> 	ret
  1492                              <1> 
  1493                              <1> ;=========================================================================
  1494                              <1> ; vid_current_offset - convert current cursor position to offset
  1495                              <1> ;		       relative to page starting address
  1496                              <1> ; Input:
  1497                              <1> ;	BL = page
  1498                              <1> ; Output:
  1499                              <1> ;	AX = offset
  1500                              <1> ;-------------------------------------------------------------------------
  1501                              <1> vid_current_offset:
  1502 0000673D B700                <1> 	mov	bh,0
  1503 0000673F D1E3                <1> 	shl	bx,1				; word index
  1504 00006741 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  1505                              <1> 
  1506                              <1> ; fall through to vid_position_to_offset
  1507                              <1> 
  1508                              <1> ;=========================================================================
  1509                              <1> ; vid_position_to_offset - convert position (row and column) to offset
  1510                              <1> ;			   relative to page starting address
  1511                              <1> ; Input:
  1512                              <1> ;	AH = row
  1513                              <1> ;	AL = column
  1514                              <1> ; Output:
  1515                              <1> ;	AX = offset
  1516                              <1> ;-------------------------------------------------------------------------
  1517                              <1> vid_position_to_offset:
  1518 00006744 53                  <1> 	push	bx
  1519 00006745 88C3                <1> 	mov	bl,al			; BL = column
  1520 00006747 88E0                <1> 	mov	al,ah			; AL = row
  1521 00006749 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  1522 0000674D B700                <1> 	mov	bh,0			;
  1523 0000674F 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  1524 00006751 D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  1525 00006753 5B                  <1> 	pop	bx
  1526 00006754 C3                  <1> 	ret
  1527                              <1> 
  1528                              <1> ;=========================================================================
  1529                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  1530                              <1> ; Input:
  1531                              <1> ;	AH = row
  1532                              <1> ;	AL = column
  1533                              <1> ; Output:
  1534                              <1> ;	AX = offset
  1535                              <1> ;-------------------------------------------------------------------------
  1536                              <1> vid_gfx_pos_to_offset:
  1537 00006755 53                  <1> 	push	bx
  1538 00006756 88C3                <1> 	mov	bl,al			; BL = column
  1539 00006758 88E0                <1> 	mov	al,ah			; AL = row
  1540 0000675A F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  1541 0000675E D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  1542 00006760 D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  1543 00006762 B700                <1> 	mov	bh,0
  1544 00006764 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  1545 00006766 5B                  <1> 	pop	bx
  1546 00006767 C3                  <1> 	ret
  1547                              <1> 
  1414                                  
  1415                                  ;=========================================================================
  1416                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  1417                                  ;-------------------------------------------------------------------------
  1418                                  
  1419                                  detect_rom_ext:
  1420 00006768 B040                    	mov	al,e_ext_start		; ROM extension scan start
  1421 0000676A E680                    	out	post_reg,al
  1422 0000676C E421                    	in	al,pic1_reg1		; get IMR (option ROMs may trash it)
  1423 0000676E 50                      	push	ax			; save it
  1424 0000676F BA00C8                  	mov	dx,0C800h
  1425                                  ;	mov	bx,0F800h
  1426 00006772 BB00F9                  	mov	bx,0F900h       ; Extend scan for XT IDE BIOS located from F8000-F8FFF
  1427                                  %ifdef BIOS_SETUP
  1428 00006775 E848A6                  	call	get_config_a
  1429 00006778 A804                    	test	al,nvram_ext_scan
  1430 0000677A 7403                    	jz	.ext_scan_loop		; ext_scan clear - scan till F8000
  1431 0000677C BB00F0                  	mov	bx,0F000h		; ext_scan set - scan till F0000
  1432                                  %endif ; BIOS_SETUP
  1433                                  
  1434                                  .ext_scan_loop:
  1435 0000677F E8DA00                  	call	extension_scan
  1436 00006782 833E670000              	cmp	word [67h],0
  1437 00006787 7429                    	jz	.ext_scan_done		; No ROM extension found
  1438 00006789 B041                    	mov	al,e_ext_detect		; ROM extension found
  1439 0000678B E680                    	out	post_reg,al
  1440 0000678D BE[D903]                	mov	si,msg_rom_found
  1441 00006790 E81DC1                  	call	print
  1442 00006793 A16900                  	mov	ax,word [69h]		; ROM extension's segment
  1443 00006796 E832C1                  	call	print_hex
  1444 00006799 BE[F603]                	mov	si,msg_rom_init
  1445 0000679C E811C1                  	call	print
  1446 0000679F 53                      	push	bx
  1447 000067A0 52                      	push	dx
  1448 000067A1 FF1E6700                	call	far [67h]
  1449 000067A5 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1450 000067A8 8ED8                    	mov	ds,ax
  1451 000067AA B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  1452 000067AC E680                    	out	post_reg,al
  1453 000067AE 5A                      	pop	dx
  1454 000067AF 5B                      	pop	bx
  1455 000067B0 EBCD                    	jmp	.ext_scan_loop
  1456                                  
  1457                                  .ext_scan_done:
  1458 000067B2 58                      	pop	ax			; get previous IMR
  1459 000067B3 E621                    	out	pic1_reg1,al		; restore it
  1460 000067B5 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  1461 000067B7 E680                    	out	post_reg,al
  1462                                  
  1463 000067B9 C3                      	ret
  1464                                  
  1465                                  ;=========================================================================
  1466                                  ; detect_ram - Determine the size of installed RAM and test it
  1467                                  ; Input:
  1468                                  ;	none
  1469                                  ; Output:
  1470                                  ;	AX = RAM size
  1471                                  ;	CX, SI - trashed
  1472                                  ;-------------------------------------------------------------------------
  1473                                  detect_ram:
  1474 000067BA B030                    	mov	al,e_ram_start		; RAM scan start
  1475 000067BC E680                    	out	post_reg,al
  1476                                  
  1477 000067BE 1E                      	push	ds
  1478 000067BF B106                    	mov	cl,6			; for SHL - converting KiB to segment
  1479 000067C1 B82000                  	mov	ax,MIN_RAM_SIZE
  1480                                  
  1481                                  .fill_loop:
  1482 000067C4 50                      	push	ax
  1483 000067C5 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1484 000067C7 8ED8                    	mov	ds,ax
  1485 000067C9 A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  1486 000067CC 58                      	pop	ax
  1487 000067CD 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1488 000067D0 3D0002                  	cmp	ax,MAX_RAM_SIZE
  1489 000067D3 75EF                    	jne	.fill_loop
  1490 000067D5 B82000                  	mov	ax,MIN_RAM_SIZE
  1491                                  
  1492                                  .size_loop:
  1493 000067D8 50                      	push	ax
  1494 000067D9 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1495 000067DB 8ED8                    	mov	ds,ax
  1496 000067DD 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  1497 000067E1 750B                    	jne	.size_done
  1498 000067E3 58                      	pop	ax
  1499 000067E4 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1500 000067E7 3D0002                  	cmp	ax,MAX_RAM_SIZE
  1501 000067EA 7303                    	jnb	.size_exit
  1502 000067EC EBEA                    	jmp	.size_loop
  1503                                  
  1504                                  .size_done:
  1505 000067EE 58                      	pop	ax
  1506                                  
  1507                                  .size_exit:
  1508 000067EF 1F                      	pop	ds
  1509 000067F0 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  1510 000067F3 C3                      	ret
  1511                                  
  1512                                  ;=========================================================================
  1513                                  ; int_12 - Get memory size
  1514                                  ; Input:
  1515                                  ;	none
  1516                                  ; Output:
  1517                                  ;	AX = memory size
  1518                                  ;-------------------------------------------------------------------------
  1519                                  ;	setloc	0F841h			; INT 12 Entry Point
  1520                                  int_12:
  1521 000067F4 FB                      	sti
  1522 000067F5 1E                      	push	ds
  1523 000067F6 B84000                  	mov	ax,biosdseg
  1524 000067F9 8ED8                    	mov	ds,ax
  1525 000067FB A11300                  	mov	ax,word [memory_size]
  1526 000067FE 1F                      	pop	ds
  1527 000067FF CF                      	iret
  1528                                  
  1529                                  ;=========================================================================
  1530                                  ; int_11 - Get equipment list
  1531                                  ; Input:
  1532                                  ;	none
  1533                                  ; Output:
  1534                                  ;	AX = equipment list
  1535                                  ;-------------------------------------------------------------------------
  1536                                  ;	setloc	0F84Dh			; INT 11 Entry Point
  1537                                  int_11:
  1538 00006800 FB                      	sti
  1539 00006801 1E                      	push	ds
  1540 00006802 B84000                  	mov	ax,biosdseg
  1541 00006805 8ED8                    	mov	ds,ax
  1542 00006807 A11000                  	mov	ax,word [equipment_list]
  1543 0000680A 1F                      	pop	ds
  1544 0000680B CF                      	iret
  1545                                  
  1546                                  ;=========================================================================
  1547                                  ; Includes with fixed entry points (for IBM compatibility)
  1548                                  ;-------------------------------------------------------------------------
  1549                                  
  1550                                  %include	"misc.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; misc.inc - Miscellaneous BIOS Services
     3                              <1> ;       INT 15h, functions:
     4                              <1> ;       	4Fh	- OS hook keyboard intercept
     5                              <1> ;		90h	- Device busy loop
     6                              <1> ;		91h	- Interrupt completed
     7                              <1> ;		0C0h	- Get system configruation
     8                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
     9                              <1> ;		
    10                              <1> ;-------------------------------------------------------------------------
    11                              <1> ;
    12                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    13                              <1> ;
    14                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    15                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    16                              <1> ;
    17                              <1> ; This program is free software: you can redistribute it and/or modify
    18                              <1> ; it under the terms of the GNU General Public License as published by
    19                              <1> ; the Free Software Foundation, either version 3 of the License, or
    20                              <1> ; (at your option) any later version.
    21                              <1> ;
    22                              <1> ; This program is distributed in the hope that it will be useful,
    23                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    24                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    25                              <1> ; GNU General Public License for more details.
    26                              <1> ;
    27                              <1> ; You should have received a copy of the GNU General Public License
    28                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    29                              <1> ;
    30                              <1> ;=========================================================================
    31                              <1> 
    32                              <1> ;-------------------------------------------------------------------------
    33                              <1> ; offsets for registers on stack
    34                              <1> int_15_bp	equ	0
    35                              <1> int_15_ip	equ	int_15_bp+2
    36                              <1> int_15_cs	equ	int_15_ip+2
    37                              <1> int_15_flags	equ	int_15_cs+2
    38                              <1> 
    39                              <1> ;=========================================================================
    40                              <1> ; int_15 - Miscellaneous BIOS services
    41                              <1> ; Input:
    42                              <1> ;	AH = 4Fh - OS hook keyboard intercept
    43                              <1> ;		- Does nothing
    44                              <1> ;	AH = 0C2h - PS/2 mouse services
    45                              <1> ;		- Implemented in ps2aux.inc
    46                              <1> ;-------------------------------------------------------------------------
    47                              <1> ;	setloc	0F859h			; INT 15 Entry Point
    48                              <1> ;	setloc	0F85Ah			; INT 15 Entry Point - Modified for BBPC to allow VGA palette DAC initialisation
    49                              <1> int_15:
    50 0000680C FB                  <1> 	sti
    51 0000680D 80FC4F              <1> 	cmp	ah,4Fh
    52 00006810 7432                <1> 	je	int_15_exit		; continue with int 09h ISR
    53 00006812 80FCC0              <1> 	cmp	ah,0C0h
    54 00006815 742E                <1> 	je	int_15_fnC0
    55 00006817 3D0190              <1> 	cmp	ax,9001h
    56 0000681A 7426                <1> 	je	int_15_os_hook		; diskette - device busy hook
    57 0000681C 3DFD90              <1> 	cmp	ax,90FDh
    58 0000681F 7421                <1> 	je	int_15_os_hook		; diskette - motor start hook
    59 00006821 3D0191              <1> 	cmp	ax,9101h
    60 00006824 741C                <1> 	je	int_15_os_hook		; diskette - interrupt completed
    61                              <1> 
    62                              <1> %ifdef PS2_MOUSE
    63 00006826 80FCC2              <1> 	cmp	ah,0C2h
    64 00006829 7503                <1> 	jne	.1
    65 0000682B E957BC              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
    66                              <1> .1:
    67                              <1> %endif
    68                              <1> 
    69 0000682E B486                <1> 	mov	ah,86h			; no cassete present
    70                              <1> 
    71                              <1> int_15_err:
    72 00006830 55                  <1> 	push	bp
    73 00006831 89E5                <1> 	mov	bp,sp
    74 00006833 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
    75 00006837 5D                  <1> 	pop	bp
    76 00006838 CF                  <1> 	iret
    77                              <1> 
    78                              <1> int_15_ok:
    79 00006839 55                  <1> 	push	bp
    80 0000683A 89E5                <1> 	mov	bp,sp
    81 0000683C 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
    82 00006840 5D                  <1> 	pop	bp
    83 00006841 CF                  <1> 	iret
    84                              <1> 
    85                              <1> int_15_os_hook:
    86 00006842 B400                <1> 	mov	ah,00h
    87                              <1> 
    88                              <1> int_15_exit:
    89 00006844 CF                  <1> 	iret
    90                              <1> 
    91                              <1> ;=========================================================================
    92                              <1> ; int_15_fnC0 - Get configuration
    93                              <1> ; Input:
    94                              <1> ;	AH = 0C0h - get configuration
    95                              <1> ; Output:
    96                              <1> ;	AH = 00h - function supported
    97                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
    98                              <1> ;	CF = 0 (success)
    99                              <1> ; Add debug output to POST
   100                              <1> ;-------------------------------------------------------------------------
   101                              <1> int_15_fnC0:
   102 00006845 B400                <1> 	mov	ah,00h
   103 00006847 50                  <1> 	push ax
   104 00006848 B0C0                <1> 	mov al,0C0h
   105 0000684A E680                <1> 	out	post_reg,al
   106 0000684C BB00F0              <1> 	mov	bx,bioscseg
   107 0000684F 8EC3                <1> 	mov	es,bx
   108 00006851 BB[F556]            <1> 	mov	bx,config_table
   109 00006854 8A4705              <1> 	mov al, [BX+5] ; Feature Byte from Config Table
   110 00006857 E680                <1> 	out	post_reg,al
   111 00006859 58                  <1>     pop ax	
   112 0000685A EBDD                <1> 	jmp	int_15_ok
  1551                                  
  1552                                  ;=========================================================================
  1553                                  ; extension_scan - scan for BIOS extensions
  1554                                  ; Input:
  1555                                  ;	DX - start segment
  1556                                  ;	BX - end segment
  1557                                  ; Returns:
  1558                                  ;	DX - address for the continuation of the scan
  1559                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  1560                                  ;-------------------------------------------------------------------------
  1561                                  extension_scan:
  1562 0000685C C70667000000            	mov	word [67h],0
  1563 00006862 C70669000000            	mov	word [69h],0
  1564                                  .scan:
  1565 00006868 8EC2                    	mov	es,dx
  1566 0000686A 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  1567 00006871 7532                    	jnz	.next			; no signature, check next 2 KiB
  1568 00006873 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  1569 00006877 B400                    	mov	ah,0
  1570 00006879 B105                    	mov	cl,5
  1571 0000687B D3E0                    	shl	ax,cl			; convert size to paragraphs
  1572 0000687D 01C2                    	add	dx,ax
  1573 0000687F 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  1574 00006882 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  1575 00006885 B104                    	mov	cl,4
  1576 00006887 D3E0                    	shl	ax,cl			; convert size to bytes
  1577 00006889 89C1                    	mov	cx,ax
  1578 0000688B B000                    	mov	al,0
  1579 0000688D 31F6                    	xor	si,si
  1580                                  .checksum:
  1581 0000688F 260204                      es	add	al,byte [si]
  1582 00006892 46                      	inc	si
  1583 00006893 E2FA                    	loop	.checksum
  1584 00006895 08C0                    	or	al,al			; AL == 0?
  1585 00006897 750C                    	jnz	.next			; AL not zero - bad checksum
  1586 00006899 C70667000300            	mov	word [67h],3		; extension initialization offset
  1587 0000689F 8C066900                	mov	word [69h],es		; extension segment
  1588 000068A3 EB08                    	jmp	.exit
  1589                                  .next:
  1590 000068A5 81C28000                	add	dx,80h			; add 2 KiB
  1591 000068A9 39DA                    	cmp	dx,bx
  1592 000068AB 72BB                    	jb	.scan
  1593                                  .exit:
  1594 000068AD C3                      	ret
  1595                                  
  1596                                  ;=========================================================================
  1597                                  ; ipl - Initial Program Load - try to read and execute boot sector
  1598                                  ;-------------------------------------------------------------------------
  1599                                  ipl:
  1600 000068AE FB                      	sti
  1601 000068AF 31C0                    	xor	ax,ax
  1602 000068B1 8ED8                    	mov	ds,ax
  1603 000068B3 C7067800[C75F]          	mov	word [78h],int_1E	; set Floppy Parameters Table location
  1604 000068B9 8C0E7A00                	mov	word [7Ah],cs
  1605                                  
  1606                                  .boot_retry:
  1607 000068BD B90400                  	mov	cx,4			; retry booting from floppy 4 times
  1608                                  
  1609                                  .fd_read_retry:
  1610 000068C0 51                      	push	cx
  1611 000068C1 B0D0                    	mov	al, 0xD0		; Floppy Disk Reset
  1612 000068C3 E680                    	out	post_reg,al
  1613                                    
  1614 000068C5 B400                    	mov	ah,00h			; reset disk system
  1615 000068C7 B200                    	mov	dl,00h			; drive 0
  1616 000068C9 CD13                    	int	13h
  1617 000068CB 722A                    	jb	.fd_failed
  1618 000068CD B0D1                    	mov	al, 0xD1		; Floppy Disk Drive Parameters
  1619 000068CF E680                    	out	post_reg,al
  1620                                  
  1621 000068D1 B408                    	mov	ah,08h			; get drive parameters
  1622 000068D3 B200                    	mov	dl,00h			; drive 0
  1623 000068D5 CD13                    	int	13h
  1624 000068D7 721E                    	jc	.fd_failed
  1625 000068D9 80FA00                  	cmp	dl,00h
  1626 000068DC 7448                    	jz	.try_hdd		; jump if zero drives
  1627 000068DE 7460                    	jz	.check_signature		; jump if zero drives
  1628 000068E0 B0D2                    	mov	al, 0xD2		; Read Boot Sector
  1629 000068E2 E680                    	out	post_reg,al
  1630                                    
  1631 000068E4 B80102                  	mov	ax,0201h		; read one sector
  1632 000068E7 31D2                    	xor	dx,dx			; head 0, drive 0
  1633 000068E9 8EC2                    	mov	es,dx			; to 0000:7C00
  1634 000068EB BB007C                  	mov	bx,7C00h
  1635 000068EE B90100                  	mov	cx,0001h		; track 0, sector 1
  1636 000068F1 CD13                    	int	13h
  1637 000068F3 7202                    	jc	.fd_failed
  1638 000068F5 EB49                    	jmp	.check_signature	; read successful, check for boot sector
  1639                                  
  1640                                  .fd_failed:
  1641 000068F7 59                      	pop	cx
  1642 000068F8 B0DF                    	mov	al, 0xDF		; Floppy Disk Failed
  1643 000068FA E680                    	out	post_reg,al
  1644 000068FC A04100                      mov	al, [fdc_last_error]    ;Last Error
  1645 000068FF E680                    	out	post_reg,al
  1646 00006901 A04200                      mov	al, [fdc_ctrl_status]   ;ST0
  1647 00006904 E680                    	out	post_reg,al
  1648 00006906 A04300                      mov	al, [fdc_ctrl_status+1] ;ST1
  1649 00006909 E680                    	out	post_reg,al
  1650 0000690B A04400                      mov	al, [fdc_ctrl_status+2] ;ST2 
  1651 0000690E E680                    	out	post_reg,al
  1652 00006910 A04500                      mov	al, [fdc_ctrl_status+3] ;Cylinder
  1653 00006913 E680                    	out	post_reg,al
  1654 00006915 A04600                      mov	al, [fdc_ctrl_status+4] ;Head
  1655 00006918 E680                    	out	post_reg,al
  1656 0000691A A04700                      mov	al, [fdc_ctrl_status+5] ;Record (sector)
  1657 0000691D E680                    	out	post_reg,al
  1658 0000691F A04800                      mov	al, [fdc_ctrl_status+6] ;Number Bytes
  1659 00006922 E680                    	out	post_reg,al
  1660 00006924 E29A                    	loop	.fd_read_retry
  1661                                  
  1662                                  ; try booting from HDD
  1663                                  .try_hdd:
  1664 00006926 B40D                    	mov	ah,0Dh			; reset hard disks
  1665 00006928 B280                    	mov	dl,80h			; drive 80h
  1666 0000692A CD13                    	int	13h
  1667 0000692C 7224                    	jc	.boot_failed
  1668 0000692E B80102                  	mov	ax,0201h		; read one sector
  1669 00006931 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  1670 00006934 31C9                    	xor	cx,cx
  1671 00006936 8EC1                    	mov	es,cx
  1672 00006938 BB007C                  	mov	bx,7C00h		; to 0000:7C00
  1673 0000693B 41                      	inc	cx			; CX == 0001h; track 0, sector 1
  1674 0000693C CD13                    	int	13h
  1675 0000693E 7212                    	jc	.boot_failed
  1676                                  
  1677                                  .check_signature:
  1678 00006940 B0C0                    	mov	al, 0xC0		; Check Signature
  1679 00006942 E680                    	out	post_reg,al
  1680 00006944 26813EFE7D55AA            es	cmp	word [7DFEh],0AA55h
  1681 0000694B 7505                    	jnz	.boot_failed		; boot sector signature not found
  1682 0000694D EA007C0000              	jmp	0000h:7C00h		; jump to the boot sector
  1683                                  
  1684                                  .boot_failed:
  1685 00006952 BE[9D03]                	mov	si,msg_boot_failed
  1686 00006955 E858BF                  	call	print
  1687 00006958 B0CF                    	mov	al, 0xCF		; Boot Failed
  1688 0000695A E680                    	out	post_reg,al
  1689 0000695C B400                    	mov	ah,00h
  1690 0000695E CD16                    	int	16h         ; Wait for a key press
  1691 00006960 E95AFF                  	jmp	.boot_retry
  1692                                  
  1693                                  ;=========================================================================
  1694                                  ; test_ram - Test installed RAM
  1695                                  ; Input:
  1696                                  ;	AX = detected RAM size
  1697                                  ; Output:
  1698                                  ;	AX = tested RAM size
  1699                                  ;	CX, SI - trashed
  1700                                  ;-------------------------------------------------------------------------
  1701                                  test_ram:
  1702 00006963 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  1703 00006969 747D                    	je	.test_done
  1704                                  
  1705                                  %ifdef BIOS_SETUP
  1706 0000696B 50                      	push	ax
  1707 0000696C E851A4                  	call	get_config_a
  1708 0000696F A808                    	test	al,nvram_mem_test
  1709 00006971 58                      	pop	ax
  1710 00006972 7574                    	jnz	.test_done		; mem_test set - skip memory test
  1711                                  %endif ; BIOS_SETUP
  1712                                  
  1713 00006974 BE[FD02]                	mov	si,msg_ram_testing
  1714 00006977 E836BF                  	call	print
  1715 0000697A B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  1716                                  
  1717                                  .test_loop:
  1718 0000697D 50                      	push	ax
  1719 0000697E B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  1720 00006980 B700                    	mov	bh,00h			; page 0
  1721 00006982 CD10                    	int	10h			; position returned in DX
  1722 00006984 58                      	pop	ax
  1723 00006985 E865BF                  	call	print_dec
  1724 00006988 50                      	push	ax
  1725 00006989 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  1726 0000698B B700                    	mov	bh,00h			; page 0
  1727 0000698D CD10                    	int	10h
  1728 0000698F B401                    	mov	ah,01h
  1729 00006991 CD16                    	int	16h
  1730 00006993 7412                    	jz	.test_no_key
  1731 00006995 B400                    	mov	ah,00h
  1732 00006997 CD16                    	int	16h			; read the keystroke
  1733 00006999 3C1B                    	cmp	al,1Bh			; ESC?
  1734 0000699B 7421                    	je	.test_esc
  1735 0000699D 3D003B                  	cmp	ax,3B00h		; F1?
  1736 000069A0 7505                    	jne	.test_no_key
  1737 000069A2 800E120001              	or	byte [post_flags],post_setup
  1738                                  
  1739                                  .test_no_key:
  1740 000069A7 58                      	pop	ax
  1741 000069A8 E83E00                  	call	ram_test_block
  1742 000069AB 721D                    	jc	.test_error		; error in last test
  1743 000069AD 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  1744 000069B0 3B061300                	cmp	ax,word [memory_size]
  1745 000069B4 72C7                    	jb	.test_loop
  1746                                  
  1747 000069B6 50                      	push	ax
  1748 000069B7 B031                    	mov	al,e_ram_complete	; RAM scan complete
  1749 000069B9 E680                    	out	post_reg,al
  1750 000069BB 58                      	pop	ax
  1751                                  
  1752 000069BC EB2A                    	jmp	.test_done
  1753                                  
  1754                                  .test_esc:
  1755 000069BE 58                      	pop	ax
  1756 000069BF A11300                  	mov	ax,word [memory_size]
  1757                                  
  1758 000069C2 50                      	push	ax
  1759 000069C3 B032                    	mov	al,e_ram_esc		; RAM scan canceled
  1760 000069C5 E680                    	out	post_reg,al
  1761 000069C7 58                      	pop	ax
  1762                                  
  1763 000069C8 EB1E                    	jmp	.test_done
  1764                                  
  1765                                  .test_error:
  1766 000069CA A31300                  	mov	word [memory_size],ax	; store size of good memory
  1767 000069CD BE[1A03]                	mov	si,msg_ram_error
  1768 000069D0 E8DDBE                  	call	print
  1769 000069D3 E817BF                  	call	print_dec
  1770 000069D6 BE[9603]                	mov	si,msg_kib
  1771 000069D9 E8D4BE                  	call	print
  1772 000069DC BE[8B00]                	mov	si,msg_crlf
  1773 000069DF E8CEBE                  	call	print
  1774                                  
  1775 000069E2 50                      	push	ax
  1776 000069E3 B055                    	mov	al,e_ram_fail		; RAM scan failed
  1777 000069E5 E680                    	out	post_reg,al
  1778 000069E7 58                      	pop	ax
  1779                                  
  1780                                  .test_done:
  1781 000069E8 C3                      	ret
  1782                                  
  1783                                  ;=========================================================================
  1784                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  1785                                  ; Input:
  1786                                  ;	AX = address of the memory to test (in KiB)
  1787                                  ; Output:
  1788                                  ;	CF = status
  1789                                  ;		0 = passed
  1790                                  ;		1 = failed
  1791                                  ;-------------------------------------------------------------------------
  1792                                  ram_test_block:
  1793 000069E9 50                      	push	ax
  1794 000069EA 53                      	push	bx
  1795 000069EB 51                      	push	cx
  1796 000069EC 56                      	push	si
  1797 000069ED 57                      	push	di
  1798 000069EE 1E                      	push	ds
  1799 000069EF 06                      	push	es
  1800                                  
  1801 000069F0 B106                    	mov	cl,6			; convert KiB to segment address
  1802 000069F2 D3E0                    	shl	ax,cl			; (multiply by 64)
  1803 000069F4 8ED8                    	mov	ds,ax
  1804 000069F6 8EC0                    	mov	es,ax
  1805 000069F8 31F6                    	xor	si,si
  1806 000069FA 31FF                    	xor	di,di
  1807 000069FC BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  1808 000069FF B8AA55                  	mov	ax,55AAh		; first test pattern
  1809 00006A02 89D9                    	mov	cx,bx
  1810 00006A04 F3AB                        rep	stosw				; store test pattern
  1811 00006A06 89D9                    	mov	cx,bx			; RAM test block size
  1812                                  .1:
  1813 00006A08 AD                      	lodsw
  1814 00006A09 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  1815 00006A0C 7522                    	jne	.fail
  1816 00006A0E E2F8                    	loop	.1
  1817 00006A10 31F6                    	xor	si,si
  1818 00006A12 31FF                    	xor	di,di
  1819 00006A14 B855AA                  	mov	ax,0AA55h		; second test pattern
  1820 00006A17 89D9                    	mov	cx,bx			; RAM test block size
  1821 00006A19 F3AB                        rep stosw				; store test pattern
  1822 00006A1B 89D9                    	mov	cx,bx			; RAM test block size
  1823                                  .2:
  1824 00006A1D AD                      	lodsw
  1825 00006A1E 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  1826 00006A21 750D                    	jne	.fail
  1827 00006A23 E2F8                    	loop	.2
  1828 00006A25 31FF                    	xor	di,di
  1829 00006A27 31C0                    	xor	ax,ax			; zero
  1830 00006A29 89D9                    	mov	cx,bx			; RAM test block size
  1831 00006A2B F3AB                        rep stosw				; zero the memory
  1832 00006A2D F8                      	clc				; test passed, clear CF
  1833 00006A2E EB01                    	jmp	.exit
  1834                                  
  1835                                  .fail:
  1836 00006A30 F9                      	stc				; test failed, set CF
  1837                                  	
  1838                                  .exit:
  1839 00006A31 07                      	pop	es
  1840 00006A32 1F                      	pop	ds
  1841 00006A33 5F                      	pop	di
  1842 00006A34 5E                      	pop	si
  1843 00006A35 59                      	pop	cx
  1844 00006A36 5B                      	pop	bx
  1845 00006A37 58                      	pop	ax
  1846 00006A38 C3                      	ret
  1847                                  
  1848                                  ;=========================================================================
  1849                                  ; Includes with fixed entry points (for IBM compatibility)
  1850                                  ;-------------------------------------------------------------------------
  1851                                  %include	"fnt00-7F.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; fnt00-7F.inc - Font for graphics modes
     3                              <1> ;       Characters from 00h to 7Fh
     4                              <1> ;-------------------------------------------------------------------------
     5                              <1> ;
     6                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     7                              <1> ;
     8                              <1> ; This font is borrowed from kbd package (alt-8x8)
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;=========================================================================
    24 00006A39 FF<rep 35h>         <1> 	setloc	0FA6Eh			; IBM graphics char set entry
    24          ******************  <1>  warning: Inserting 53 bytes [-w+user]
    25                              <1> gfx_font:
    26 00006A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
    27 00006A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
    28 00006A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
    29 00006A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
    30 00006A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
    31 00006A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
    32 00006A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
    33 00006AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
    34 00006AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
    35 00006AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
    36 00006ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
    37 00006AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
    38 00006ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
    39 00006AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
    40 00006ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
    41 00006AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
    42 00006AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
    43 00006AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
    44 00006AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
    45 00006B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
    46 00006B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
    47 00006B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
    48 00006B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
    49 00006B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
    50 00006B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
    51 00006B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
    52 00006B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
    53 00006B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
    54 00006B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
    55 00006B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
    56 00006B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
    57 00006B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
    58 00006B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
    59 00006B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
    60 00006B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
    61 00006B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
    62 00006B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
    63 00006B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
    64 00006B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
    65 00006BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
    66 00006BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
    67 00006BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
    68 00006BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
    69 00006BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
    70 00006BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
    71 00006BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
    72 00006BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
    73 00006BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
    74 00006BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
    75 00006BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
    76 00006BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
    77 00006C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
    78 00006C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
    79 00006C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
    80 00006C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
    81 00006C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
    82 00006C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
    83 00006C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
    84 00006C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
    85 00006C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
    86 00006C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
    87 00006C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
    88 00006C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
    89 00006C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
    90 00006C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
    91 00006C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
    92 00006C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
    93 00006C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
    94 00006C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
    95 00006C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
    96 00006C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
    97 00006CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
    98 00006CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
    99 00006CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
   100 00006CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
   101 00006CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
   102 00006CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
   103 00006CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   104 00006CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
   105 00006CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
   106 00006CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
   107 00006CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
   108 00006CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
   109 00006D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
   110 00006D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
   111 00006D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
   112 00006D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
   113 00006D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
   114 00006D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
   115 00006D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
   116 00006D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
   117 00006D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
   118 00006D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
   119 00006D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
   120 00006D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
   121 00006D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
   122 00006D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
   123 00006D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
   124 00006D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   125 00006D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
   126 00006D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
   127 00006D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
   128 00006D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
   129 00006DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
   130 00006DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
   131 00006DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
   132 00006DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
   133 00006DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   134 00006DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
   135 00006DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   136 00006DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
   137 00006DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
   138 00006DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
   139 00006DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
   140 00006DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
   141 00006E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
   142 00006E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
   143 00006E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
   144 00006E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
   145 00006E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
   146 00006E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
   147 00006E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
   148 00006E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
   149 00006E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
   150 00006E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
   151 00006E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
   152 00006E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
   153 00006E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  1852                                  %include	"time2.inc"
     1                              <1> ;=========================================================================
     2                              <1> ; time2.int - BIOS Time Services
     3                              <1> ;       INT 1Ah - BIOS Time Serivces
     4                              <1> ;		dispatcher
     5                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
     6                              <1> ;-------------------------------------------------------------------------
     7                              <1> ;
     8                              <1> ; Compiles with NASM 2.13.02, might work with other versions
     9                              <1> ;
    10                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    11                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    12                              <1> ;
    13                              <1> ; This program is free software: you can redistribute it and/or modify
    14                              <1> ; it under the terms of the GNU General Public License as published by
    15                              <1> ; the Free Software Foundation, either version 3 of the License, or
    16                              <1> ; (at your option) any later version.
    17                              <1> ;
    18                              <1> ; This program is distributed in the hope that it will be useful,
    19                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                              <1> ; GNU General Public License for more details.
    22                              <1> ;
    23                              <1> ; You should have received a copy of the GNU General Public License
    24                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    25                              <1> ;
    26                              <1> ;=========================================================================
    27                              <1> 
    28                              <1> ;=========================================================================
    29                              <1> ; int_1A - BIOS Time Services
    30                              <1> ; Note: see time1.inc for functions implementation
    31                              <1> ;-------------------------------------------------------------------------
    32                              <1> ;	setloc	0FE6Eh			; INT 1A Entry Point
    33                              <1> int_1A:
    34 00006E6E 53                  <1> 	push	bx
    35 00006E6F 1E                  <1> 	push	ds
    36 00006E70 BB4000              <1> 	mov	bx,biosdseg
    37 00006E73 8EDB                <1> 	mov	ds,bx
    38 00006E75 80FC08              <1> 	cmp	ah,.max/2
    39 00006E78 731B                <1> 	jae	int_1A_exit
    40 00006E7A B700                <1> 	mov	bh,0
    41 00006E7C 88E3                <1> 	mov	bl,ah
    42 00006E7E D1E3                <1> 	shl	bx,1
    43 00006E80 2EFFA7[856E]        <1>     cs	jmp	near [.dispatch+bx]
    44                              <1> .dispatch:
    45 00006E85 [2912]              <1> 	dw	int_1A_fn00
    46 00006E87 [3B12]              <1> 	dw	int_1A_fn01
    47                              <1> %ifdef AT_RTC
    48 00006E89 [4B12]              <1> 	dw	int_1A_fn02
    49 00006E8B [7D12]              <1> 	dw	int_1A_fn03
    50 00006E8D [C212]              <1> 	dw	int_1A_fn04
    51 00006E8F [F212]              <1> 	dw	int_1A_fn05
    52 00006E91 [3113]              <1> 	dw	int_1A_fn06
    53 00006E93 [8213]              <1> 	dw	int_1A_fn07
    54                              <1> %endif ; AT_RTC
    55                              <1> .max	equ	$-.dispatch
    56                              <1> int_1A_exit:
    57 00006E95 1F                  <1> 	pop	ds
    58 00006E96 5B                  <1> 	pop	bx
    59 00006E97 CF                  <1> 	iret
    60                              <1> int_1A_exitf:
    61 00006E98 1F                  <1> 	pop	ds
    62 00006E99 5B                  <1> 	pop	bx
    63 00006E9A CA0200              <1> 	retf	2
    64                              <1> 
    65                              <1> ;=========================================================================
    66                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
    67                              <1> ;-------------------------------------------------------------------------
    68                              <1> ;	setloc	0FEA5h			; INT 08 Entry Point
    69                              <1> int_08:
    70 00006E9D 50                  <1> 	push	ax
    71 00006E9E 52                  <1> 	push	dx
    72 00006E9F 1E                  <1> 	push	ds
    73 00006EA0 B84000              <1> 	mov	ax,biosdseg
    74 00006EA3 8ED8                <1> 	mov	ds,ax
    75 00006EA5 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
    76 00006EAA 7411                <1> 	jz	.1
    77 00006EAC FE0E4000            <1> 	dec	byte [fdc_motor_tout]
    78 00006EB0 750B                <1> 	jnz	.1
    79 00006EB2 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
    80 00006EB7 B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
    81 00006EB9 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
    82 00006EBC EE                  <1> 	out	dx,al
    83                              <1> .1:
    84 00006EBD FF066C00            <1> 	inc	word [ticks_lo]
    85 00006EC1 7504                <1> 	jnz	.2
    86 00006EC3 FF066E00            <1> 	inc	word [ticks_hi]
    87                              <1> .2:
    88 00006EC7 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
    89 00006ECC 7519                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
    90 00006ECE 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
    91 00006ED4 7511                <1> 	jnz	.3
    92 00006ED6 C7066E000000        <1> 	mov	word [ticks_hi],0
    93 00006EDC C7066C000000        <1> 	mov	word [ticks_lo],0
    94 00006EE2 C606700001          <1> 	mov	byte [new_day],1
    95                              <1> .3:
    96 00006EE7 CD1C                <1> 	int	1Ch			; User timer interrupt
    97 00006EE9 B020                <1> 	mov	al,20h
    98 00006EEB E620                <1> 	out	pic1_reg0,al
    99 00006EED 1F                  <1> 	pop	ds
   100 00006EEE 5A                  <1> 	pop	dx
   101 00006EEF 58                  <1> 	pop	ax
   102 00006EF0 CF                  <1> 	iret
  1853                                  
  1854                                  ;=========================================================================
  1855                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  1856                                  ;-------------------------------------------------------------------------
  1857 00006EF1 FF<rep 32h>             	setloc	0FF23h			; Spurious IRQ Handler Entry Point
  1857          ******************       warning: Inserting 50 bytes [-w+user]
  1858                                  int_ignore:
  1859 00006F23 50                      	push	ax
  1860 00006F24 1E                      	push	ds
  1861 00006F25 B84000                  	mov	ax,biosdseg
  1862 00006F28 8ED8                    	mov	ds,ax
  1863 00006F2A B00B                    	mov	al,0Bh			; PIC OCW3 - read in-service register
  1864 00006F2C E620                    	out	pic1_reg0,al
  1865 00006F2E 90                      	nop
  1866 00006F2F E420                    	in	al,pic1_reg0		; get IRQ number
  1867 00006F31 88C4                    	mov	ah,al
  1868 00006F33 08C0                    	or	al,al
  1869 00006F35 7504                    	jnz	.1
  1870 00006F37 B4FF                    	mov	ah,0FFh
  1871 00006F39 EB0A                    	jmp	.2
  1872                                  .1:
  1873 00006F3B E421                    	in	al,pic1_reg1		; clear the interrupt
  1874 00006F3D 08E0                    	or	al,ah
  1875 00006F3F E621                    	out	pic1_reg1,al
  1876 00006F41 B020                    	mov	al,20h			; end of interrupt
  1877 00006F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
  1878                                  .2:
  1879 00006F45 88266B00                	mov	byte [last_irq],ah
  1880 00006F49 1F                      	pop	ds
  1881 00006F4A 58                      	pop	ax
  1882 00006F4B CF                      	iret
  1883                                  
  1884                                  ;=========================================================================
  1885                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
  1886                                  ;-------------------------------------------------------------------------
  1887 00006F4C FF<rep 7h>              	setloc	0FF53h			; Dummy Interrupt Handler
  1887          ******************       warning: Inserting 7 bytes [-w+user]
  1888                                  int_dummy:
  1889 00006F53 CF                      	iret
  1890                                  
  1891                                  ;=========================================================================
  1892                                  ; int_05 - BIOS Print Screen
  1893                                  ;-------------------------------------------------------------------------
  1894                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
  1895                                  int_05:
  1896 00006F54 FB                      	sti
  1897 00006F55 50                      	push	ax
  1898 00006F56 53                      	push	bx
  1899 00006F57 51                      	push	cx
  1900 00006F58 52                      	push	dx
  1901 00006F59 1E                      	push	ds
  1902 00006F5A B84000                  	mov	ax,biosdseg
  1903 00006F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
  1904 00006F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
  1905 00006F64 746A                    	je	.exit			; print screen is already in progress
  1906 00006F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
  1907                                  					; signal that print screen is running
  1908                                  
  1909 00006F6B B40F                    	mov	ah,0Fh			; get video mode parameters
  1910 00006F6D CD10                    	int	10h			; returns number of columns in AH
  1911                                  					; and active display page in BH
  1912 00006F6F 88E1                    	mov	cl,ah			; store number columns
  1913                                  
  1914 00006F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
  1915 00006F75 08ED                    	or	ch,ch
  1916 00006F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
  1917                                  
  1918 00006F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
  1919 00006F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
  1920 00006F7E 7602                    	jbe	.get_cursor_pos
  1921                                  
  1922                                  .wrong_num_rows:
  1923 00006F80 B519                    	mov	ch,25			; assume 25 rows
  1924                                  
  1925                                  .get_cursor_pos:
  1926 00006F82 B403                    	mov	ah,03h			; get cursor position and size
  1927 00006F84 CD10                    	int	10h			; returns cursor position in DX
  1928 00006F86 52                      	push	dx			; save original position / DX in stack
  1929                                  
  1930                                  	
  1931 00006F87 B40D                    	mov	ah,0Dh			; move to the next line
  1932 00006F89 E85100                  	call	.print_char
  1933 00006F8C 7548                    	jnz	.error
  1934 00006F8E B40A                    	mov	ah,0Ah
  1935 00006F90 E84A00                  	call	.print_char
  1936 00006F93 7541                    	jnz	.error
  1937                                  
  1938 00006F95 B600                    	mov 	dh,0			; start from the first row (0)
  1939                                  
  1940                                  .row_loop:
  1941 00006F97 B200                    	mov 	dl,0			; start from the first column (0)
  1942                                  
  1943                                  .column_loop:
  1944 00006F99 B402                    	mov	ah,02h
  1945 00006F9B CD10                    	int	10h			; set cursor position (position in DX)
  1946                                  
  1947 00006F9D B408                    	mov	ah,08h
  1948 00006F9F CD10                    	int	10h			; read character at cursor position
  1949                                  
  1950 00006FA1 3C20                    	cmp	al,20h			; control character?
  1951 00006FA3 7302                    	jae	.continue		; no, print it
  1952 00006FA5 B020                    	mov	al,20h			; print space instead
  1953                                  
  1954                                  .continue:
  1955 00006FA7 E83300                  	call	.print_char
  1956 00006FAA 752A                    	jnz	.error
  1957 00006FAC FEC2                    	inc	dl
  1958 00006FAE 38CA                    	cmp	dl,cl			; on the last column?
  1959 00006FB0 72E7                    	jb	.column_loop		; print next column
  1960                                  
  1961 00006FB2 B40D                    	mov	ah,0Dh			; move to the next line
  1962 00006FB4 E82600                  	call	.print_char
  1963 00006FB7 751D                    	jnz	.error
  1964 00006FB9 B40A                    	mov	ah,0Ah
  1965 00006FBB E81F00                  	call	.print_char
  1966 00006FBE 7516                    	jnz	.error
  1967                                  
  1968 00006FC0 FEC6                    	inc	dh
  1969 00006FC2 38EE                    	cmp	dh,ch			; on the last row?
  1970 00006FC4 72D1                    	jb	.row_loop		; print next row
  1971                                  
  1972 00006FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
  1973                                  					; ready for the next call
  1974                                  
  1975                                  .restore_cursor:
  1976 00006FCB 5A                      	pop	dx			; DX = original cursor position
  1977 00006FCC B402                    	mov	ah,02h
  1978 00006FCE CD10                    	int	10h			; set cursor position (position in DX)
  1979                                  
  1980                                  .exit:
  1981 00006FD0 1F                      	pop	ds
  1982 00006FD1 5A                      	pop	dx
  1983 00006FD2 59                      	pop	cx
  1984 00006FD3 5B                      	pop	bx
  1985 00006FD4 58                      	pop	ax
  1986 00006FD5 CF                      	iret
  1987                                  
  1988                                  .error:
  1989 00006FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
  1990                                  					; signal failure
  1991 00006FDB EBEE                    	jmp	.restore_cursor
  1992                                  	
  1993                                  
  1994                                  .print_char:
  1995 00006FDD 52                      	push	dx
  1996 00006FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
  1997 00006FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
  1998 00006FE2 CD17                    	int	17h
  1999 00006FE4 5A                      	pop	dx
  2000 00006FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
  2001 00006FE8 C3                      	ret
  2002                                  
  2003                                  ;=========================================================================
  2004                                  ; start - at power up or reset execution starts here (F000:FFF0)
  2005                                  ;-------------------------------------------------------------------------
  2006 00006FE9 FF<rep 7h>                      setloc	0FFF0h			; Power-On Entry Point
  2006          ******************       warning: Inserting 7 bytes [-w+user]
  2007                                  start:
  2008                                      ;    jmp     bioscseg:cold_start
  2009 00006FF0 EA[0030]00F0                     jmp     bioscseg:reset     ; Start the Nanocomp Monitor, use B for BIOS
  2010                                  
  2011                                  	setloc	0FFF5h			; ROM Date in ASCII
  2012 00006FF5 30392F32392F3233        	db	DATE			; BIOS release date MM/DD/YY
  2013 00006FFD 20                      	db	20h
  2014                                  
  2015                                  	setloc	0FFFEh			; System Model byte
  2016 00006FFE FC                      	db	MODEL_BYTE
  2017 00006FFF FF                      	db	0ffh
